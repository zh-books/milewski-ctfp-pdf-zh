% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{一}{个范畴（category）是小的（small）}，如果它的对象构成一个集合。但是我们知道，有些事物比集合更大。众所周知，在标准集合论（Zermelo-Fraenkel理论，通常附加选择公理）的框架下，不能形成所有集合的集合。因此，所有集合的范畴必须是大的。数学上有一些技巧，如Grothendieck宇宙，可以用来定义超越集合的集合。这些技巧使我们可以讨论大范畴（large categories）。

一个范畴是\emph{局部小的}（locally small），如果任何两个对象之间的态射（morphism）形成一个集合。如果它们不能形成一个集合，我们就必须重新思考一些定义。特别是，如果我们甚至不能从一个集合中选择态射，那么复合态射（composition of morphisms）又意味着什么？解决方案是通过用来自其他某个范畴 $\cat{V}$ 的\emph{对象}替换同态集（hom-sets）来引导我们自己。区别在于，一般来说，对象没有元素，所以我们不再允许讨论单个态射。我们必须用可以整体操作的同态对象（hom-objects）的术语来定义一个\emph{加厚范畴}（enriched category）的所有性质。为了做到这一点，提供同态对象的范畴必须具有额外的结构——它必须是一个\emph{单积范畴}（monoidal category）。如果我们称这个单积范畴为 $\cat{V}$，我们可以讨论一个范畴 $\cat{C}$ 加厚于 $\cat{V}$ 的情形。

除了规模上的原因，我们可能还对将同态集推广为比单纯集合更具结构的事物感兴趣。例如，传统范畴没有定义对象之间距离（distance）的概念。两个对象要么通过态射连接，要么不连接。与给定对象相连接的所有对象都是它的邻居。与现实生活不同，在一个范畴中，一个朋友的朋友的朋友与我的知心好友一样接近。在一个适当加厚的范畴中，我们可以定义对象之间的距离。

还有一个非常实际的理由来了解加厚范畴，因为一个非常有用的在线范畴知识来源，\urlref{https://ncatlab.org/}{nLab}，主要是以加厚范畴的术语编写的。

\section{为什么选择单积范畴？\\ \textmd{Why Monoidal Category?}}

当构造一个\emph{加厚范畴}（enriched category）时，我们必须记住，当我们用 $\Set$ 替换\emph{单积范畴}（monoidal category）并用同态集（hom-sets）替换同态对象（hom-objects）时，我们应该能够恢复通常的定义。实现这一目标的最好方法是从通常的定义开始，并不断以无元素（point-free）方式重新表述它们——即不命名集合的元素。

让我们从复合的定义开始。通常，它接受一对态射，一个来自 $\cat{C}(b, c)$，另一个来自 $\cat{C}(a, b)$，并将其映射到来自 $\cat{C}(a, c)$ 的态射。换句话说，它是一个映射：
\[\cat{C}(b, c)\times{}\cat{C}(a, b) \to \cat{C}(a, c)\]
这是一个集合之间的函数——其中一个是两个同态集的笛卡尔积（Cartesian product）。通过用更一般的笛卡尔积替换笛卡尔积，这个公式可以很容易地推广。范畴积（categorical product）可以起作用，但我们可以更进一步，使用一个完全通用的\emph{张量积}（tensor product）。

接下来是恒等态射（identity morphisms）。我们可以用从单元素集合 $\cat{1}$ 到 $\cat{C}(a, a)$ 的函数来定义它们，而不是从同态集中选择单个元素：
\[j_a \Colon \cat{1} \to \cat{C}(a, a)\]
同样，我们可以用终对象（terminal object）替换单元素集合，但我们可以更进一步，用张量积的单位元 $i$ 替换它。

正如你所见，从某个\emph{单积范畴}（monoidal category） $\cat{V}$ 取出的对象是替换同态集的好候选者。

\section{单积范畴\\ \textmd{Monoidal Category}}

我们之前讨论过\emph{单积范畴}（monoidal category），但值得重新说明其定义。一个单积范畴定义了一个张量积，它是一个双函子：
\[\otimes \Colon \cat{V}\times{}\cat{V} \to \cat{V}\]
我们希望张量积是结合的，但满足结合律的自然同构就足够了。这种同构称为结合子（associator）。它的分量是：
\[\alpha_{a b c} \Colon (a \otimes b) \otimes c \to a \otimes (b \otimes c)\]
它必须在所有三个参数中自然。

一个单积范畴还必须定义一个特殊的单位对象 $i$，它作为张量积的单位元；同样是通过自然同构。这两个同构分别称为左结合子（left unitor）和右结合子（right unitor），它们的分量是：
\begin{align*}
  \lambda_a & \Colon i \otimes a \to a \\
  \rho_a    & \Colon a \otimes i \to a
\end{align*}
结合子和单位元必须满足一致性条件：

\begin{figure}[H]
  \centering
  \begin{tikzcd}[row sep=large]
    ((a \otimes b) \otimes c) \otimes d
    \arrow[d, "\alpha_{(a \otimes b)cd}"]
    \arrow[rr, "\alpha_{abc} \otimes \id_d"]
    & & (a \otimes (b \otimes c)) \otimes d
    \arrow[d, "\alpha_{a(b \otimes c)d}"] \\
    (a \otimes b) \otimes (c \otimes d)
    \arrow[rd, "\alpha_{ab(c \otimes d)}"]
    & & a \otimes ((b \otimes c) \otimes d)
    \arrow[ld, "\id_a \otimes \alpha_{bcd}"] \\
    & a \otimes (b \otimes (c \otimes d))
  \end{tikzcd}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzcd}[row sep=large]
  (a \otimes i) \otimes b
  \arrow[dr, "\rho_{a} \otimes \id_b"']
  \arrow[rr, "\alpha_{aib}"]
  & & a \otimes (i \otimes b)
  \arrow[dl, "\id_a \otimes \lambda_b"] \\
  & a \otimes b
  \end{tikzcd}
\end{figure}

\noindent
一个单积范畴被称为\newterm{对称的}（symmetric），如果它有一个自然同构，其分量为：
\[\gamma_{a b} \Colon a \otimes b \to b \otimes a\]
且其``平方为一''：
\[\gamma_{b a} \circ \gamma_{a b} = \idarrow[a \otimes b]\]
并且它与单积结构是一致的。

关于单积范畴的一个有趣之处是，你可以定义内部同态（internal hom，也就是函数对象）作为张量积的右伴随（right adjoint）。你可能还记得，函数对象或指数（exponential）的标准定义是通过范畴积的右伴随来实现的。一个范畴，如果这样的对象存在于任何一对对象之间，就被称为笛卡尔闭范畴（Cartesian closed）。这里是一个定义单积范畴内部同态的伴随关系：
\[\cat{V}(a \otimes b, c) \sim \cat{V}(a, [b, c])\]
参照\urlref{http://www.tac.mta.ca/tac/reprints/articles/10/tr10.pdf}{G. M. Kelly}，我使用符号${[}b, c{]}$表示内部同态。这一伴随关系的余单元（counit）是一个自然变换，其分量被称为评估态射（evaluation morphisms）：
\[\varepsilon_{a b} \Colon ([a, b] \otimes a) \to b\]
注意，如果张量积不是对称的，我们可以定义另一个内部同态，记为${[}{[}a, c{]}{]}$，使用以下伴随关系：
\[\cat{V}(a \otimes b, c) \sim \cat{V}(b, [[a, c]])\]
一个单积范畴，如果这两者都被定义出来，则称为\newterm{双闭的}（biclosed）。一个非双闭范畴的例子是$\Set$中的端函子范畴（endofunctors），其中函子合成作为张量积。我们用这个范畴来定义Monad。

\section{加厚范畴\\ \textmd{Enriched Category}}

一个加厚于单积范畴 $\cat{V}$ 的范畴 $\cat{C}$ 用同态对象替换了同态集。对于 $\cat{C}$ 中的每一对对象 $a$ 和 $b$，我们关联一个对象 $\cat{C}(a, b)$ 在 $\cat{V}$ 中。我们对同态对象使用与同态集相同的符号，理解为它们不包含态射。另一方面，$\cat{V}$ 是一个常规的（非加厚的）具有同态集和态射的范畴。所以我们并没有完全摆脱集合——我们只是将它们隐藏了起来。

既然我们不能讨论 $\cat{C}$ 中的单个态射，那么复合态射的操作就由 $\cat{V}$ 中的态射家族替代：
\[\circ \Colon \cat{C}(b, c) \otimes \cat{C}(a, b) \to \cat{C}(a, c)\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.45\textwidth]{images/composition.jpg}
\end{figure}

\noindent
同样，恒等态射被替换为 $\cat{V}$ 中的一个态射家族：
\[j_a \Colon i \to \cat{C}(a, a)\]
这里的 $i$ 是 $\cat{V}$ 中的张量单位元。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/id.jpg}
\end{figure}

\noindent
复合态射的结合性由 $\cat{V}$ 中的结合子定义：

\begin{figure}[H]
  \centering
  \begin{tikzcd}[column sep=large]
  (\cat{C}(c,d) \otimes \cat{C}(b,c)) \otimes \cat{C}(a,b)
  \arrow[r, "\circ\otimes\id"]
  \arrow[dd, "\alpha"]
  & \cat{C}(b,d) \otimes \cat{C}(a,b)
  \arrow[dr, "\circ"] \\
  & & \cat{C}(a,d) \\
  \cat{C}(c,d) \otimes (\cat{C}(b,c) \otimes \cat{C}(a,b))
  \arrow[r, "\id\otimes\circ"]
  & \cat{C}(c,d) \otimes \cat{C}(a,c)
  \arrow[ur, "\circ"]
  \end{tikzcd}
\end{figure}

\noindent
单位律同样以单位元的形式表达：

\begin{figure}[H]
  \centering
  \begin{subfigure}
    \centering
    \begin{tikzcd}[row sep=large]
      \cat{C}(a,b) \otimes i
      \arrow[rr, "\id \otimes j_a"]
      \arrow[dr, "\rho"]
      & & \cat{C}(a,b) \otimes \cat{C}(a,a)
      \arrow[dl, "\circ"] \\
      & \cat{C}(a,b)
    \end{tikzcd}
  \end{subfigure}
  \hspace{1cm}
  \begin{subfigure}
    \centering
    \begin{tikzcd}[row sep=large]
      i \otimes \cat{C}(a,b)
      \arrow[rr, "j_b \otimes \id"]
      \arrow[dr, "\lambda"]
      & & \cat{C}(b,b) \otimes \cat{C}(a,b)
      \arrow[dl, "\circ"] \\
      & \cat{C}(a,b)
    \end{tikzcd}
  \end{subfigure}
\end{figure}

\section{预序（Preorders）\\ \textmd{Preorders}}

\emph{预序}（preorder）定义为一个稀薄范畴（thin category），其中每个同态集要么为空，要么是单元集。我们将一个非空的 $\cat{C}(a, b)$ 集解释为 $a$ 小于或等于 $b$ 的证明。这样的范畴可以解释为加厚于一个非常简单的单积范畴，该范畴只包含两个对象，$0$ 和 $1$（有时称为 $\mathit{False}$ 和 $\mathit{True}$）。除了强制性的恒等态射外，这个范畴还有一个从 $0$ 到 $1$ 的态射，称为 $0 \to 1$。一个简单的单积结构可以在其中建立，张量积模拟 $0$ 和 $1$ 的简单算术运算（即，唯一的非零积是 $1 \otimes 1$）。这个范畴中的单位对象是 $1$。这是一个严格的单积范畴，即结合子和单位元是恒等态射。

由于在预序中，同态集要么为空，要么是单元集，我们可以很容易地用我们这个微小范畴中的同态对象替换它。加厚预序 $\cat{C}$ 对于任意一对对象 $a$ 和 $b$ 有一个同态对象 $\cat{C}(a, b)$。如果 $a$ 小于或等于 $b$，这个对象是 $1$；否则它是 $0$。

让我们来看一下复合态射。任何两个对象的张量积是 $0$，除非它们都是 $1$，在这种情况下它是 $1$。如果它是 $0$，那么我们有两个选择用于复合态射：它可以是 $\idarrow[0]$ 或 $0 \to 1$。但是如果它是 $1$，那么唯一的选择是 $\idarrow[1]$。将此翻译回关系中，这表示如果 $a \leqslant b$ 且 $b \leqslant c$ 那么 $a \leqslant c$，这正是我们所需的传递律。

恒等态射如何？它是从 $1$ 到 $\cat{C}(a, a)$ 的态射。唯一从 $1$ 出发的态射是 $\idarrow[1]$，所以 $\cat{C}(a, a)$ 必须是 $1$。这意味着 $a \leqslant a$，这是预序的反身性定律。因此，如果我们将预序实现为加厚范畴，传递性和反身性都会自动强制执行。

\section{度量空间\\ \textmd{Metric Spaces}}

一个有趣的例子来自\urlref{http://www.tac.mta.ca/tac/reprints/articles/1/tr1.pdf}{William Lawvere}。他注意到度量空间（metric space）可以用加厚范畴来定义。度量空间定义了任意两个对象之间的距离。这个距离是一个非负实数。将无穷大作为一个可能的值是方便的。如果距离是无穷大的，就无法从起点对象到达目标对象。

距离必须满足的一些显而易见的属性之一是，距离从一个对象到它自身必须为零。另一个是三角不等式：直接距离不大于带有中间站点的距离之和。我们不要求距离是对称的，这在开始时可能看起来很奇怪，但正如Lawvere解释的那样，你可以想象在一个方向上你在上坡，而在另一个方向上你在下坡。无论如何，对称性可以稍后作为附加约束强加。

那么，如何将度量空间转换为范畴语言？我们必须构造一个范畴，在其中同态对象是距离。注意，距离不是态射，而是同态对象。同态对象如何成为一个数字？只有当我们可以构造一个单积范畴 $\cat{V}$，在其中这些数字是对象。非负实数（加上无穷大）形成一个全序，所以它们可以被视为稀薄范畴。在两个这样的数字 $x$ 和 $y$ 之间存在一个态射，当且仅当 $x \geqslant y$（注意：这是与传统预序定义相反的方向）。单积结构由加法给出，零作为单位对象。换句话说，两个数字的张量积是它们的和。

一个度量空间是加厚于这样的单积范畴的范畴。从对象 $a$ 到对象 $b$ 的同态对象 $\cat{C}(a, b)$ 是一个非负（可能是无穷大的）数，我们称之为从 $a$ 到 $b$ 的距离。让我们看看在这样的范畴中，我们为恒等态射和复合态射得到了什么。

根据我们的定义，从张量单位（即数字零）到同态对象 $\cat{C}(a, a)$ 的态射是关系：
\[0 \geqslant \cat{C}(a, a)\]
由于 $\cat{C}(a, a)$ 是一个非负数，这个条件告诉我们从 $a$ 到 $a$ 的距离总是零。检查！

现在让我们讨论复合态射。我们从两个相邻同态对象 $\cat{C}(b, c) \otimes \cat{C}(a, b)$ 的张量积开始。我们已经定义了张量积作为两个距离的和。复合态射是 $\cat{V}$ 中从这个积到 $\cat{C}(a, c)$ 的态射。$\cat{V}$ 中的态射定义为大于或等于关系。换句话说，从 $a$ 到 $b$ 和从 $b$ 到 $c$ 的距离之和大于或等于从 $a$ 到 $c$ 的距离。但这正是标准的三角不等式。检查！

通过将度量空间重新构造成一个加厚范畴，我们``免费''获得了三角不等式和零自距离。

\section{加厚函子\\ \textmd{Enriched Functors}}

函子（functor）的定义涉及态射的映射。在加厚环境中，我们没有单个态射的概念，所以我们必须整体处理同态对象。同态对象是单积范畴 $\cat{V}$ 中的对象，并且我们可以使用它们之间的态射。因此，在加厚于同一个单积范畴 $\cat{V}$ 的范畴之间定义加厚函子是有意义的。然后我们可以使用 $\cat{V}$ 中的态射来映射两个加厚范畴之间的同态对象。

一个\newterm{加厚函子}（enriched functor）$F$ 在两个范畴 $\cat{C}$ 和 $\cat{D}$ 之间，除了将对象映射到对象，还为 $\cat{C}$ 中的每一对对象分配一个 $\cat{V}$ 中的态射：
\[F_{a b} \Colon \cat{C}(a, b) \to \cat{D}(F a, F b)\]
函子是一个保持结构的映射。对于常规函子，这意味着保持复合和恒等态射。在加厚环境中，保持复合意味着以下图表交换：

\begin{figure}[H]
  \centering
  \begin{tikzcd}[column sep=large, row sep=large]
    \cat{C}(b,c) \otimes \cat{C}(a,b)
    \arrow[r, "\circ"]
    \arrow[d, "F_{bc} \otimes F_{ab}"]
    & \cat{C}(a,c)
    \arrow[d, "F_{ac}"] \\
    \cat{D}(F b, F c) \otimes \cat{D}(F a, F b)
    \arrow[r,  "\circ"]
    & \cat{D}(F a, F c)
  \end{tikzcd}
\end{figure}

\noindent
保持恒等性被替换为保持\emph{选择}恒等态射的 $\cat{V}$ 中的态射：

\begin{figure}[H]
  \centering
  \begin{tikzcd}[row sep=large]
    & i \arrow[dl, "j_a"'] \arrow[dr, "j_{F a}"] & \\
    \cat{C}(a,a)
    \arrow[rr, "F_{aa}"]
    & & \cat{D}(F a, F a)
  \end{tikzcd}
\end{figure}

\section{自加厚\\ \textmd{Self Enrichment}}

一个封闭对称单积范畴（closed symmetric monoidal category）可以通过用内部同态（internal homs）替换同态集来自加厚。为了使其工作，我们必须为内部同态定义复合法。换句话说，我们必须实现具有以下签名的态射：
\[[b, c] \otimes [a, b] \to [a, c]\]
这与其他任何编程任务没有太大不同，只是，在范畴论中，我们通常使用无元素实现。我们首先指定其元素应该是什么集合。在这种情况下，它是同态集的一个成员：
\[\cat{V}([b, c] \otimes [a, b], [a, c])\]
这个同态集与以下同构：
\[\cat{V}(([b, c] \otimes [a, b]) \otimes a, c)\]
我刚刚使用了定义内部同态 ${[}a, c{]}$ 的伴随。如果我们能在这个新集合中构造一个态射，伴随将指向原始集合中的态射，我们可以将其用作复合。我们通过组合一些我们可以使用的态射来构建这个态射。首先，我们可以使用结合子 $\alpha_{{[}b, c{]}\ {[}a, b{]}\ a}$ 来重新关联左边的表达式：
\[([b, c] \otimes [a, b]) \otimes a \to [b, c] \otimes ([a, b] \otimes a)\]
我们可以接着用伴随的余单元 $\varepsilon_{a b}$：
\[[b, c] \otimes ([a, b] \otimes a) \to [b, c] \otimes b\]
然后再次使用余单元 $\varepsilon_{b c}$ 到 $c$。我们就这样构造了一个态射：
\[\varepsilon_{b c}\ .\ (\idarrow[{[b, c]}] \otimes \varepsilon_{a b})\ .\ \alpha_{[b, c] [a, b] a}\]
这是同态集的一个元素：
\[\cat{V}(([b, c] \otimes [a, b]) \otimes a, c)\]
伴随将给我们所寻找的复合法。

同样地，恒等态射：
\[j_a \Colon i \to [a, a]\]
是以下同态集的一个成员：
\[\cat{V}(i, [a, a])\]
它通过伴随同构于：
\[\cat{V}(i \otimes a, a)\]
我们知道这个同态集中包含左恒等 $\lambda_a$。我们可以将 $j_a$ 定义为其在伴随下的像。

一个实际的自加厚例子是 $\Set$ 范畴，它是编程语言中类型的原型。我们之前已经看到，它是关于笛卡尔积的封闭单积范畴。在 $\Set$ 中，任意两个集合之间的同态集本身就是一个集合，所以它是 $\Set$ 中的一个对象。我们知道它与指数集合同构，所以外部同态和内部同态是等价的。现在我们也知道，通过自加厚，我们可以使用指数集合作为同态对象，并通过笛卡尔积的指数对象来表示复合。

\section{与 $\cat{2}$-范畴的关系\\ \textmd{Relation to $\cat{2}$-Categories}}

我在谈论 $\Cat$ 范畴（小范畴的范畴）时谈到过 $\cat{2}$-范畴（2-categories）。范畴之间的态射是函子，但还有一个附加结构：函子之间的自然变换。在一个 $\cat{2}$-范畴中，对象通常称为零胞（zero-cells）；态射称为$1$-胞（1-cells）；态射之间的态射称为$2$-胞（2-cells）。在 $\Cat$ 中，$0$-胞是范畴，$1$-胞是函子，$2$-胞是自然变换。

但是请注意，两个范畴之间的函子本身也形成一个范畴；因此，在 $\Cat$ 中，我们实际上有一个\emph{同态范畴}（hom-category），而不是同态集。这意味着，正如 $\Set$ 可以视为加厚于 $\Set$ 的范畴，$\Cat$ 可以视为加厚于 $\Cat$ 的范畴。更广泛地讲，就像每个范畴可以视为加厚于 $\Set$，每个 $\cat{2}$-范畴也可以视为加厚于 $\Cat$。
