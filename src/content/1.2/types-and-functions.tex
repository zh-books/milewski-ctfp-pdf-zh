% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{类}{型与函数的范畴}在编程中起着重要作用，所以让我们讨论一下什么是类型以及为什么我们需要它们。

\section{谁需要类型？ (Who Needs Types?)}

关于静态 vs 动态，以及强类型 vs 弱类型的优点似乎存在一些争议。让我用一个思想实验来说明这些选择。想象一下，数百万只猴子在计算机键盘上开心地敲打随机键，编写程序、编译并运行它们。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/img_1329.jpg}
\end{figure}

\noindent
在机器语言中，猴子产生的任何字节组合都会被接受并运行。但在更高级的语言中，我们确实感谢编译器能够检测到词法和语法错误。许多猴子将得不到香蕉，但剩下的程序将有更大的机会有用。类型检查提供了另一道屏障，以防止无意义的程序。此外，在动态类型语言中，类型不匹配将在运行时被发现，而在强类型静态检查语言中，类型不匹配在编译时就会被发现，从而在程序有机会运行之前消除许多错误的程序。

所以问题是，我们是想让猴子开心，还是想产生正确的程序？

在打字猴子思想实验中的通常目标是生产出莎士比亚的全集。让拼写检查器和语法检查器参与其中将大大提高成功的几率。类型检查器的类似物甚至会更进一步，确保一旦罗密欧被宣告为人类，他不会长出叶子或在他强大的引力场中捕获光子。

\section{类型与组合性 (Types Are About Composability)}

范畴论是关于箭头的组合的。但并不是任何两个箭头都可以组合。一个箭头的目标对象必须与下一个箭头的源对象相同。在编程中，我们将一个函数的结果传递给另一个函数。如果目标函数不能正确解释源函数生成的数据，程序将无法运行。为了使组合起作用，两端必须匹配。语言的类型系统越强，这种匹配就越容易描述和机械验证。

我听到的唯一反对强静态类型检查的严肃论点是，它可能会排除一些语义上正确的程序。实际上，这种情况极为罕见，而且无论如何，每种语言都提供了某种绕过类型系统的后门，当确实有必要时。即使是 Haskell 也有 \code{unsafeCoerce}。但这种手段应谨慎使用。弗朗茨·卡夫卡（Franz Kafka）的角色，格雷戈尔·萨姆萨（Gregor Samsa），当他变形为一只巨大的虫子时，打破了类型系统，我们都知道这是如何结束的。

我经常听到的另一个论点是，处理类型给程序员带来了太多的负担。在自己写了几个 C++ 中迭代器的声明之后，我可以理解这种情绪，除了有一种叫做\newterm{类型推断}（type inference）的技术，它让编译器可以从使用它们的上下文中推断出大多数类型。在 C++ 中，你现在可以声明一个变量为 \code{auto}，让编译器确定它的类型。

在 Haskell 中，除了极少数情况下，类型注释是纯粹可选的。程序员通常还是会使用它们，因为它们可以传达大量的代码语义，并使编译错误更易于理解。在 Haskell 中，一个常见的做法是先设计类型，\sloppy{然后，类型注释驱动实现，并成为编译器强制的注释。}

强静态类型通常被用作不测试代码的借口。你有时会听到 Haskell 程序员说，“如果它编译了，那它就一定是正确的。”当然，没有任何保证类型正确的程序在产生正确输出的意义上也是正确的。结果是，在几项研究中，Haskell 在代码质量方面的表现并没有像预期的那样遥遥领先。看来，在商业环境中，修复错误的压力只会施加到某个质量水平，这与软件开发的经济性和最终用户的容忍度息息相关，而与编程语言或方法论几乎无关。更好的标准应该是衡量有多少项目落后于进度或以大幅减少的功能交付。

至于单元测试可以取代强类型的论点，请考虑在强类型语言中常见的重构实践：更改特定函数的参数类型。在强类型语言中，只需修改该函数的声明，然后修复所有构建错误。在弱类型语言中，函数现在期望不同数据的事实无法传播到调用点。单元测试可能会捕捉到一些不匹配，但测试几乎总是一个概率过程，而不是确定性的。测试是证明的糟糕替代品。

\section{什么是类型？ (What Are Types?)}

对类型最简单的直觉是它们是值的集合。类型 \code{Bool}（记住，在 Haskell 中，具体类型以大写字母开头）是一个包含 \code{True} 和 \code{False} 的两元素集合。类型 \code{Char} 是所有 Unicode 字符的集合，如 \code{a} 或 \code{ą}。

集合可以是有限的或无限的。类型 \code{String} 是 \code{Char} 列表的同义词，它是一个无限集合的例子。

当我们声明 \code{x} 是 \code{Integer} 时：

\src{snippet01}
我们是在说它是整数集的一个元素。Haskell 中的 \code{Integer} 是一个无限集合，可以用于任意精度的算术运算。还有一个有限集合 \code{Int} 对应于机器类型，就像 C++ 中的 \code{int}。

有些微妙之处使得将类型与集合等同变得棘手。涉及循环定义的多态函数有问题，而且你不能拥有所有集合的集合；但正如我所承诺的，我不会拘泥于数学。好消息是，有一个集合的范畴，称为 $\Set$，我们将仅与它打交道。在 $\Set$ 中，对象是集合，态射（箭头）是函数。

$\Set$ 是一个非常特殊的范畴，因为我们实际上可以窥视其内部对象并从中获得大量直觉。例如，我们知道空集没有元素。我们知道有特殊的单元素集。我们知道函数将一个集合的元素映射到另一个集合的元素。它们可以将两个元素映射到一个，但不能将一个元素映射到两个。我们知道恒等函数将集合的每个元素映射到其自身，等等。我们的计划是逐渐忘记所有这些信息，而是用纯范畴术语（即对象和箭头的术语）表达所有这些概念。

在理想世界中，我们会说 Haskell 类型是集合，Haskell 函数是集合之间的数学函数。只是有一个小问题：数学函数不执行任何代码——它只是知道答案。Haskell 函数必须计算答案。如果答案可以在有限步数内获得——无论这个数字多大——这都不是问题。但有些计算涉及递归，而这些计算可能永远不会终止。我们不能仅仅因为区分终止和不终止的函数是不可判定的（著名的停机问题）而禁止 Haskell 中的不终止函数。这就是为什么计算机科学家提出了一个聪明的主意，或者从某种观点来看是一个重要的黑客，来扩展每种类型再加上一个特殊值，称为 \newterm{底}（bottom），表示为 \code{\_|\_} 或 Unicode $\bot$。这个“值”对应于一个不终止的计算。所以一个声明为：

\src{snippet02}
的函数可以返回 \code{True}，\code{False}，或 \code{\_|\_}；后者意味着它将永远不会终止。

有趣的是，一旦你接受底作为类型系统的一部分，将每个运行时错误视为底也是很方便的，甚至允许函数显式地返回底。后者通常使用表达式 \code{undefined} 来完成，例如：

\src{snippet03}
这个定义通过类型检查，因为 \code{undefined} 计算为底，底是任何类型的成员，包括 \code{Bool}。你甚至可以写：

\src{snippet04}
（没有 \code{x}），因为底也是类型 \code{Bool -> Bool} 的成员。

可能返回底的函数称为部分函数，与此相对的是全函数，它们对每个可能的参数返回有效结果。

由于底的存在，你会看到 Haskell 类型和函数的范畴称为 $\Hask$ 而不是 $\Set$。从理论的角度来看，这是无尽复杂的源头，所以在这一点上，我会用我的屠刀切断这种推理。从实际的角度来看，忽略不终止函数和底是可以的，并将 $\Hask$ 视为真正的 $\Set$。\footnote{Nils Anders Danielsson,
  John Hughes, Patrik Jansson, Jeremy Gibbons, \href{http://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf}{
    《快速而松散的推理在道德上是正确的》}. 这篇论文为在大多数情况下忽略底提供了理由。}

\section{我们为什么需要数学模型？ (Why Do We Need a Mathematical Model?)}

作为一个程序员，你对编程语言的语法和文法非常熟悉。这些语言的方面通常在语言规范的开头使用正式的符号进行描述。但语言的含义或语义要难得多，需要更多的页面，通常不够正式，几乎从未完整。因此，语言律师之间的讨论永无止境，专门用于解释语言标准细节的书籍也应运而生。

有一些用于描述语言语义的正式工具，但由于它们的复杂性，它们主要用于简化的学术语言，而不是现实生活中的编程巨兽。其中一种工具称为\newterm{操作语义}（operational semantics），它描述了程序执行的机制。它定义了一个形式化的理想化解释器。工业语言（如 C++）的语义通常使用非正式的操作推理来描述，通常以“抽象机”的形式进行。

问题在于，使用操作语义来证明程序的性质非常困难。为了展示一个程序的性质，你基本上必须通过理想化解释器“运行”它。

程序员从来不会进行形式化的正确性证明并不重要。我们总是“认为”我们编写的程序是正确的。没有人会坐在键盘前说，“哦，我就随便写几行代码，看看会发生什么。”我们认为我们写的代码会执行某些操作并产生预期的结果。当它不这样做时，我们通常会感到非常惊讶。这意味着我们确实在推理我们编写的程序，通常是通过在脑海中运行一个解释器。只是很难跟踪所有的变量。计算机擅长运行程序——人类则不擅长！如果我们擅长，我们就不需要计算机了。

但有另一种选择。它称为\newterm{指称语义}（denotational semantics），它基于数学。在指称语义中，每个编程构造都有其数学解释。如果你想证明一个程序的性质，你只需证明一个数学定理。你可能会认为证明定理很难，但事实是，我们人类已经建立了数千年的数学方法，因此有丰富的知识可供利用。而且，与职业数学家证明的那种定理相比，我们在编程中遇到的问题通常相当简单，甚至是琐碎的。

考虑一下 Haskell 中的阶乘函数定义，这是一个非常适合指称语义的语言：

\src{snippet05}
表达式 \code{{[}1..n{]}} 是从 \code{1} 到 \code{n} 的整数列表。函数 \code{product} 乘以列表中的所有元素。这就像从数学文本中取出的阶乘定义。将其与 C 进行比较：

\begin{snip}{c}
  int fact(int n) {
    int i;
    int result = 1;
    for (i = 2; i <= n; ++i)
    result *= i;
    return result;
  }
\end{snip}
我还需要说什么吗？

好吧，我会第一个承认这是一个廉价的伎俩！阶乘函数有一个明显的数学指称。一个敏锐的读者可能会问：从键盘读取一个字符或通过网络发送一个数据包的数学模型是什么？很长一段时间，这将是一个尴尬的问题，导致一个相当复杂的解释。看起来指称语义并不是为大量重要任务（这些任务对于编写有用的程序至关重要）提供最佳支持，而这些任务可以通过操作语义轻松处理。突破来自范畴论。Eugenio Moggi 发现计算效应可以映射到单子（monads）。事实证明，这是一个重要的观察，不仅为指称语义带来了新的生机，使纯函数式程序更加可用，还为传统编程提供了新的视角。我会在稍后，当我们开发更多范畴工具时讨论单子。

拥有编程数学模型的一个重要优点是可以对软件的正确性进行形式证明。当你编写消费者软件时，这可能看起来不那么重要，但在某些编程领域，失败的代价可能是极其昂贵的，甚至关乎人类生命。但即使是在为健康系统编写 Web 应用程序时，你也会欣赏 Haskell 标准库中的函数和算法附带正确性证明这一事实。

\section{纯函数与脏函数 (Pure and Dirty Functions)}

我们在 C++ 或任何其他命令式语言中称为函数的东西，与数学家称为函数的东西并不相同。数学函数只是值到值的映射。

我们可以在编程语言中实现一个数学函数：给定一个输入值，这样的函数将计算输出值。生成一个数的平方的函数可能会将输入值乘以自身。每次调用它时，它都会这样做，并且保证每次以相同的输入调用它都会产生相同的输出。一个数的平方不会随着月相的变化而变化。

此外，计算一个数的平方不应该有副作用，例如为你的狗分发美味的零食。一个“函数”如果这样做，就无法轻松地建模为数学函数。

在编程语言中，给定相同的输入总是产生相同的结果且没有副作用的函数称为\newterm{纯函数}（pure functions）。在像 Haskell 这样的纯函数式语言中，所有函数都是纯函数。正因为如此，这些语言更容易赋予它们指称语义并使用范畴论对其建模。至于其他语言，你总是可以将自己限制在一个纯子集，或者单独推理副作用。稍后我们将看到单子如何让我们只使用纯函数来建模各种效应。因此，通过将自己限制在数学函数内，我们实际上并没有失去任何东西。

\section{类型的例子 (Examples of Types)}

一旦你意识到类型是集合，你就可以想到一些相当奇特的类型。例如，什么类型对应于空集？不，这不是 C++ 中的 \code{void}，尽管这个类型在 Haskell 中确实被称为 \code{Void}。它是一种没有任何值的类型。你可以定义一个接受 \code{Void} 的函数，但你永远无法调用它。要调用它，你必须提供一个类型为 \code{Void} 的值，但根本没有这样的值。至于这个函数可以返回什么，没有任何限制。它可以返回任何类型（尽管它永远不会返回，因为它无法被调用）。换句话说，它是一个在返回类型上是多态的函数。Haskellers 为它起了一个名字：

\src{snippet06}
（记住，\code{a} 是一个可以代表任何类型的类型变量。）这个名字并非巧合。类型和函数在逻辑方面有一个更深的解释，称为 Curry-Howard 对应。类型 \code{Void} 表示虚假，而函数 \code{absurd} 的类型对应于从虚假中可以得出任何结论的声明，正如拉丁格言“ex falso sequitur quodlibet”所言。

接下来是对应于单例集的类型。这是一个只有一个可能值的类型。这个值只是“存在”。你可能不会立即认出它，但这就是 C++ 中的 \code{void}。想想从这个类型到另一个类型的函数。一个从 \code{void} 到另一个类型的函数总是可以被调用。如果它是一个纯函数，它将总是返回相同的结果。以下是一个这样的函数的例子：

\begin{snip}{c}
  int f44() { return 44; }
\end{snip}
你可能认为这个函数不接受任何输入，但正如我们刚才看到的，一个不接受任何输入的函数永远无法被调用，因为没有表示“无”的值。那么这个函数接受什么呢？概念上，它接受一个虚拟值，只有一个实例存在，所以我们不必明确提及它。然而，在 Haskell 中，有一个符号表示这个值：一个空的括号对，\code{()}. 因此，巧合的是（或者这真的是巧合吗？），在 C++ 和 Haskell 中调用一个 void 函数的方式看起来相同。此外，由于 Haskell 对简洁的喜爱，同样的符号 \code{()} 用于类型、构造函数和唯一对应于单例集的值。所以这里是这个函数在 Haskell 中的定义：

\src{snippet07}
第一行声明 \code{f44} 接受 \code{()} 类型，读作“unit”，返回 \code{Integer} 类型。第二行通过模式匹配 \code{()}，即 unit 的唯一构造函数，生成数字 44。你通过提供 unit 值 \code{()} 来调用这个函数：

\begin{snip}{c}
  f44 ()
\end{snip}
请注意，任何 unit 的函数都相当于从目标类型中选择一个元素（这里是选择 \code{Integer} 44）。事实上，你可以将 \code{f44} 视为数字 44 的另一种表示形式。这是我们如何用函数（箭头）代替集合的明确元素的一个例子。将函数从 unit 到任何类型 $A$ 视为与该集合 $A$ 的元素之间存在一一对应关系。

那么具有 \code{void} 返回类型或在 Haskell 中具有 unit 返回类型的函数呢？在 C++ 中，这些函数用于副作用，但我们知道这些在数学意义上不是真正的函数。返回 unit 的纯函数什么都不做：它丢弃其参数。

从集合 $A$ 到单例集的函数在数学上将 $A$ 的每个元素映射到该单例集的单个元素。对于每个 $A$，这样的函数恰好只有一个。以下是 \code{Integer} 的这个函数：

\src{snippet08}
你给它任何整数，它都会返回一个 unit。秉持简洁的精神，Haskell 允许你使用通配符模式，即下划线，来表示一个被丢弃的参数。这样你就不必为它发明一个名字。所以上面的代码可以重写为：

\src{snippet09}
请注意，这个函数的实现不仅不依赖于传递给它的值，它甚至不依赖于参数的类型。

可以使用相同公式为任何类型实现的函数称为参数化多态函数。你可以使用一个类型参数而不是具体类型来实现一整个家族的此类函数。我们应该如何称呼从任何类型到 unit 类型的多态函数？当然，我们称它为 \code{unit}：

\src{snippet10}
在 C++ 中你会这样编写这个函数：

\begin{snip}{cpp}
  template<class T>
  void unit(T) {}
\end{snip}
接下来是类型学中的两元素集。在 C++ 中，它被称为 \code{bool}，而在 Haskell 中，预料之中的是 \code{Bool}。不同之处在于，在 C++ 中，\code{bool} 是一种内置类型，而在 Haskell 中，它可以定义如下：

\src{snippet11}
（读这个定义的方式是 \code{Bool} 不是 \code{True} 就是 \code{False}。）原则上，在 C++ 中也应该能够将布尔类型定义为枚举：

\begin{snip}{cpp}
  enum bool {
    true,
    false
  };
\end{snip}
但 C++ 中的 \code{enum} 秘密地是一个整数。C++11 的“\code{enum class}”可以代替使用，但你必须用类名限定它的值，如 \code{bool::true} 和 \code{bool::false}，更不用说在使用的每个文件中都必须包含适当的头文件。

从 \code{Bool} 到目标类型的纯函数只需选择两个值，一个对应 \code{True}，另一个对应 \code{False}。

到 \code{Bool} 的函数称为\newterm{谓词}（predicates）。例如，Haskell 库 \code{Data.Char} 充满了谓词，如 \code{isAlpha} 或 \code{isDigit}。在 C++ 中有一个类似的库 \code{}，它定义了 \code{isalpha} 和 \code{isdigit} 等函数，但这些返回的是一个 \code{int}，而不是布尔值。实际的谓词定义在 \code{std::ctype} 中，并具有 \code{ctype::is(alpha, c)}，\code{ctype::is(digit, c)} 等形式。

\section{挑战 (Challenges)}

\begin{enumerate}
  \tightlist
  \item
  在你最喜欢的语言中定义一个高阶函数（或函数对象）\code{memoize}。该函数接受一个纯函数 \code{f} 作为参数，并返回一个函数，该函数的行为几乎与 \code{f} 相同，只不过它只对每个参数调用原始函数一次，内部存储结果，并在每次以相同参数调用时返回该存储的结果。你可以通过观察它的性能来区分记忆化函数与原始函数。例如，尝试记忆化一个需要很长时间才能计算出结果的函数。第一次调用它时，你需要等待结果，但在随后的调用中，只要使用相同的参数，你应该能立即得到结果。
  \item
  尝试记忆化你通常用来产生随机数的标准库中的函数。它能正常工作吗？
  \item
  大多数随机数生成器都可以用种子进行初始化。实现一个函数，该函数接受一个种子，调用带有该种子的随机数生成器，并返回结果。记忆化该函数。它能正常工作吗？
  \item
  以下哪些 C++ 函数是纯函数？尝试记忆化它们，并观察在多次调用时（记忆化与否）会发生什么：

  \begin{enumerate}
    \tightlist
    \item
    本文中的阶乘函数。
    \item
    \begin{minted}{cpp}
std::getchar()
    \end{minted}
    \item
    \begin{minted}{cpp}
bool f() {
    std::cout << "Hello!" << std::endl;
    return true;
}
    \end{minted}
    \item
    \begin{minted}{cpp}
int f(int x) {
    static int y = 0;
    y += x;
    return y;
}
    \end{minted}
  \end{enumerate}
  \item
  从 \code{Bool} 到 \code{Bool} 的函数有多少种不同的实现方式？你能实现它们吗？
  \item
  绘制一个范畴的图示，其唯一的对象是 \code{Void}、\code{()}（unit）和 \code{Bool}；箭头对应于这些类型之间的所有可能的函数。用函数的名字标注箭头。
\end{enumerate}
