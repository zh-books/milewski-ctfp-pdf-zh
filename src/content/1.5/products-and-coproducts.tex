% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{古}{希腊的}剧作家欧里庇得斯曾说过：“每个人都像他惯常交往的朋友。” 我们的身份是由我们的关系定义的。这在范畴理论（category theory）中尤为真实。如果我们想要在一个范畴中单独挑选出某个对象，我们只能通过描述它与其他对象（以及它自己）的关系来做到这一点。这些关系是由态射（morphisms）定义的。

在范畴理论中，有一种常见的结构称为\newterm{泛结构}{universal construction}，用于通过对象之间的关系来定义对象。实现这种结构的一种方法是选择一个模式，即由对象和态射构成的特定形状，然后在范畴中寻找所有满足这一形状的情况。如果这是一个足够常见的模式，并且范畴足够大，那么你可能会找到许多这样的情况。诀窍在于在这些情况中建立某种排序，并选择最适合的那个。

这个过程类似于我们进行网络搜索的方式。查询就像一个模式。一个非常通用的查询会给你带来大量的\emph{召回率}{recall}：大量的结果。其中一些可能相关，另一些可能无关。为了消除无关的结果，你可以精炼查询。这将提高它的\emph{精确度}{precision}。最后，搜索引擎将对结果进行排序，并希望你感兴趣的那个结果能排在最前面。

\section{初始对象}{Initial Object}

最简单的形状是一个单一对象。显然，在给定的范畴中，这种形状的实例与对象的数量相同。我们需要建立某种排序，并试图找到在这个层次结构中处于顶端的对象。我们唯一的工具是态射。如果你把态射看作箭头，那么可能存在从范畴的一端到另一端的箭头流动。这在有序范畴（ordered categories）中是存在的，例如在偏序（partial orders）中。我们可以通过说对象$a$“更初始”于对象$b$，如果有一个箭头（态射）从$a$指向$b$。然后我们可以定义\emph{初始对象}{initial object}为具有指向所有其他对象的箭头的对象。显然，不能保证这样的对象一定存在，这也没关系。一个更大的问题是可能有太多这样的对象：召回率很好，但精确度不足。解决方案是借鉴有序范畴的提示——它们允许在任意两个对象之间最多只有一个箭头：只有一种方式是“少于或等于”另一个对象。这引导我们得出初始对象的定义：

\begin{quote}
  \textbf{初始对象}{initial object}是指在范畴中具有唯一且只有一个态射指向任意对象的对象。
\end{quote}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/initial.jpg}
\end{figure}

\noindent
然而，这并不保证初始对象的唯一性（如果它存在）。但它保证了另一种最佳情况：\newterm{同构}{isomorphism}意义上的唯一性。同构在范畴理论中非常重要，我稍后会讨论它。现在，我们只需同意，在定义初始对象时，使用“the”是有道理的。

以下是一些例子：在偏序集（通常称为\newterm{偏序集}{poset}）中，初始对象是其最小元素。有些偏序集没有初始对象——比如所有整数的集合（包括正数和负数），它们的态射是“小于或等于”关系。

在集合和函数的范畴中，初始对象是空集。记住，空集对应于Haskell中的\code{Void}类型（在C++中没有对应的类型），并且从\code{Void}到任何其他类型的唯一多态函数称为\code{absurd}：

\src{snippet01}
正是这一系列态射使得\code{Void}成为类型范畴中的初始对象。

\section{终端对象}{Terminal Object}

让我们继续讨论单一对象模式，但这次改变我们对对象排序的方式。我们将说对象$a$“更终端”于对象$b$，如果存在从$b$指向$a$的态射（注意方向的反转）。我们将寻找一个比范畴中任何其他对象都更终端的对象。同样，我们将坚持唯一性：

\begin{quote}
  \textbf{终端对象}{terminal object}是指在范畴中具有唯一且只有一个态射从任何对象指向它的对象。
\end{quote}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/final.jpg}
\end{figure}

\noindent
同样，终端对象是唯一的，同构意义上的唯一性，我稍后会展示。但首先让我们来看一些例子。在一个偏序集中，终端对象（如果存在）是最大的对象。在集合范畴中，终端对象是一个单元素集合。我们已经讨论过单元素集合——它们对应于C++中的\code{void}类型和Haskell中的单位类型\code{()}。这是一种只有一个值的类型——在C++中是隐含的，在Haskell中是显式的，表示为\code{()}。我们还确定，从任何类型到单位类型的纯函数只有一个：

\src{snippet02}
因此，满足终端对象的所有条件。

注意，在这个例子中，唯一性条件至关重要，因为存在其他集合（实际上是所有集合，除了空集）具有从每个集合指向它们的态射。例如，定义在每个类型上的布尔值函数（谓词）：

\src{snippet03}
但\code{Bool}不是终端对象。对于每种类型（除了\code{Void}，对于它来说，两个函数都等于\code{absurd}），至少还有一个\code{Bool}值的函数：

\src{snippet04}
坚持唯一性使我们能够将终端对象的定义精确到只有一种类型。

\section{对偶性}{Duality}

你可能已经注意到，我们定义初始对象和终端对象的方式是对称的。两者之间唯一的区别是态射的方向。事实证明，对于任何范畴$\cat{C}$，我们可以通过反转所有箭头来定义\newterm{对偶范畴}{opposite category} $\cat{C}^\mathit{op}$。只要我们同时重新定义组合，对偶范畴自动满足范畴的所有要求。如果原始态射$f \Colon a \to b$ 和 $g \Colon b \to c$ 组合为$h \Colon a \to c$，使得$h = g \circ f$，那么反转后的态射$f^\mathit{op} \Colon b \to a$ 和 $g^\mathit{op} \Colon c \to b$ 将组合为$h^\mathit{op} \Colon c \to a$，并且$h^\mathit{op} = f^\mathit{op} \circ g^\mathit{op}$。反转恒等箭头是一个（双关警告！）无操作。

对偶性是范畴的一个非常重要的性质，因为它将每个研究范畴理论的数学家的生产力翻倍。对于你提出的每个构造，都会有它的对偶；对于你证明的每个定理，你会免费得到一个。在对偶范畴中的构造通常以“co”开头，所以你有积和余积（products and coproducts）、单子和共单子（monads and comonads）、锥和余锥（cones and cocones）、极限和余极限（limits and colimits）等等。然而，没有共单子（cocomonads），因为反转箭头两次会使我们回到原始状态。

因此，终端对象就是对偶范畴中的初始对象。

\section{同构}{Isomorphisms}

作为程序员，我们深知定义相等性是一个非平凡的任务。对于两个对象来说，相等是什么意思？它们是否必须占据内存中的同一位置（指针相等性）？还是说它们的所有组件的值相等就足够了？如果一个复数是用实部和虚部表示的，而另一个是用模和角度表示的，那么这两个复数是否相等？你可能会认为数学家已经弄清楚了相等的含义，但他们并没有。他们面临着相同的问题，即相等性的多种竞争性定义。存在命题相等性（propositional equality）、意图相等性（intensional equality）、外延相等性（extensional equality）和同伦类型论中的路径相等性（path equality）。然后还有较弱的同构（isomorphism）和更弱的等价（equivalence）的概念。

直观上，同构对象看起来是相同的——它们具有相同的形状。这意味着一个对象的每个部分都与另一个对象的某个部分一一对应。从我们的仪器来看，这两个对象是彼此的完美副本。在数学上，这意味着存在一个从对象$a$到对象$b$的映射，并且存在一个从对象$b$回到对象$a$的映射，它们是彼此的逆映射。在范畴理论中，我们用态射来代替映射。同构是可逆的态射；或者说是一对态射，其中一个是另一个的逆。

我们通过组合和恒等性来理解逆态射：态射$g$是态射$f$的逆态射，如果它们的组合是恒等态射。这实际上是两个方程，因为有两种组合两个态射的方式：

\src{snippet05}
当我说初始对象（终端对象）在同构意义上是唯一的时，我的意思是任何两个初始对象（终端对象）都是同构的。这实际上很容易看出。假设我们有两个初始对象$i_{1}$ 和 $i_{2}$。由于$i_{1}$是初始对象，因此存在一个从$i_{1}$到$i_{2}$的唯一态射$f$。同样，由于$i_{2}$是初始对象，因此存在一个从$i_{2}$到$i_{1}$的唯一态射$g$。这两个态射的组合是什么？

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/uniqueness.jpg}
  \caption{该图中的所有态射都是唯一的。}
\end{figure}

\noindent
组合$g \circ f$必须是从$i_{1}$到$i_{1}$的态射。但是$i_{1}$是初始对象，因此只能有一个从$i_{1}$到$i_{1}$的态射。由于我们处于一个范畴中，我们知道存在一个从$i_{1}$到$i_{1}$的恒等态射，并且由于只有一个位置，这必须是它。因此$g \circ f$等于恒等态射。同样，$f \circ g$也必须等于恒等态射，因为只能有一个从$i_{2}$回到$i_{2}$的态射。这证明了$f$和$g$必须是彼此的逆态射。因此，任何两个初始对象都是同构的。

注意，在这个证明中，我们使用了从初始对象到自身的态射的唯一性。没有它，我们无法证明“同构意义上的唯一性”这一部分。但为什么我们需要$f$和$g$的唯一性呢？因为不仅初始对象在同构意义上是唯一的，它还在\emph{唯一}同构意义上是唯一的。原则上，在两个对象之间可能存在多个同构，但在这里不是这种情况。这种“唯一同构意义上的唯一性”是所有泛结构的一个重要属性。

\section{积}{Products}

下一个泛结构是积的构造。我们知道两个集合的笛卡尔积是什么：它是一个有序对的集合。但是连接积集与其组成集合的模式是什么呢？如果我们能弄清楚这一点，我们就能将其推广到其他范畴。

我们只能说，有两个函数（projections）从积到它们的组成部分。在Haskell中，这两个函数分别被称为\code{fst}和\code{snd}，它们分别选取有序对的第一个和第二个组件：

\src{snippet06}

\src{snippet07}
在这里，这些函数是通过对其参数进行模式匹配来定义的：匹配任何对的模式是\code{(x, y)}，它将其组件提取到变量\code{x}和\code{y}中。

通过使用通配符，这些定义可以进一步简化：

\src{snippet08}
在C++中，我们将使用模板函数，例如：

\begin{snip}{cpp}
  template<class A, class B> A
  fst(pair<A, B> const & p) {
    return p.first;
  }
\end{snip}
有了这些看似非常有限的知识，让我们尝试在集合的范畴中定义一个对象和态射的模式，这将引导我们构造两个集合的积。这个模式由一个对象$c$和两个态射$p$和$q$组成，它们分别连接到$a$和$b$：

\src{snippet09}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/productpattern.jpg}
\end{figure}

\noindent
所有符合这一模式的$c$都将被视为积的候选者。可能会有很多这样的对象。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/productcandidates.jpg}
\end{figure}

\noindent
例如，让我们选择两个Haskell类型\code{Int}和\code{Bool}，并获取它们积的候选样本。

这是一个：\code{Int}。\code{Int}可以被视为\code{Int}和\code{Bool}的积的候选者吗？是的，可以——这里是它的投影：

\src{snippet10}
这很弱，但它符合标准。

这是另一个：\code{(Int, Int, Bool)}。这是一个三元素的元组或三元组。这里有两个态射，使其成为一个合法的候选者（我们使用的是对三元组的模式匹配）：

\src{snippet11}
你可能已经注意到，虽然我们的第一个候选者太小了——它只涵盖了积的\code{Int}维度；第二个则太大了——它错误地复制了\code{Int}维度。

但我们还没有探索泛结构的另一部分：排序。我们希望能够比较我们的模式的两个实例。我们希望比较一个候选对象$c$及其两个投影$p$和$q$与另一个候选对象$c'$及其两个投影$p'$和$q'$。我们希望说$c$“优于”$c'$，如果存在一个从$c'$到$c$的态射$m$——但这太弱了。我们还希望它的投影“优于”或“更普遍”$c'$的投影。这意味着可以通过$m$从$p$和$q$重新构建$p'$和$q'$：

\src{snippet12}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/productranking.jpg}
\end{figure}

\noindent
另一种看待这些方程的方法是，$m$ \emph{因式分解} $p'$ 和 $q'$。假装这些方程是在自然数中，并且点是乘法：$m$是$p'$和$q'$的公因子。

为了建立一些直觉，让我向你展示，具有两个标准投影\code{fst}和\code{snd}的对\code{(Int, Bool)}确实比我之前展示的两个候选者\emph{更好}。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/not-a-product.jpg}
\end{figure}

\noindent
第一个候选者的映射\code{m}是：

\src{snippet13}
确实，这两个投影\code{p}和\code{q}可以通过以下方式重建：

\src{snippet14}
第二个示例的\code{m}也类似地唯一确定：

\src{snippet15}
我们能够证明\code{(Int, Bool)}比前两个候选者更好。让我们看看为什么反过来是不成立的。我们能找到一些\code{m'}来帮助我们从\code{p}和\code{q}中重建\code{fst}和\code{snd}吗？

\src{snippet16}
在我们的第一个示例中，\code{q}总是返回\code{True}，而我们知道有些对的第二个组件是\code{False}。我们无法从\code{q}中重建\code{snd}。

第二个例子不同：运行\code{p}或\code{q}后，我们保留了足够的信息，但有不止一种方式来因式分解\code{fst}和\code{snd}。因为\code{p}和\code{q}都忽略了三元组的第二个组件，所以我们的\code{m'}可以在其中放置任何东西。我们可以有：

\src{snippet17}

或者
\src{snippet18}
等等。

综上所述，给定任何具有两个投影\code{p}和\code{q}的类型\code{c}，存在唯一的\code{m}从\code{c}到笛卡尔积\code{(a, b)}，它们会因式分解这些投影。实际上，它只是将\code{p}和\code{q}组合成一对。

\src{snippet19}
这使得笛卡尔积\code{(a, b)}成为我们的最佳匹配，这意味着这个泛结构在集合范畴中有效。它选择了任何两个集合的积。

现在，让我们忘记集合，并使用相同的泛结构在任何范畴中定义两个对象的积。这种积不总是存在，但当它存在时，它是唯一的，同构意义上的唯一性。

\begin{quote}
  两个对象$a$和$b$的\textbf{积}{product}是对象$c$，配备两个投影，使得对于任何其他配备两个投影的对象$c'$，存在唯一的态射$m$从$c'$到$c$，因式分解这些投影。
\end{quote}

\noindent
产生因式分解函数\code{m}的（高阶）函数有时称为\newterm{因式分解器}{factorizer}。在我们的例子中，它将是函数：

\src{snippet20}

\section{余积}{Coproduct}

像范畴理论中的每个构造一样，积有一个对偶，称为余积。当我们反转积模式中的箭头时，我们最终得到一个对象$c$，它配备了两个\emph{嵌入}{injections}，\code{i}和\code{j}：从$a$和$b$到$c$的态射。

\src{snippet21}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/coproductpattern.jpg}
\end{figure}

\noindent
排序也被反转了：对象$c$“优于”配备了嵌入$i'$和$j'$的对象$c'$，如果存在一个态射$m$从$c$到$c'$，它因式分解了这些嵌入：

\src{snippet22}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/coproductranking.jpg}
\end{figure}

\noindent
这样的“最佳”对象，具有唯一的态射将其连接到任何其他模式，称为余积，如果它存在，则在唯一同构意义上是唯一的。

\begin{quote}
  两个对象$a$和$b$的\textbf{余积}{coproduct}是对象$c$，配备两个嵌入，使得对于任何其他配备两个嵌入的对象$c'$，存在唯一的态射$m$从$c$到$c'$，因式分解这些嵌入。
\end{quote}

\noindent
在集合范畴中，余积是两个集合的\emph{不交并}{disjoint union}。集合$a$和$b$的不交并的元素要么是$a$的元素，要么是$b$的元素。如果这两个集合重叠，不交并包含公共部分的两个副本。你可以认为不交并的元素是带有标识符的，它指定了其来源。

对于程序员来说，更容易理解余积的类型意义：它是两个类型的标记并集（tagged union）。C++支持并集，但它们不是标记的。这意味着在你的程序中，你必须以某种方式跟踪并集的哪个成员是有效的。要创建一个标记并集，你必须定义一个标记——枚举——并将其与并集结合。例如，一个\code{int}和\code{char const *}的标记并集可以实现为：

\begin{snip}{cpp}
  struct Contact {
    enum { isPhone, isEmail } tag;
    union { int phoneNum; char const * emailAddr; };
  };
\end{snip}
这两个嵌入可以实现为构造函数或函数。例如，下面是第一个嵌入作为函数\code{PhoneNum}的实现：

\begin{snip}{cpp}
  Contact PhoneNum(int n) {
    Contact c;
    c.tag = isPhone;
    c.phoneNum = n;
    return c;
  }
\end{snip}
它将一个整数嵌入到\code{Contact}中。

标记并集也称为\newterm{变体}{variant}，并且在Boost库中有一个非常通用的变体实现，\code{boost::variant}。

在Haskell中，你可以通过使用竖线分隔数据构造函数，将任何数据类型组合成一个标记并集。上面的\code{Contact}示例转换为如下声明：

\src{snippet23}
在这里，\code{PhoneNum}和\code{EmailAddr}既充当了构造函数（嵌入），又充当了模式匹配的标记（稍后将详细讨论）。例如，以下是如何使用电话号码构造一个联系人的方法：

\src{snippet24}
与Haskell中作为原始对内置的积的规范实现不同，余积的规范实现是一个称为\code{Either}的数据类型，它在标准Prelude中定义为：

\src{snippet25}
它是一个由两个类型\code{a}和\code{b}参数化的数据类型，并且有两个构造函数：\code{Left}接收类型\code{a}的值，\code{Right}接收类型\code{b}的值。

正如我们为积定义了因式分解器一样，我们也可以为余积定义一个。给定一个候选类型\code{c}和两个候选嵌入\code{i}和\code{j}，\code{Either}的因式分解器会生成因式分解函数：

\src{snippet26}

\section{不对称性}{Asymmetry}

我们已经看到了两组对偶定义：可以通过反转箭头的方向，从初始对象的定义中得到终端对象的定义；同样地，可以从积的定义中得到余积的定义。然而，在集合的范畴中，初始对象与终端对象非常不同，余积与积也非常不同。稍后我们将看到，积表现得像乘法，终端对象扮演“一”的角色；而余积更像是加法，初始对象扮演“零”的角色。特别是，对于有限集合，积的大小是各个集合大小的乘积，而余积的大小是各个集合大小的总和。

这表明，集合范畴对于箭头反转是不对称的。

注意，虽然空集有唯一的态射指向任何集合（\code{absurd}函数），但它没有返回的态射。单元素集合有一个唯一的态射从任何集合指向它，但它\emph{也}有指向每个集合的态射（除了空集）。正如我们之前看到的那样，这些从终端对象指向其他集合的态射在选择其他集合的元素方面扮演着非常重要的角色（空集没有元素，因此没有东西可以选择）。

这就是单元素集合与积的关系，使其与余积不同。考虑使用单元素集合，表示为单位类型\code{()}，作为积模式的另一个——大大逊色的——候选者。为其配备两个投影\code{p}和\code{q}：从单元素集合到每个组成集合的函数。每个函数选择组成集合中的一个具体元素。因为积是普遍的，所以还存在一个（唯一的）态射\code{m}，将我们的候选对象单元素集合映射到积上。这个态射选择了积集合中的一个元素——它选择了一个具体的对。它也因式分解了这两个投影：

\src{snippet27}
当作用于单元素集合的唯一值\code{()}时，这两个方程变为：

\src{snippet28}
由于\code{m ()}是由\code{m}选择的积的元素，这些方程告诉我们，从第一个集合中由\code{p}选择的元素\code{p ()}是\code{m}选择的对的第一个组成部分。同样，\code{q ()}等于第二个组成部分。这与我们对积的元素是组成集合的对的理解完全一致。

对于余积，没有如此简单的解释。我们可以尝试将单元素集合作为余积的候选者，试图从中提取元素，但我们将有两个嵌入而不是两个投影。它们不会告诉我们关于其来源的任何信息（事实上，我们已经看到它们忽略了输入参数）。余积到单元素集合的唯一态射也不会。集合的范畴看起来在初始对象方向和终端方向上非常不同。

这不是集合的内在性质，而是函数的性质，我们在$\Set$中将其用作态射。一般来说，函数是不对称的。让我解释一下。

一个函数必须为其定义域集合的每个元素定义（在编程中，我们称其为\newterm{全函数}{total function}），但它不必覆盖整个值域。我们已经看到了它的一些极端情况：从单元素集合到值域的函数——这些函数只选择值域中的单个元素。（实际上，从空集到值域的函数是极端情况。）当定义域的大小远小于值域的大小时，我们经常认为这些函数将定义域嵌入到值域中。例如，我们可以认为从单元素集合到值域的函数是将其单个元素嵌入到值域中。我称它们为\newterm{嵌入函数}{embedding functions}，但数学家更喜欢给相反的函数命名：那些紧密填充其值域的函数被称为\newterm{满射}{surjective}或\newterm{上的}{onto}。

另一种不对称性的来源是，函数被允许将定义域集合中的多个元素映射到值域的一个元素上。它们可以压缩它们。最极端的情况是，将整个集合映射到单元素集合的函数。你已经看到了多态的\code{unit}函数，它就是这么做的。压缩只能通过组合来复合。两个压缩函数的组合比单个函数更具压缩性。数学家给非压缩函数命名：他们称它们为\newterm{单射}{injective}或\newterm{一对一}{one-to-one}。

当然，有些函数既不是嵌入也不是压缩的。它们被称为\newterm{双射}{bijections}，它们是真正对称的，因为它们是可逆的。在集合范畴中，同构就是双射。

\section{挑战}{Challenges}

\begin{enumerate}
  \tightlist
  \item
  证明终端对象在唯一同构意义上是唯一的。
  \item
  偏序集中两个对象的积是什么？提示：使用泛结构。
  \item
  偏序集中两个对象的余积是什么？
  \item
  在你喜欢的语言（除了Haskell）中实现Haskell \code{Either}的等效泛型类型。
  \item
  证明\code{Either}是比配备两个嵌入的\code{int}“更好”的余积：

  \begin{snip}{cpp}
    int i(int n) { return n; }
    int j(bool b) { return b ? 0: 1; }
  \end{snip}

  提示：定义一个函数

  \begin{snip}{cpp}
    int m(Either const & e);
  \end{snip}

  因式分解\code{i}和\code{j}。
  \item
  继续前一个问题：你如何证明带有两个嵌入\code{i}和\code{j}的\code{int}不能“优于”\code{Either}？
  \item
  继续：这些嵌入怎么样？

  \begin{snip}{cpp}
    int i(int n) {
      if (n < 0) return n;
      return n + 2;
    }

    int j(bool b) { return b ? 0: 1; }
  \end{snip}
  \item
  提出一个劣质的\code{int}和\code{bool}余积的候选者，因为它允许从其到\code{Either}的多个可接受的态射，故它不能优于\code{Either}。
\end{enumerate}

\section{参考文献}{Bibliography}

\begin{enumerate}
  \tightlist
  \item
  The Catsters,
  \urlref{https://www.youtube.com/watch?v=upCSDIO9pjc}{Products and
  Coproducts} 视频。
\end{enumerate}
