% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{现}{在是时候}谈谈集合了。
数学家与集合论（set theory）有一种爱恨交织的关系。集合论曾是数学的汇编语言——至少以前是。范畴论（category theory）在某种程度上试图远离集合论。例如，众所周知，所有集合的集合不存在，但所有集合的范畴 $\Set$ 却存在。这是个好消息。另一方面，我们假设一个范畴中任意两个对象之间的态射（morphisms）形成一个集合。我们甚至称之为同态集（hom-set）。公平地说，范畴论有一个分支，其中态射不构成集合，而是另一个范畴中的对象。那些使用同态对象而非同态集的范畴被称为\newterm{充实范畴}（enriched categories）。在接下来的讨论中，我们将坚持使用老式的同态集范畴。

集合是范畴对象之外最接近于无特征斑点的东西。集合有元素，但你不能对这些元素说太多。如果你有一个有限集合，你可以数元素。你也可以用基数（cardinal numbers）“数”无限集合的元素。例如，自然数集合比实数集合要小，尽管两者都是无限的。但也许令人惊讶的是，有理数集合与自然数集合一样大。

除此之外，有关集合的所有信息都可以通过它们之间的函数来编码——特别是可逆的函数，称为同构（isomorphisms）。在所有意图和目的上，同构的集合是相同的。在我招致基础数学家们的愤怒之前，让我解释一下，等同和同构之间的区别是根本性的。事实上，这是最新数学分支之一，同伦类型论（Homotopy Type Theory, HoTT）的主要关注点之一。我提到 HoTT 是因为它是一种纯粹的数学理论，受到计算的启发，而其主要倡导者之一 Vladimir Voevodsky 在研究 Coq 定理证明器时获得了重大启发。数学与编程之间的互动是双向的。

关于集合的重要教训是，可以比较不同元素的集合。例如，我们可以说某个自然变换（natural transformations）集合与某个态射集合是同构的，因为集合只是一个集合。同构在这种情况下仅意味着，对于一个集合中的每个自然变换，另一个集合中都有一个唯一的态射与之对应，反之亦然。它们可以一一对应。如果它们是不同范畴的对象，你不能比较苹果和橙子，但你可以比较苹果集合和橙子集合。通常，将范畴问题转化为集合论问题可以为我们提供必要的洞察，甚至让我们证明有价值的定理。

\section{同态函子（The Hom Functor）}

每个范畴都配备了一组规范的映射到 $\Set$。这些映射实际上是函子（functors），因此它们保留了范畴的结构。让我们构建一个这样的映射。

让我们固定范畴 $\cat{C}$ 中的一个对象 $a$，然后选择另一个对象 $x$，同样在 $\cat{C}$ 中。同态集 $\cat{C}(a, x)$ 是一个集合，一个 $\Set$ 中的对象。当我们在保持 $a$ 不变的情况下改变 $x$ 时，$\cat{C}(a, x)$ 也会在 $\Set$ 中变化。因此，我们得到了从 $x$ 到 $\Set$ 的映射。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.45\textwidth]{images/hom-set.jpg}
\end{figure}

\noindent
如果我们想强调我们正在考虑的同态集是其第二个参数中的映射，我们使用符号 $\cat{C}(a, -)$，其中破折号用作参数的占位符。

这个对象的映射可以轻松扩展到态射的映射。让我们在 $\cat{C}$ 中取一个态射 $f$，它在两个任意对象 $x$ 和 $y$ 之间。对象 $x$ 映射到集合 $\cat{C}(a, x)$，对象 $y$ 映射到 $\cat{C}(a, y)$，在我们刚刚定义的映射下。如果这个映射是一个函子，那么 $f$ 必须被映射到两个集合之间的函数：$\cat{C}(a, x) \to \cat{C}(a, y)$

让我们逐点定义这个函数，即分别为每个参数定义。对于参数，我们应该选择 $\cat{C}(a, x)$ 的任意元素——我们称之为 $h$。态射是可组合的，如果它们端到端匹配。碰巧的是，$h$ 的目标与 $f$ 的源匹配，因此它们的组合：
\[f \circ h \Colon a \to y\]
是一个从 $a$ 到 $y$ 的态射。因此它是 $\cat{C}(a, y)$ 的成员。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.45\textwidth]{images/hom-functor.jpg}
\end{figure}

\noindent
我们刚刚找到了从 $\cat{C}(a, x)$ 到 $\cat{C}(a, y)$ 的函数，它可以作为 $f$ 的像。如果没有混淆的危险，我们会将这个提升的函数写为：$\cat{C}(a, f)$，并将其在态射 $h$ 上的作用写为：
\[\cat{C}(a, f) h = f \circ h\]
由于这个构造在任何范畴中都有效，因此它也必须在 Haskell 类型的范畴中有效。在 Haskell 中，同态函子更为人所知的是 \code{Reader} 函子：

\src{snippet01}

\src{snippet02}
现在让我们考虑，如果不是固定同态集的源，而是固定目标，会发生什么。换句话说，我们在问，映射 $\cat{C}(-, a)$ 是否也是一个函子。它是一个函子，但不是协变的（covariant），而是逆变的（contravariant）。这是因为相同的端到端匹配的态射组合结果是在 $f$ 后组合（postcomposition）；而不是像 $\cat{C}(a, -)$ 那样是前组合（precomposition）。

我们已经在 Haskell 中看到了这个逆变函子。我们称之为 \code{Op}：

\src{snippet03}

\src{snippet04}
最后，如果我们让两个对象都变化，我们得到一个双函子（profunctor）$\cat{C}(-, =)$，它在第一个参数中是逆变的，而在第二个参数中是协变的（为了强调两个参数可以独立变化，我们在第二个占位符上使用双破折号）。当我们谈论函子性时，我们已经见过这个双函子：

\src{snippet05}
重要的教训是，这个观察在任何范畴中都成立：对象到同态集的映射是函子性的。由于逆变性等同于从对偶范畴的映射，我们可以简洁地陈述这一事实：
\[C(-, =) \Colon \cat{C}^\mathit{op} \times \cat{C} \to \Set\]

\section{可表示函子（Representable Functors）}

我们已经看到，对于 $\cat{C}$ 中的每个对象 $a$，我们都可以得到一个从 $\cat{C}$ 到 $\Set$ 的函子。这种结构保留映射到 $\Set$ 的结构通常称为\newterm{表示}（representation）。我们将 $\cat{C}$ 的对象和态射表示为 $\Set$ 中的集合和函数。

函子 $\cat{C}(a, -)$ 本身有时被称为可表示的。更一般地，任何对某个 $a$ 的选择自然同构于同态函子的函子 $F$ 都称为\newterm{可表示的}。这样的函子必须是 $\Set$-值的，因为 $\cat{C}(a, -)$ 是。

我之前说过，我们经常将同构集合视为相同的。更一般地，我们将范畴中的同构\emph{对象}视为相同的。这是因为对象除了通过态射与其他对象（以及自身）的关系之外没有其他结构。

例如，我们之前讨论过由集合建模的单子范畴 $\cat{Mon}$。但我们小心翼翼地选择了那些保持这些集合的单子结构的函数作为态射。因此，如果 $\cat{Mon}$ 中的两个对象是同构的，意味着它们之间存在可逆的态射，那么它们具有完全相同的结构。如果我们窥视它们所基于的集合和函数，我们会看到一个单子的单位元素映射到另一个单子的单位元素，并且两个元素的积映射到它们的映射的积。

同样的推理可以应用于函子。两个范畴之间的函子形成了一个范畴，在其中自然变换（natural transformations）扮演了态射的角色。因此，如果两个函子是同构的，我们可以将它们视为相同的，如果它们之间存在可逆的自然变换。

让我们从这个角度分析可表示函子的定义。对于 $F$ 是可表示的，我们要求：在 $\cat{C}$ 中存在一个对象 $a$；从 $\cat{C}(a, -)$ 到 $F$ 的自然变换 $\alpha$；一个方向相反的自然变换 $\beta$；并且它们的组合是恒等自然变换。

让我们看看 $\alpha$ 在某个对象 $x$ 处的分量。这是一个 $\Set$ 中的函数：
\[\alpha_x \Colon \cat{C}(a, x) \to F x\]
这个变换的自然性条件告诉我们，对于从 $x$ 到 $y$ 的任何态射 $f$，下图是交换的：
\[F f \circ \alpha_x = \alpha_y \circ \cat{C}(a, f)\]
在 Haskell 中，我们会用多态函数替换自然变换：

\src{snippet06}
使用可选的 \code{forall} 量词。自然性条件

\src{snippet07}
由于参数化（parametricity）的原因自动满足（这是我之前提到的那些免费的定理之一），理解左边的 \code{fmap} 由函子 $F$ 定义，而右边的由 reader 函子定义。由于 reader 的 \code{fmap} 只是函数前组合（function precomposition），我们可以更明确一点。作用于 $\cat{C}(a, x)$ 的一个元素 $h$，自然性条件简化为：

\src{snippet08}
另一个变换 \code{beta} 走相反的方向：

\src{snippet09}
它必须满足自然性条件，并且必须是 \code{alpha} 的逆：

\begin{snip}{text}
  alpha . beta = id = beta . alpha
\end{snip}
我们稍后会看到，从 $\cat{C}(a, -)$ 到任何 $\Set$-值函子的自然变换总是存在的，只要 $F a$ 非空（Yoneda 引理），但它不一定是可逆的。

让我给你一个 Haskell 中的例子，使用列表函子和 \code{Int} 作为 \code{a}。这是一个可以完成任务的自然变换：

\src{snippet10}
我任意选择了数字 12，并用它创建了一个单元素列表。然后我可以对这个列表调用 \code{fmap} 函数 \code{h}，得到一个类型为 \code{h} 返回类型的列表。（实际上，这样的变换与整数列表一样多。）

自然性条件等价于 \code{map}（列表版本的 \code{fmap}）的可组合性：

\src{snippet11}
但如果我们试图找到逆变换，我们需要从一个任意类型 \code{x} 的列表到一个返回 \code{x} 的函数：

\src{snippet12}
你可能会想到从列表中检索一个 \code{x}，例如，使用 \code{head}，但这对空列表不起作用。注意，这里没有一种类型 \code{a}（代替 \code{Int}）可以奏效。所以列表函子不是可表示的。

还记得我们谈到 Haskell 的（自）函子有点像容器吗？同样，我们可以将可表示函子视为存储函数调用结果的缓存容器（在 Haskell 中，同态集的成员只是函数）。表示对象，$\cat{C}(a, -)$ 中的类型 $a$，被认为是键类型，我们可以用它来访问函数的表格化值。我们称为 \code{alpha} 的变换称为 \code{tabulate}，它的逆变换 \code{beta} 称为 \code{index}。以下是一个（略微简化的）\code{Representable} 类的定义：

\src{snippet13}
注意，表示类型，即我们所说的 $a$，这里称为 \code{Rep f}，是 \code{Representable} 定义的一部分。星号只是意味着 \code{Rep f} 是一个类型（而不是类型构造器或其他更奇特的种类）。

无限列表或流（streams），不能是空的，是可表示的。

\src{snippet14}
你可以将它们视为接受 \code{Integer} 作为参数的函数的缓存值。（严格来说，我应该使用非负自然数，但我不想让代码变得复杂。）

要 \code{tabulate} 这样的函数，你需要创建一个无限的值流。当然，这只能在 Haskell 是惰性求值（lazy evaluation）的情况下实现。值是在需求时计算的。你可以使用 \code{index} 访问缓存的值：

\src{snippet15}
有趣的是，你可以实现一个单一的缓存机制来覆盖一整个家族的函数，返回类型任意。

逆变函子的可表示性类似定义，不同之处在于我们保持 $\cat{C}(-, a)$ 的第二个参数固定。或者，等效地，我们可以考虑从 $\cat{C}^\mathit{op}$ 到 $\Set$ 的函子，因为 $\cat{C}^\mathit{op}(a, -)$ 与 $\cat{C}(-, a)$ 相同。

可表示性有一个有趣的转折。记住，同态集可以在内部视为指数对象，在笛卡尔闭范畴（Cartesian closed categories）中。$\cat{C}(a, x)$ 的同态集等价于 $x^a$，对于一个可表示函子 $F$，我们可以写作：$-^a = F$。

让我们做一个形式上的变换：$a = \mathbf{log}F$

当然，这只是一个纯粹的形式变换，但如果你知道一些对数的性质，它会非常有帮助。特别是，基于乘积类型的函子可以用和类型来表示，而和类型函子通常不可表示（例如：列表函子）。

最后，注意一个可表示函子为我们提供了两个不同的实现——一个是函数，一个是数据结构。它们有完全相同的内容——使用相同的键检索相同的值。这就是我所说的“相同”的含义。对于它们的内容，两个自然同构的函子是相同的。另一方面，这两种表示通常是不同的实现，可能具有不同的性能特性。缓存用作性能增强，可能显著减少运行时间。能够生成相同基础计算的不同表示在实践中非常有价值。因此，令人惊讶的是，尽管范畴论完全不关注性能，但它提供了许多探索具有实际价值的替代实现的机会。

\section{挑战（Challenges）}

\begin{enumerate}
  \tightlist
  \item
  证明同态函子将范畴 $C$ 中的恒等态射映射到 $\Set$ 中相应的恒等函数。
  \item
  证明 \code{Maybe} 不是可表示的。
  \item
  \code{Reader} 函子是可表示的吗？
  \item
  使用 \code{Stream} 表示，缓存一个平方其参数的函数。
  \item
  证明 \code{tabulate} 和 \code{index} 对于 \code{Stream} 确实是彼此的逆。（提示：使用归纳法。）
  \item
  函子：

  \begin{snip}{haskell}
    Pair a = Pair a a
  \end{snip}
  是可表示的。你能猜出表示它的类型吗？实现 \code{tabulate} 和 \code{index}。
\end{enumerate}

\section{参考文献（Bibliography）}

\begin{enumerate}
  \tightlist
  \item
  Catsters 视频关于
  \urlref{https://www.youtube.com/watch?v=4QgjKUzyrhM}{可表示函子}。
\end{enumerate}
