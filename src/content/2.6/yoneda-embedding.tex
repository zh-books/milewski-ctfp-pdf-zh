% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{我}{们之前已经看到}，当我们在范畴 $\cat{C}$ 中固定一个对象 $a$ 时，映射 $\cat{C}(a, -)$ 是一个从 $\cat{C}$ 到 $\Set$ 的（协变）函子。
\[x \to \cat{C}(a, x)\]
（由于同态集（hom-set）$\cat{C}(a, x)$ 是一个\emph{集合（set）}，因此对域是 $\Set$。）我们称这个映射为同态函子（hom-functor）——我们之前已经定义了它在态射（morphisms）上的作用。

现在让我们变化 $a$ 在这个映射中的值。我们得到一个新的映射，将同态\emph{函子（functor）}$\cat{C}(a, -)$ 赋给任何 $a$。
\[a \to \cat{C}(a, -)\]
这是一个从范畴 $\cat{C}$ 的对象到函子的映射，这些函子是函子范畴（functor category）中的\emph{对象}（参见关于\hyperref[natural-transformations]{自然变换（Natural Transformations）}的章节）。我们用符号 $[\cat{C}, \Set]$ 来表示从 $\cat{C}$ 到 $\Set$ 的函子范畴。你可能还记得，同态函子是\hyperref[representable-functors]{可表函子（representable functors）}的原型。

每当我们在两个范畴之间有对象的映射时，自然会问这种映射是否也是一个函子。换句话说，我们能否将一个范畴中的态射提升为另一个范畴中的态射。$\cat{C}$ 中的一个态射只是 $\cat{C}(a, b)$ 的一个元素，但在函子范畴 $[\cat{C}, \Set]$ 中的态射是一个自然变换（natural transformation）。所以我们在寻找将态射映射到自然变换的映射。

让我们看看是否能找到与态射 $f \Colon a \to b$ 对应的自然变换。首先，让我们看看 $a$ 和 $b$ 被映射到了哪里。它们被映射到两个函子：$\cat{C}(a, -)$ 和 $\cat{C}(b, -)$。我们需要在这两个函子之间找到一个自然变换。

这就是诀窍：我们使用Yoneda引理（Yoneda lemma）：
\[[\cat{C}, \Set](\cat{C}(a, -), F) \cong F a\]
并将一般的 $F$ 替换为同态函子 $\cat{C}(b, -)$。我们得到：
\[[\cat{C}, \Set](\cat{C}(a, -), \cat{C}(b, -)) \cong \cat{C}(b, a)\]
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{images/yoneda-embedding.jpg}
\end{figure}

\noindent
这正是我们在寻找的两个同态函子之间的自然变换，只是有一个小转折：我们有一个自然变换和态射之间的映射——$\cat{C}(b, a)$ 的一个元素——它朝着“错误”的方向移动。但这没关系；这只意味着我们正在看的函子是逆变函子（contravariant）。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.65\textwidth]{images/yoneda-embedding-2.jpg}
\end{figure}

\noindent
实际上，我们得到了比预期更多的东西。$\cat{C}$ 到 $[\cat{C}, \Set]$ 的映射不仅仅是一个逆变函子——它是一个\emph{完全忠实（fully faithful）}的函子。完全性（fullness）和忠实性（faithfulness）是描述函子如何映射同态集的属性。

一个\emph{忠实（faithful）}函子在同态集中是\newterm{单射（injective）}的，这意味着它将不同的态射映射到不同的态射。换句话说，它不会将它们合并。

一个\emph{完全（full）}函子在同态集中是\newterm{满射（surjective）}的，这意味着它将一个同态集\emph{映射到}另一个同态集，完全覆盖后者。

一个完全忠实函子 $F$ 是同态集上的\newterm{双射（bijection）}——一个一对一匹配的所有元素。对于源范畴 $\cat{C}$ 中的每一对对象 $a$ 和 $b$，$\cat{C}(a, b)$ 与 $F$ 的目标范畴 $\cat{D}$ 中的 $\cat{D}(F a, F b)$ 之间存在一个双射。在我们的情况下，$\cat{D}$ 是函子范畴 $[\cat{C}, \Set]$。注意，这并不意味着 $F$ 是对象上的双射。$\cat{D}$ 中可能存在不在 $F$ 映像中的对象，我们无法对这些对象的同态集发表任何意见。

\section{嵌入（The Embedding）}

我们刚刚描述的（逆变）函子，函子将 $\cat{C}$ 中的对象映射到 $[\cat{C}, \Set]$ 中的函子：
\[a \to \cat{C}(a, -)\]
定义了\newterm{Yoneda嵌入（Yoneda embedding）}。它将范畴 $\cat{C}$（严格来说是逆范畴 $\cat{C}^\mathit{op}$，因为它是逆变的）\emph{嵌入}到函子范畴 $[\cat{C}, \Set]$ 中。它不仅将 $\cat{C}$ 中的对象映射为函子，还忠实地保留了它们之间的所有联系。

这是一个非常有用的结果，因为数学家们对函子范畴，尤其是那些对域为 $\Set$ 的函子范畴了解很多。通过将任意范畴嵌入到函子范畴中，我们可以获得很多关于这个范畴的洞见。

当然，Yoneda嵌入还有一个对偶版本，有时被称为co-Yoneda嵌入。注意，我们本可以通过固定每个同态集的目标对象（而不是源对象）来开始。这将给我们一个逆变同态函子。逆变函子从 $\cat{C}$ 到 $\Set$ 是我们熟悉的预层（presheaves）（参见，例如，\hyperref[limits-and-colimits]{极限与余极限（Limits and Colimits）}）。co-Yoneda嵌入定义了将范畴 $\cat{C}$ 嵌入到预层范畴中的嵌入。它在态射上的作用是：
\[[\cat{C}^\mathit{op}, \Set](\cat{C}(-, a), \cat{C}(-, b)) \cong \cat{C}(a, b)\]
同样，数学家们对预层范畴了解很多，所以能够将任意范畴嵌入其中是一个巨大的胜利。

\section{在 Haskell 中的应用（Application to Haskell）}

在 Haskell 中，Yoneda嵌入可以表示为读者函子（reader functors）之间的自然变换与函数（逆向进行）之间的同构：

\begin{snipv}
  forall x. (a -> x) -> (b -> x) \ensuremath{\cong} b -> a
\end{snipv}
（请记住，读者函子相当于 \code{((->) a)}。）

这个等式的左侧是一个多态函数，给定从 \code{a} 到 \code{x} 的一个函数和一个类型为 \code{b} 的值，可以生成一个类型为 \code{x} 的值（我正在展开——去掉了函数 \code{b -> x} 周围的括号）。唯一能对所有 \code{x} 执行此操作的方法是，如果我们的函数知道如何将 \code{b} 转换为 \code{a}。它必须秘密访问一个从 \code{b} 到 \code{a} 的函数。

给定这样一个转换器 \code{btoa}，我们可以定义左侧，称其为 \code{fromY}，如下所示：

\src{snippet01}
相反，给定一个 \code{fromY} 函数，我们可以通过调用 \code{fromY} 和 \code{id} 来恢复转换器：

\src{snippet02}
这建立了 \code{fromY} 和 \code{btoa} 类型的函数之间的双射。

另一种看待这种同构的方法是，它是从 \code{b} 到 \code{a} 的函数的\acronym{CPS} 编码。参数 \code{a -> x} 是一个延续（continuation）（处理程序）。结果是一个从 \code{b} 到 \code{x} 的函数，当它被调用并传递一个类型为 \code{b} 的值时，将执行与编码函数预组合的延续。

Yoneda嵌入还解释了 Haskell 中某些数据结构的替代表示。特别是，它为 \code{Control.Lens} 库中的镜头（lenses）提供了\urlref{https://bartoszmilewski.com/2015/07/13/from-lenses-to-yoneda-embedding/}{非常有用的表示（very useful representation）}。

\section{预序示例（Preorder Example）}

这个示例由 Robert Harper 提出。它是 Yoneda 嵌入应用于由预序（preorder）定义的范畴。预序是一个具有元素间顺序关系的集合，传统上写作 $\leqslant$（小于或等于）。“预（pre）”在预序中是因为我们只要求关系是传递的和自反的，而不一定是反对称的（所以有可能出现循环）。

具有预序关系的集合会产生一个范畴。对象是这个集合的元素。从对象 $a$ 到 $b$ 的态射要么不存在，如果对象不可比较或 $a \leqslant b$ 不成立；要么存在，如果 $a \leqslant b$，并且它从 $a$ 指向 $b$。在这种范畴中，从一个对象到另一个对象的态射最多只有一个。因此，在这种范畴中，任何同态集要么是一个空集，要么是一个单元素集。这样的范畴被称为\emph{瘦（thin）}范畴。

很容易让自己相信这种结构确实是一个范畴：箭头是可组合的，因为如果 $a \leqslant b$ 和 $b \leqslant c$，那么 $a \leqslant c$；并且组合是结合的。我们还拥有身份箭头，因为每个元素（小于或）等于它自己（关系的自反性）。

现在我们可以将 co-Yoneda 嵌入应用于预序范畴。特别是，我们感兴趣的是它对态射的作用：
\[[\cat{C}, \Set](\cat{C}(-, a), \cat{C}(-, b)) \cong \cat{C}(a, b)\]
右侧的同态集当且仅当 $a \leqslant b$ 时非空——在这种情况下，它是一个单元素集。因此，如果 $a \leqslant b$，则左侧存在单个自然变换。否则不存在自然变换。

那么，在预序中，同态函子之间的自然变换是什么？它应该是集合 $\cat{C}(-, a)$ 和 $\cat{C}(-, b)$ 之间的一组函数。在预序中，每个这些集合要么为空，要么是单元素集合。让我们看看有什么样的函数可以供我们使用。

存在一个从空集到自身的函数（作用于空集的身份），一个从空集到单元素集合的函数 \code{absurd}（它什么也不做，因为它只需要为空集中的元素定义，而空集中没有元素），以及一个从单元素集合到自身的函数（作用于单元素集合的身份）。唯一被禁止的组合是将单元素集合映射到空集合的组合（当对单个元素作用时，这种函数的值将是什么？）。

因此，我们的自然变换永远不会将单元素同态集连接到空同态集。换句话说，如果 $x \leqslant a$（单元素同态集 $\cat{C}(x, a)$），那么 $\cat{C}(x, b)$ 不能为空。$\cat{C}(x, b)$ 非空意味着 $x$ 小于或等于 $b$。因此，所讨论的自然变换的存在要求，对于每个 $x$，如果 $x \leqslant a$，则 $x \leqslant b$。
\[\text{对所有 } x，x \leqslant a \Rightarrow x \leqslant b\]
另一方面，co-Yoneda 告诉我们，这种自然变换的存在等价于 $\cat{C}(a, b)$ 非空，或者 $a \leqslant b$。综合起来，我们得到：
\[a \leqslant b \text{ 当且仅当对于所有 } x，x \leqslant a \Rightarrow x \leqslant b\]
我们本可以直接得出这个结论。直觉是，如果 $a \leqslant b$，那么所有低于 $a$ 的元素也必须低于 $b$。反过来，当你在右侧将 $a$ 替换为 $x$ 时，得出 $a \leqslant b$。但是你必须承认，通过 Yoneda 嵌入得出这个结果要更加令人兴奋。

\section{自然性（Naturality）}

Yoneda 引理建立了自然变换集与 $\Set$ 中的对象之间的同构。自然变换是函子范畴 $[\cat{C}, \Set]$ 中的态射。任何两个函子之间的自然变换集是该范畴中的同态集。Yoneda 引理是一个同构：
\[[\cat{C}, \Set](\cat{C}(a, -), F) \cong F a\]
这个同构在 $F$ 和 $a$ 中都具有自然性（natural）。换句话说，它在 $(F, a)$ 上是自然的，这是从积范畴 $[\cat{C}, \Set] \times \cat{C}$ 中选取的一对。注意，我们现在将 $F$ 视为函子范畴中的\newterm{对象（object）}。

让我们稍微想一下这意味着什么。自然同构是两个函子之间可逆的\emph{自然变换}。而且，确实，我们同构的右侧是一个函子。它是从 $[\cat{C}, \Set] \times \cat{C}$ 到 $\Set$ 的函子。它在一对 $(F, a)$ 上的作用是一个集合——评估函子 $F$ 在对象 $a$ 处的结果。这个函子被称为评估函子（evaluation functor）。

左侧也是一个函子，它将 $(F, a)$ 映射到自然变换的集合 $[\cat{C}, \Set](\cat{C}(a, -), F)$。

为了表明这些确实是函子，我们还应该定义它们在态射上的作用。但在一对 $(F, a)$ 和 $(G, b)$ 之间的态射是什么？它是一对态射 $(\Phi, f)$；第一个是函子之间的态射——自然变换；第二个是 $\cat{C}$ 中的常规态射。

评估函子将这一对 $(\Phi, f)$ 映射到两个集合 $F a$ 和 $G b$ 之间的一个函数。我们可以很容易地从 $\Phi$ 在 $a$ 处的分量（将 $F a$ 映射到 $G a$）和 $f$ 被 $G$ 提升的态射构建这样一个函数：
\[(G f) \circ \Phi_a\]
注意，由于 $\Phi$ 的自然性，这与以下内容相同：
\[\Phi_b \circ (F f)\]
我不会证明整个同构的自然性——一旦你确定了函子是什么，证明就相当机械化。因为我们的同构是由函子和自然变换构建的，所以它没有出错的可能。

\section{挑战（Challenges）}

\begin{enumerate}
  \tightlist
  \item
  用 Haskell 表达 co-Yoneda 嵌入。
  \item
  证明我们在 \code{fromY} 和 \code{btoa} 之间建立的双射是一个同构（两个映射互为逆）。
  \item
  计算出单子（monoid）的 Yoneda 嵌入。哪个函子对应于单子的单个对象？哪些自然变换对应于单子的态射？
  \item
  协变 Yoneda 嵌入在预序中的应用是什么？（问题由 Gershom Bazerman 提出。）
  \item
  可以使用 Yoneda 嵌入将任意函子范畴 $[\cat{C}, \cat{D}]$ 嵌入到函子范畴 $[[\cat{C}, \cat{D}], \Set]$ 中。弄清楚它如何在态射上工作（在这种情况下，这些态射是自然变换）。
\end{enumerate}
