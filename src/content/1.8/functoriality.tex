% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{现}{在你已经了解} 了什么是函子，并且看过了一些例子，现在让我们看看如何从更小的函子构建更大的函子。特别有趣的是看看哪些类型构造器（对应于范畴中的对象之间的映射）可以扩展为函子（包括态射之间的映射）。

\section{双函子（Bifunctors）}

由于函子是 $\Cat$（范畴的范畴）中的态射，许多关于态射的直觉——特别是关于函数的直觉——同样适用于函子。例如，就像你可以有两个参数的函数一样，你可以有两个参数的函子，或称为\newterm{双函子}。在对象上，双函子将每对对象，一个来自范畴 $\cat{C}$，另一个来自范畴 $\cat{D}$，映射到范畴 $\cat{E}$ 中的一个对象。注意，这只是说它是从范畴 $\cat{C}\times{}\cat{D}$ 的\newterm{笛卡尔积}到 $\cat{E}$ 的映射。

\begin{figure}[H]
  \centering\includegraphics[width=0.3\textwidth]{images/bifunctor.jpg}
\end{figure}

\noindent
这相当直接。但是函子性意味着双函子也必须映射态射。不过这次，它必须将一对态射，一个来自 $\cat{C}$，另一个来自 $\cat{D}$，映射到 $\cat{E}$ 中的一个态射。

同样，一对态射只是在乘积范畴 $\cat{C}\times{}\cat{D}$ 中的一个态射。我们将笛卡尔积范畴中的态射定义为从一对对象到另一对对象的态射对。这些态射对可以以显而易见的方式进行组合：
\[(f, g) \circ (f', g') = (f \circ f', g \circ g')\]
这种组合是结合的，并且它有一个恒等元——一对恒等态射 $(\id, \id)$。所以笛卡尔积范畴确实是一个范畴。

思考双函子的一种更简单的方式是将它们视为每个参数单独的函子。因此，不必将函子性法则——结合性和恒等性——从函子翻译到双函子，只需分别为每个参数单独检查它们。然而，一般来说，单独的函子性不足以证明联合函子性。在联合函子性失败的范畴中，这些范畴被称为\newterm{准单元}（premonoidal）。

让我们在 Haskell 中定义一个双函子。在这种情况下，所有三个范畴都是相同的：Haskell 类型的范畴。双函子是一个接受两个类型参数的类型构造器。以下是来自库 \code{Control.Bifunctor} 的 \code{Bifunctor} 类型类的定义：

\src{snippet01}

\begin{figure}[H]
  \centering\includegraphics[width=0.3\textwidth]{images/bimap.jpg}
  \caption{bimap}
\end{figure}

类型变量 \code{f} 表示双函子。你可以看到，在所有类型签名中它总是应用于两个类型参数。第一个类型签名定义了 \code{bimap}：一次映射两个函数。结果是一个提升后的函数 \code{(f a b -> f c d)}，作用于由双函子类型构造器生成的类型。还有一个基于 \code{first} 和 \code{second} 的 \code{bimap} 的默认实现。（如前所述，这并不总是有效，因为两个映射可能不交换，也就是说 \code{first g . second h} 可能与 \code{second h . first g} 不相同。）

\noindent
另外两个类型签名 \code{first} 和 \code{second} 是两个 \code{fmap}，分别见证 \code{f} 在第一个和第二个参数上的函子性。

\begin{figure}[H]
  \centering
  \begin{minipage}{0.45\textwidth}
    \centering
    \includegraphics[width=0.65\textwidth]{images/first.jpg} % first figure itself
    \caption{first}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \centering
    \includegraphics[width=0.6\textwidth]{images/second.jpg} % second figure itself
    \caption{second}
  \end{minipage}
\end{figure}

\noindent
类型类定义提供了它们两者的默认实现，基于 \code{bimap}。

在声明 \code{Bifunctor} 的实例时，你可以选择实现 \code{bimap} 并接受 \code{first} 和 \code{second} 的默认值，或者实现 \code{first} 和 \code{second} 并接受 \code{bimap} 的默认值（当然，你也可以实现这三者，但此时确保它们彼此之间相关联的责任在你）。

\section{积函子和余积函子（Product and Coproduct Bifunctors）}

双函子的重要例子之一是范畴积——两个对象的积，它由一个\hyperref[products-and-coproducts]{通用构造}定义。如果对于任意一对对象都存在积，那么从这些对象到积的映射是双函子的。这在一般情况下成立，特别是在 Haskell 中也是如此。以下是配对构造器的 \code{Bifunctor} 实例——最简单的积类型：

\src{snippet02}[b]
没有太多选择：\code{bimap} 简单地将第一个函数应用于第一个组件，将第二个函数应用于配对的第二个组件。考虑到类型，代码几乎是自动生成的：

\src{snippet03}
这里双函子的作用是生成类型的对，例如：

\begin{snip}{haskell}
(,) a b = (a, b)
\end{snip}
通过对偶，余积，如果它定义在范畴中的每对对象上，也将是一个双函子。在 Haskell 中，这由 \code{Either} 类型构造器作为 \code{Bifunctor} 实例体现：

\src{snippet04}[b]
这段代码也几乎是自动生成的。

现在，记得我们讨论过的单元范畴吗？单元范畴定义了一个作用于对象的二元操作符，以及一个单位对象。我提到过，相对于笛卡尔积，$\Set$ 是一个单元范畴，单例集合作为单位。而且它也是一个相对于不相交并集的单元范畴，空集合作为单位。我没有提到的是，单元范畴的一个要求是二元操作符是一个双函子。这是一个非常重要的要求——我们希望单元积与范畴的结构兼容，该结构由态射定义。现在我们离单元范畴的完整定义又近了一步（我们还需要学习自然性，然后我们才能到达那里）。

\section{函子的代数数据类型（Functorial Algebraic Data Types）}

我们已经看到了一些参数化数据类型的例子，它们最终被证明是函子——我们能够为它们定义 \code{fmap}。复杂的数据类型是由更简单的数据类型构造的。特别是，代数数据类型 (\acronym{ADT}s) 是使用和与积构造的。我们刚刚看到和与积是函子的。我们也知道函子是可以组合的。因此，如果我们能证明 \acronym{ADT}s 的基本构建块是函子的，我们就能知道参数化的 \acronym{ADT}s 也是函子的。

那么什么是参数化代数数据类型的构建块？首先，有些项与函子的类型参数无关，比如 \code{Maybe} 中的 \code{Nothing}，或者 \code{List} 中的 \code{Nil}。它们等价于 \code{Const} 函子。记住，\code{Const} 函子忽略了它的类型参数（实际上，它忽略了\emph{第二个}类型参数，即我们感兴趣的那个，第一个保持不变）。

然后，有些元素只是简单地封装了类型参数本身，比如 \code{Maybe} 中的 \code{Just}。它们等价于恒等函子。我之前提到过恒等函子，作为 \emph{Cat} 中的恒等态射，但没有给出它在 Haskell 中的定义。这里是：

\src{snippet05}

\src{snippet06}
你可以将 \code{Identity} 视为始终存储一个类型 \code{a} 的（不可变的）值的最简单的容器。

代数数据结构中的其他所有内容都是使用这些两个原语通过积与和构造的。

有了这个新知识，让我们重新审视 \code{Maybe} 类型构造器：

\src{snippet07}
它是两个类型的和，而我们现在知道和是函子的。第一部分，\code{Nothing} 可以表示为作用于 \code{a} 的 \code{Const ()}（\code{Const} 的第一个类型参数设置为单位——稍后我们将看到 \code{Const} 的更有趣的用途）。第二部分只是恒等函子的另一个名字。我们可以将 \code{Maybe} 定义为，直到同构为止：

\src{snippet08}
因此 \code{Maybe} 是双函子 \code{Either} 与两个函子 \code{Const ()} 和 \code{Identity} 的组合。（\code{Const} 实际上是一个双函子，但在这里我们总是部分应用它。）

我们已经看到，函子的组合是一个函子——我们可以很容易地说服自己，同样的道理适用于双函子。我们需要做的就是弄清楚双函子与两个函子的组合如何在态射上起作用。给定两个态射，我们简单地用一个函子提升其中一个，用另一个函子提升另一个态射。然后我们用双函子提升得到的态射对。

我们可以在 Haskell 中表达这个组合。让我们定义一个数据类型，它由双函子 \code{bf} 参数化（它是一个接受两个类型作为参数的类型构造器），两个函子 \code{fu} 和 \code{gu}（每个都接受一个类型变量的类型构造器），以及两个常规类型 \code{a} 和 \code{b}。我们将 \code{fu} 应用于 \code{a}，将 \code{gu} 应用于 \code{b}，然后将 \code{bf} 应用于结果的两个类型：

\src{snippet09}
这就是对象或类型上的组合。注意在 Haskell 中我们如何将类型构造器应用于类型，就像我们将函数应用于参数一样。语法是相同的。

如果你有点迷失，不妨尝试将 \code{BiComp} 应用于 \code{Either}、\code{Const ()}、\code{Identity}、\code{a} 和 \code{b}，以此顺序。你会恢复我们精简版的 \code{Maybe b}（\code{a} 被忽略）。

新的数据类型 \code{BiComp} 是 \code{a} 和 \code{b} 的双函子，但前提是 \code{bf} 本身是一个 \code{Bifunctor}，而 \code{fu} 和 \code{gu} 是 \code{Functor}s。编译器必须知道在 \code{BiComp} 使用时，将有一个 \code{bimap} 的定义可用，以及 \code{fu} 和 \code{gu} 的 \code{fmap} 的定义。在 Haskell 中，这在实例声明中通过类约束集和双箭头来表达：

\src{snippet10}[b]
\code{BiComp} 的 \code{bimap} 的实现是基于 \code{bf} 的 \code{bimap} 和两个 \code{fmap}（对于 \code{fu} 和 \code{gu}）的实现。每当使用 \code{BiComp} 时，编译器会自动推断出所有类型，并选择正确的重载函数。

\code{bimap} 定义中的 \code{x} 具有如下类型：

\src{snippet11}
这真是有点绕口。外层 \code{bimap} 通过外层 \code{bf} 层次，两个 \code{fmap} 分别深入到 \code{fu} 和 \code{gu} 内部。如果 \code{f1} 和 \code{f2} 的类型是：

\src{snippet12}
那么最终结果的类型是 \code{bf (fu a') (gu b')}：

\src{snippet13}[b]
如果你喜欢拼图，这种类型操作可以提供数小时的娱乐。

因此，事实证明，我们不必证明 \code{Maybe} 是一个函子——这个事实是由于它被构造为两个函子性原语的和而得出的。

敏锐的读者可能会问一个问题：如果代数数据类型的 \code{Functor} 实例的推导如此机械化，难道不能由编译器自动化执行吗？确实如此，并且实际上是这样。你只需要通过在源文件顶部包含以下行来启用特定的 Haskell 扩展：

\begin{snip}{haskell}
{-# LANGUAGE DeriveFunctor #-}
\end{snip}
然后将 \code{deriving Functor} 添加到你的数据结构中：

\begin{snip}{haskell}
  data Maybe a = Nothing | Just a deriving Functor
\end{snip}
并且相应的 \code{fmap} 将由编译器为你实现。

代数数据结构的规则性使得不仅可以推导出 \code{Functor} 实例，还可以推导出其他几个类型类的实例，包括我之前提到的 \code{Eq} 类型类。还可以选择教授编译器派生你自己的类型类实例，但这有点高级。然而，思路是相同的：你为基本构建块、和与积提供行为，然后让编译器找出其余的内容。

\section{C++ 中的函子（Functors in C++）}

如果你是一名 C++ 程序员，那么在实现函子方面显然只能靠自己了。然而，你应该能够在 C++ 中识别出一些代数数据结构类型。如果这种数据结构被制作成通用模板，你应该能够快速为其实现 \code{fmap}。

让我们看看一个树形数据结构，我们在 Haskell 中将其定义为递归和类型：

\src{snippet14}
正如我之前提到的，在 C++ 中实现和类型的一种方式是通过类层次结构。在面向对象的语言中，将 \code{fmap} 实现为基类 \code{Functor} 的虚函数然后在所有子类中重载它是很自然的。不幸的是，这是不可能的，因为 \code{fmap} 是一个模板，不仅由它作用的对象类型（\code{this} 指针）参数化，还由应用于它的函数的返回类型参数化。在 C++ 中，虚函数不能模板化。我们将 \code{fmap} 实现为一个通用的自由函数，并用 \code{dynamic\_cast} 替换模式匹配。

基类必须至少定义一个虚函数以支持动态转换，因此我们将析构函数设置为虚函数（这在任何情况下都是一个好主意）：

\begin{snip}{cpp}
  template<class T>
  struct Tree {
    virtual ~Tree() {}
  };
\end{snip}
\code{Leaf} 只是一个伪装成 \code{Identity} 的函子：

\begin{snip}{cpp}
  template<class T>
  struct Leaf : public Tree<T> {
    T _label;
    Leaf(T l) : _label(l) {}
  };
\end{snip}
\code{Node} 是一个积类型：

\begin{snip}{cpp}
  template<class T>
  struct Node : public Tree<T> {
    Tree<T> * _left;
    Tree<T> * _right;
    Node(Tree<T> * l, Tree<T> * r) : _left(l), _right(r) {}
  };
\end{snip}
在实现 \code{fmap} 时，我们利用了 \code{Tree} 类型的动态调度。 \code{Leaf} 情况下应用了 \code{Identity} 版本的 \code{fmap}，而 \code{Node} 情况下则被视为一个与两个 \code{Tree} 函子副本组合的双函子。作为 C++ 程序员，你可能不习惯以这些术语分析代码，但这是一个很好的范畴思考练习。

\begin{snip}{cpp}
  template<class A, class B>
  Tree<B> * fmap(std::function<B(A)> f, Tree<A> * t) {
    Leaf<A> * pl = dynamic_cast <Leaf<A>*>(t);
    if (pl)
    return new Leaf<B>(f (pl->_label));
    Node<A> * pn = dynamic_cast<Node<A>*>(t);
    if (pn)
    return new Node<B>( fmap<A>(f, pn->_left)
    , fmap<A>(f, pn->_right));
    return nullptr;
  }
\end{snip}
为了简单起见，我决定忽略内存和资源管理问题，但在生产代码中，你可能会使用智能指针（独占或共享，具体取决于你的策略）。

将其与 Haskell 中的 \code{fmap} 实现进行比较：

\src{snippet15}
这个实现也可以由编译器自动派生。

\section{写入函子（The Writer Functor）}

我承诺过会回到我之前描述的\hyperref[kleisli-categories]{Kleisli 范畴}。该范畴中的态射表示为返回 \code{Writer} 数据结构的“装饰”函数。

\src{snippet16}
我说过这种装饰与内函子（endofunctors）有某种关系。实际上，\code{Writer} 类型构造器在 \code{a} 中是函子。我们甚至不需要为其实现 \code{fmap}，因为它只是一个简单的积类型。

但 Kleisli 范畴与函子之间的一般关系是什么呢？作为一个范畴，Kleisli 范畴定义了组合和恒等性。让我提醒你，组合由鱼运算符给出：

\src{snippet17}
恒等态射由称为 \code{return} 的函数给出：

\src{snippet18}
事实证明，如果你花足够长的时间（我指的是\emph{足够长的时间}）看这些两个函数的类型，你可以找到一种方法将它们组合起来，以产生一个具有合适类型签名的函数作为 \code{fmap}。像这样：

\src{snippet19}
这里，鱼运算符结合了两个函数：一个是熟悉的 \code{id}，另一个是将 \code{f} 作用于 lambda 的参数并对其结果应用 \code{return} 的 lambda。最难理解的部分可能是 \code{id} 的使用。鱼运算符的参数不是应该是一个接受“正常”类型并返回装饰类型的函数吗？实际上不是。没有人说 \code{a} 在 \code{a -> Writer b} 中必须是一个“正常”的类型。它是一个类型变量，因此它可以是任何东西，特别是它可以是一个装饰类型，比如 \code{Writer b}。

所以 \code{id} 会将 \code{Writer a} 转换为 \code{Writer a}。鱼运算符会取出 \code{a} 的值并作为 \code{x} 传递给 lambda。在那里，\code{f} 会将它转换为 \code{b}，\code{return} 会将其装饰，使其成为 \code{Writer b}。综合起来，我们最终得到一个接受 \code{Writer a} 并返回 \code{Writer b} 的函数，这正是 \code{fmap} 应该产生的。

注意，这个论点非常通用：你可以用任何类型构造器替换 \code{Writer}。只要它支持鱼运算符和 \code{return}，你就可以定义 \code{fmap}。因此，Kleisli 范畴中的装饰总是一个函子。（但并不是每个函子都会产生一个 Kleisli 范畴。）

你可能想知道我们刚才定义的 \code{fmap} 是否与编译器为我们派生的 \code{fmap} 相同。有趣的是，确实如此。这是因为 Haskell 实现多态函数的方式。它被称为\newterm{参数多态性}（parametric polymorphism），这是所谓的\newterm{免费定理}（theorems for free）的来源。其中特别一个定理说，如果对于给定的类型构造器有一个 \code{fmap} 实现，并且它保持恒等性，那么它一定是唯一的。

\section{协变和逆变函子（Covariant and Contravariant Functors）}

现在我们已经回顾了写入函子，让我们回到读取函子。它基于部分应用的函数箭头类型构造器：

\src{snippet20}
我们可以将其重写为类型同义词：

\src{snippet21}
我们之前见过的 \code{Functor} 实例如下所示：

\src{snippet22}
但就像配对类型构造器或 \code{Either} 类型构造器一样，函数类型构造器接受两个类型参数。配对和 \code{Either} 在两个参数中都是函子性——它们是双函子。函数构造器也是双函子吗？

让我们尝试使它在第一个参数中函子性。我们从一个类型同义词开始——它就像 \code{Reader} 但参数顺序相反：

\src{snippet23}
这次我们固定返回类型 \code{r}，并改变参数类型 \code{a}。让我们看看我们是否可以以某种方式匹配类型来实现 \code{fmap}，它将具有以下类型签名：

\src{snippet24}
仅凭两个接受 \code{a} 并分别返回 \code{b} 和 \code{r} 的函数，没有任何方法可以构建一个接受 \code{b} 并返回 \code{r} 的函数！如果我们能够以某种方式反转第一个函数，使其接受 \code{b} 并返回 \code{a}，情况就会有所不同。我们不能反转一个任意的函数，但我们可以进入对偶范畴。

简单回顾一下：对于每个范畴 $\cat{C}$，都有一个对偶范畴 $\cat{C}^\mathit{op}$。这是一个与 $\cat{C}$ 具有相同对象的范畴，但所有箭头都反转了。

考虑一个从 $\cat{C}^\mathit{op}$ 到另一个范畴 $\cat{D}$ 的函子：
\[F \Colon \cat{C}^\mathit{op} \to \cat{D}\]
这样的函子将 $\cat{C}^\mathit{op}$ 中的态射 $f^\mathit{op} \Colon a \to b$ 映射到 $\cat{D}$ 中的态射 $F f^\mathit{op} \Colon F a \to F b$。但态射 $f^\mathit{op}$ 实际上对应于原范畴 $\cat{C}$ 中的某个态射 $f \Colon b \to a$。注意到这个反转。

现在，$F$ 是一个常规的函子，但我们可以基于 $F$ 定义另一个映射，它不是一个函子——我们称之为 $G$。这是从 $\cat{C}$ 到 $\cat{D}$ 的映射。它以与 $F$ 相同的方式映射对象，但当涉及映射态射时，它会反转它们。它接受 $\cat{C}$ 中的态射 $f \Colon b \to a$，首先将其映射到对偶态射 $f^\mathit{op} \Colon a \to b$，然后在其上使用函子 $F$，得到 $F f^\mathit{op} \Colon F a \to F b$。

考虑到 $F a$ 与 $G a$ 相同，$F b$ 与 $G b$ 相同，整个过程可以描述为：$G f \Colon (b \to a) \to (G a \to G b)$。这是一种“带有扭曲”的函子。以这种方式反转态射方向的范畴映射称为\emph{逆变函子}。注意，逆变函子只是来自对偶范畴的常规函子。而我们迄今为止研究的常规函子，称为\emph{协变函子}。

\begin{figure}[H]
  \centering
  \includegraphics[width=40mm]{images/contravariant.jpg}
\end{figure}

\noindent
以下是 Haskell 中定义逆变函子的类型类（确实是逆变\emph{端函子}）：

\src{snippet25}
我们的类型构造器 \code{Op} 是其实例：

\src{snippet26}
注意到函数 \code{f} 插入在 \emph{之前}（即，位于右侧）\code{Op} 的内容——函数 \code{g}。

\code{Op} 的 \code{contramap} 的定义可能更加简洁，如果你注意到它只是带有翻转参数的函数组合运算符。有一个名为 \code{flip} 的特殊函数：

\src{snippet27}
有了它，我们得到：

\src{snippet28}

\section{前函子（Profunctors）}

我们已经看到，函数箭头运算符在第一个参数中是逆变的，在第二个参数中是协变的。这种怪物有名字吗？事实证明，如果目标范畴是 $\Set$，这种怪物被称为\newterm{前函子}。因为逆变函子等同于来自对偶范畴的协变函子，所以前函子定义为：
\[\cat{C}^\mathit{op} \times \cat{D} \to \Set\]
由于 Haskell 类型在一定程度上可以看作是集合，因此我们将 \code{Profunctor} 名称应用于一个双参数的类型构造器 \code{p}，它在第一个参数中是逆变的，在第二个参数中是函子的。以下是取自 \code{Data.Profunctor} 库的适当类型类：

\src{snippet29}[b]
所有三个函数都有默认实现。就像 \code{Bifunctor} 一样，当声明 \code{Profunctor} 的实例时，你可以选择实现 \code{dimap} 并接受 \code{lmap} 和 \code{rmap} 的默认值，或者实现 \code{lmap} 和 \code{rmap} 并接受 \code{dimap} 的默认值。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/dimap.jpg}
  \caption{dimap}
\end{figure}

\noindent
现在我们可以断言函数箭头运算符是 \code{Profunctor} 的一个实例：

\src{snippet30}[b]
前函子在 Haskell 的 lens 库中有其应用。我们在讨论端和余端时还会再次见到它们。

\section{同态函子（The Hom-Functor）}

上面的例子反映了一个更一般的陈述，即将一对对象 $a$ 和 $b$ 映射到它们之间的态射集 $\cat{C}(a, b)$ 的映射是一个函子。它是从乘积范畴 $\cat{C}^\mathit{op}\times{}\cat{C}$ 到集合范畴 $\Set$ 的一个函子。

让我们定义其对态射的作用。$\cat{C}^\mathit{op}\times{}\cat{C}$ 中的一个态射是一对来自 $\cat{C}$ 的态射：
\begin{gather*}
  f \Colon a' \to a \\
  g \Colon b \to b'
\end{gather*}
这对的提升必须是从集合 $\cat{C}(a, b)$ 到集合 $\cat{C}(a', b')$ 的态射（一个函数）。只需选择 $\cat{C}(a, b)$ 的任何元素 $h$（这是从 $a$ 到 $b$ 的态射），并将其映射为：
\[g \circ h \circ f\]
这是 $\cat{C}(a', b')$ 的一个元素。

如你所见，同态函子是前函子的一个特例。

\section{挑战}

\begin{enumerate}
  \tightlist
  \item
  证明数据类型：

  \begin{snip}{haskell}
    data Pair a b = Pair a b
  \end{snip}

  是一个双函子。为额外加分，实现 \code{Bifunctor} 的所有三种方法，并使用等式推理证明这些定义在可以应用的情况下与默认实现兼容。
  \item
  证明标准定义的 \code{Maybe} 与以下展开的同构性：

  \begin{snip}{haskell}
    type Maybe' a = Either (Const () a) (Identity a)
  \end{snip}

  提示：定义两者之间的两个映射。为额外加分，使用等式推理证明它们是彼此的逆映射。
  \item
  让我们尝试另一个数据结构。我称之为 \code{PreList}，因为它是 \code{List} 的前体。它用一个类型参数 \code{b} 替换了递归。

  \begin{snip}{haskell}
    data PreList a b = Nil | Cons a b
  \end{snip}

  你可以通过递归应用 \code{PreList} 来恢复我们之前定义的 \code{List}（我们会在讨论不动点时看到它是如何完成的）。

  证明 \code{PreList} 是 \code{Bifunctor} 的一个实例。
  \item
  证明以下数据类型在 \code{a} 和 \code{b} 中定义了双函子：

  \begin{snip}{haskell}
    data K2 c a b = K2 c

    data Fst a b = Fst a

    data Snd a b = Snd b
  \end{snip}

  为额外加分，将你的解决方案与 Conor McBride 的论文 \urlref{http://strictlypositive.org/CJ.pdf}{Clowns to the Left of me, Jokers to the Right} 进行对比。
  \item
  用 Haskell 以外的语言定义一个双函子。在该语言中为通用对实现 \code{bimap}。
  \item
  \code{std::map} 应该在两个模板参数 \code{Key} 和 \code{T} 中被视为双函子还是前函子？你会如何重新设计此数据类型以使其成为这样？
\end{enumerate}
