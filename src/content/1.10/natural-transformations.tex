% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{我}{们讨论了}函子（functor）作为在范畴之间的映射，它们保留了范畴的结构。

一个函子将一个范畴“嵌入”到另一个范畴中。它可能会将多个事物折叠成一个，但它从不破坏连接。我们可以认为，使用函子时，我们是在另一个范畴内建模一个范畴。源范畴作为某种结构的模型，一个蓝图，而这个结构是目标范畴的一部分。

\begin{figure}[H]
  \centering\includegraphics[width=0.4\textwidth]{images/1_functors.jpg}
\end{figure}

\noindent
可能有很多种方式将一个范畴嵌入到另一个范畴中。有时它们是等价的，有时则非常不同。一个可能会将整个源范畴折叠成一个对象，而另一个可能将每个对象映射到不同的对象，每个态射（morphism）映射到不同的态射。同一个蓝图可以以多种不同的方式实现。自然变换（natural transformations）帮助我们比较这些实现。它们是函子的映射——一种特殊的映射，保留了函子的本质特性。

考虑在范畴 $\cat{C}$ 和 $\cat{D}$ 之间的两个函子 $F$ 和 $G$。如果你只关注 $\cat{C}$ 中的一个对象 $a$，它将被映射为两个对象：$F a$ 和 $G a$。一个函子的映射应该将 $F a$ 映射为 $G a$。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/2_natcomp.jpg}
\end{figure}

\noindent
注意到 $F a$ 和 $G a$ 是 $\cat{D}$ 范畴中的对象。范畴中对象之间的映射不应违反范畴的规则。我们不想在对象之间制造人为的连接，因此使用现有的连接，即态射，是“自然的”。自然变换是态射的选择：对于每个对象 $a$，它选择一个从 $F a$ 到 $G a$ 的态射。如果我们称自然变换为 $\alpha$，那么这个态射就是 $\alpha$ 在 $a$ 处的分量（component），即 $\alpha_a$。

\[\alpha_a \Colon F a \to G a\]
请记住，$a$ 是 $\cat{C}$ 中的一个对象，而 $\alpha_a$ 是 $\cat{D}$ 中的一个态射。

如果在某些 $a$ 上，$F a$ 和 $G a$ 之间在 $\cat{D}$ 中没有态射，那么 $F$ 和 $G$ 之间就没有自然变换。

当然，这只是故事的一半，因为函子不仅映射对象，它们也映射态射。那么，自然变换对这些映射做了什么？事实证明，在 $F$ 和 $G$ 之间的自然变换下，$F f$ 必须被转化为 $G f$。此外，两个函子对态射的映射极大地限制了定义与之兼容的自然变换的选择。考虑在 $\cat{C}$ 中两个对象 $a$ 和 $b$ 之间的态射 $f$。它被映射为在 $\cat{D}$ 中的两个态射：$F f$ 和 $G f$：

\begin{gather*}
  F f \Colon F a \to F b \\
  G f \Colon G a \to G b
\end{gather*}
自然变换 $\alpha$ 提供了两个额外的态射，它们完成了 $\cat{D}$ 中的图：

\begin{gather*}
  \alpha_a \Colon F a \to G a \\
  \alpha_b \Colon F b \to G b
\end{gather*}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/3_naturality.jpg}
\end{figure}

\noindent
现在我们有两种从 $F a$ 到 $G b$ 的路径。为了确保它们相等，我们必须施加一个对于任何 $f$ 都成立的 \newterm{自然性条件}：

\[G f \circ \alpha_a = \alpha_b \circ F f\]
自然性条件是一个相当严格的要求。例如，如果态射 $F f$ 是可逆的，那么自然性就决定了 $\alpha_b$ 依赖于 $\alpha_a$。它\emph{传送}了 $\alpha_a$ 沿着 $f$ 的变化：

\[\alpha_b = (G f) \circ \alpha_a \circ (F f)^{-1}\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/4_transport.jpg}
\end{figure}

\noindent
如果在两个对象之间有多于一个可逆的态射，那么所有这些传送都必须一致。然而，一般情况下，态射是不可逆的；但你可以看到，两函子之间存在自然变换的可能性远非保证。因此，函子之间由自然变换连接的稀缺性或丰富性可以告诉你关于它们所操作的范畴结构的许多信息。在讨论极限（limits）和 Yoneda 引理时，我们将看到一些例子。

从分量的角度来看待自然变换，或许可以说它将对象映射为态射。由于自然性条件的存在，你也可以说它将态射映射为交换方块——在 $\cat{D}$ 中每个 $\cat{C}$ 中的态射都有一个交换的自然性方块。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/naturality.jpg}
\end{figure}

\noindent
自然变换的这种特性在许多范畴论的构造中非常有用，这些构造通常包含交换图。通过慎重选择函子，许多这些交换条件可以被转化为自然性条件。当我们涉及极限、余极限（colimits）和伴随（adjunctions）时，我们将看到一些例子。

最后，自然变换可以用来定义函子的同构。说两个函子是自然同构的几乎等同于说它们是相同的。 \newterm{自然同构} 被定义为所有分量都是同构（可逆态射）的自然变换。

\section{多态函数}

我们讨论了函子（更具体地说是自函子）在编程中的作用。它们对应于将类型映射到类型的类型构造器。它们还将函数映射到函数，这种映射是通过高阶函数 \code{fmap}（或在 C++ 中的 \code{transform}、\code{then} 等）来实现的。

要构造一个自然变换，我们从一个对象开始，这里是一个类型 \code{a}。一个函子 \code{F} 将它映射到类型 $F a$。另一个函子 \code{G} 将它映射到 $G a$。自然变换 \code{alpha} 在 \code{a} 处的分量是一个从 $F a$ 到 $G a$ 的函数。在伪 Haskell 中：

\begin{snipv}
  alpha\textsubscript{a} :: F a -> G a
\end{snipv}
自然变换是一个对所有类型 \code{a} 都定义的多态函数：

\src{snippet01}
在 Haskell 中，\code{forall a} 是可选的（实际上需要开启语言扩展 \code{ExplicitForAll}）。通常，你会这样写：

\src{snippet02}
请记住，它实际上是一个以 \code{a} 为参数的函数族。这是 Haskell 语法简洁性的另一个例子。在 C++ 中，一个类似的结构会稍微冗长一些：

\begin{snip}{cpp}
  template<class A> G<A> alpha(F<A>);
\end{snip}
在 Haskell 的多态函数和 C++ 的泛型函数之间有一个更深刻的区别，这反映在这些函数的实现和类型检查方式上。在 Haskell 中，一个多态函数必须统一地为所有类型定义。一个公式必须适用于所有类型。这被称为 \newterm{参数多态性}。

而在 C++ 中，默认支持的是 \newterm{特定多态性}，这意味着模板不必对所有类型都是良定义的。模板是否对给定类型起作用是在实例化时决定的，在此过程中，具体类型被替换为类型参数。类型检查被延迟，这不幸的是，通常导致难以理解的错误消息。

在 C++ 中，还有一个函数重载和模板特化的机制，允许为不同的类型定义相同函数的不同定义。在 Haskell 中，这种功能由类型类和类型族提供。

Haskell 的参数多态性有一个意想不到的后果：任何类型为

\src{snippet03}
的多态函数，其中 \code{F} 和 \code{G} 是函子，自动满足自然性条件。这里是范畴符号中的表示（$f$ 是一个函数 $f \Colon a \to b$）：

\[G f \circ \alpha_a = \alpha_b \circ F f\]
在 Haskell 中，函子 \code{G} 对态射 \code{f} 的作用是通过 \code{fmap} 实现的。我首先会在伪 Haskell 中写出来，带有明确的类型注释：

\begin{snipv}
  fmap\textsubscript{G} f . alpha\textsubscript{a} = alpha\textsubscript{b} . fmap\textsubscript{F} f
\end{snipv}
由于类型推断，这些注释是不必要的，下面的等式成立：

\begin{snip}{text}
  fmap f . alpha = alpha . fmap f
\end{snip}
这仍然不是真正的 Haskell——函数相等性在代码中是无法表达的——但它是程序员在方程推理中可以使用的等式；或者由编译器使用来实现优化。

自然性条件在 Haskell 中是自动满足的，原因在于“免费的定理”。参数多态性，在 Haskell 中用于定义自然变换，对实现施加了非常强的限制——所有类型只有一个公式。这些限制转换为关于此类函数的方程定理。在变换函子的函数的情况下，免费的定理就是自然性条件。\footnote{
  你可以在我的博客 \href{https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/}{``Parametricity:
  Money for Nothing and Theorems for Free}.'' 中阅读更多关于免费的定理的内容。}

我之前提到过，将 Haskell 中的函子看作是广义容器的一种方法。我们可以继续这个类比，将自然变换看作是将一个容器的内容重新打包到另一个容器的配方。我们不触碰项目本身：我们不修改它们，也不创建新的项目。我们只是将它们（有时多次）复制到一个新容器中。

自然性条件变成了这样一种陈述：无论我们是先通过应用 \code{fmap} 修改项目，后重新打包；还是先重新打包，然后在新容器中修改项目，通过其自己的 \code{fmap} 实现，这两种行为是正交的。“一个移动鸡蛋，另一个煮它们。”

让我们来看一些 Haskell 中自然变换的例子。第一个例子是列表函子和 \code{Maybe} 函子之间的自然变换。它返回列表的头部，但前提是列表非空：

\src{snippet04}
这是一个在 \code{a} 上多态的函数。它对任何类型 \code{a} 都有效，没有限制，因此它是参数多态的一个例子。因此，它是两个函子之间的自然变换。但为了让我们信服，让我们验证自然性条件。

\src{snippet05}
我们有两种情况需要考虑：一个空列表：

\src{snippet06}

\src{snippet07}
和一个非空列表：

\src{snippet08}

\src{snippet09}
我使用了列表的 \code{fmap} 实现：

\src{snippet10}
和 \code{Maybe} 的：

\src{snippet11}
一个有趣的情况是，当其中一个函子是平凡的 \code{Const} 函子时。从或到 \code{Const} 函子的自然变换看起来就像是一个在返回类型或参数类型上多态的函数。

例如，\code{length} 可以被视为从列表函子到 \code{Const Int} 函子的自然变换：

\src{snippet12}
这里使用 \code{unConst} 来剥离 \code{Const} 构造器：

\src{snippet13}
当然，实际上 \code{length} 是这样定义的：

\src{snippet14}
它有效地隐藏了它是自然变换的事实。

找到一个从 \code{Const} 函子 \emph{来的}参数多态函数有点困难，因为它需要从无到有地创建一个值。我们能做的最好的是：

\src{snippet15}
另一个我们已经见过的常见函子，并将在 Yoneda 引理中发挥重要作用的，是 \code{Reader} 函子。我将重新将其定义为 \code{newtype}：

\src{snippet16}
它被两个类型参数化，但只在第二个类型上是（协变）函子化的：

\src{snippet17}
对于每个类型 \code{e}，你可以定义从 \code{Reader e} 到任何其他函子 \code{f} 的自然变换族。稍后我们会看到，这个族的成员总是与 \code{f e} 的元素一一对应（\hyperref[the-yoneda-lemma]{Yoneda 引理}）。

例如，考虑有一个带有一个元素 \code{()} 的稍显平凡的单位类型 \code{()}。函子 \code{Reader ()} 将任何类型 \code{a} 映射为函数类型 \code{() -> a}。这些只是从集合 \code{a} 中选择单个元素的所有函数。它们与 \code{a} 中的元素一样多。现在我们来考虑从这个函子到 \code{Maybe} 函子的自然变换：

\src{snippet18}
只有两个：\code{dumb} 和 \code{obvious}：

\src{snippet19}
和

\src{snippet20}
（你唯一能对 \code{g} 做的就是将它应用到单位值 \code{()} 上。）

而且，正如 Yoneda 引理所预测的那样，它们对应于 \code{Maybe ()} 类型的两个元素，即 \code{Nothing} 和 \code{Just ()}。我们稍后会回到 Yoneda 引理——这只是一个小小的预告。

\section{超越自然性}

在两个函子之间的参数多态函数（包括 \code{Const} 函子的边界情况）总是一个自然变换。由于所有标准的代数数据类型都是函子，任何这类类型之间的多态函数都是自然变换。

我们还可以使用函数类型，而函数类型在其返回类型上是函子化的。我们可以使用它们来构建函子，并定义高阶函数形式的自然变换。

然而，函数类型在其参数类型上不是协变的。它们是\newterm{逆变的}。当然，逆变函子等价于从对偶范畴到 Haskell 类型的协变函子。两个逆变函子之间的多态函数在范畴意义上仍然是自然变换，只是它们在 Haskell 类型的对偶范畴中工作。

你可能还记得我们之前看过的一个逆变函子的例子：

\src{snippet21}
这个函子在 \code{a} 上是逆变的：

\src{snippet22}
我们可以编写一个从 \code{Op Bool} 到 \code{Op String} 的多态函数：

\src{snippet23}
但由于这两个函子不是协变的，这不是一个 $\Hask$ 中的自然变换。然而，由于它们都是逆变的，它们满足“相反”的自然性条件：

\src{snippet24}[b]
注意到函数 \code{f} 必须朝与使用 \code{fmap} 相反的方向，因为 \code{contramap} 的签名是：

\src{snippet25}
是否有不是函子的类型构造器，无论是协变的还是逆变的？这里有一个例子：

\src{snippet26}
这不是一个函子，因为相同的类型 \code{a} 同时用于负面（逆变）和正面（协变）的位置。你不能为这个类型实现 \code{fmap} 或 \code{contramap}。因此，签名为

\src{snippet27}
的函数，其中 \code{f} 是一个任意的函子，不能是自然变换。有趣的是，有一种自然变换的推广，称为双自然变换（dinatural transformations），可以处理这些情况。当我们讨论端（ends）时，我们会涉及到它们。

\section{函子范畴}

现在我们有了函子之间的映射——自然变换——自然会问函子是否构成了一个范畴。确实如此！对于每一对范畴 $\cat{C}$ 和 $\cat{D}$，都有一个函子的范畴。在这个范畴中的对象是从 $\cat{C}$ 到 $\cat{D}$ 的函子，态射是这些函子之间的自然变换。

我们必须定义两个自然变换的复合，但这相当容易。自然变换的分量是态射，我们知道如何复合态射。

确实，让我们考虑一个从函子 $F$ 到 $G$ 的自然变换 $\alpha$。它在对象 $a$ 处的分量是某个态射：
\[\alpha_a \Colon F a \to G a\]
我们想将 $\alpha$ 与 $\beta$ 复合，$\beta$ 是从函子 $G$ 到 $H$ 的自然变换。$\beta$ 在 $a$ 处的分量是一个态射：
\[\beta_a \Colon G a \to H a\]
这些态射是可复合的，它们的复合是另一个态射：
\[\beta_a \circ \alpha_a \Colon F a \to H a\]
我们将使用这个态射作为自然变换 $\beta \cdot \alpha$ 的分量——两个自然变换 $\beta$ 在 $\alpha$ 后的复合：
\[(\beta \cdot \alpha)_a = \beta_a \circ \alpha_a\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/5_vertical.jpg}
\end{figure}

\noindent
通过观察图，我们可以确定这个复合的结果确实是从 $F$ 到 $H$ 的自然变换：
\[H f \circ (\beta \cdot \alpha)_a = (\beta \cdot \alpha)_b \circ F f\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/6_verticalnaturality.jpg}
\end{figure}

\noindent
自然变换的复合是结合的，因为它们的分量是关于态射复合的结合态射。

最后，对于每个函子 $F$，都有一个恒等自然变换 $1_F$，其分量是恒等态射：
\[\id_{F a} \Colon F a \to F a\]
因此，函子确实构成了一个范畴。

关于符号的说明。遵循 Saunders Mac Lane 的做法，我使用圆点来表示我刚才描述的自然变换的复合。问题是自然变换有两种复合方式。这种被称为纵向复合，因为函子通常在描述它们的图中垂直堆叠。纵向复合在定义函子范畴时很重要。我会很快解释横向复合。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/6a_vertical.jpg}
\end{figure}

\noindent
范畴 $\cat{C}$ 和 $\cat{D}$ 之间的函子范畴被写作 $\cat{Fun(C, D)}$，或 $\cat{{[}C, D{]}}$，或者有时写作 $\cat{D^C}$。最后一种符号表明函子范畴本身可能被视为某个其他范畴中的函数对象（指数）。这确实是这样吗？

让我们看看我们迄今为止构建的抽象层次。我们从范畴开始，这是对象和态射的集合。范畴本身（或严格来说，小范畴，其对象构成集合）本身就是更高级范畴 $\Cat$ 中的对象。该范畴中的态射是函子。$\Cat$ 中的一个同态集是一个函子的集合。例如，$\cat{Cat(C, D)}$ 是两个范畴 $\cat{C}$ 和 $\cat{D}$ 之间的函子的集合。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/7_cathomset.jpg}
\end{figure}

\noindent
函子范畴 $\cat{{[}C, D{]}}$ 也是两个范畴之间的函子的集合（加上自然变换作为态射）。它的对象与 $\cat{Cat(C, D)}$ 的成员相同。此外，函子范畴作为一个范畴，必须本身是 $\Cat$ 的对象（碰巧两个小范畴之间的函子范畴本身也是小的）。我们在一个范畴中的同态集与同一个范畴中的一个对象之间有关系。情况正如我们在上一节中看到的指数对象。让我们看看如何在 $\Cat$ 中构造后者。

你可能还记得，为了构造一个指数，我们需要首先定义一个积。在 $\Cat$ 中，这相对容易，因为小范畴是对象的\emph{集合}，我们知道如何定义集合的笛卡尔积。因此，积范畴 $\cat{C\times D}$ 中的一个对象只是一对对象 $(c, d)$，一个来自 $\cat{C}$，一个来自 $\cat{D}$。类似地，两对 $(c, d)$ 和 $(c', d')$ 之间的态射是一对态射 $(f, g)$，其中 $f \Colon c \to c'$ 和 $g \Colon d \to d'$。这些态射对分量地复合，并且总有一个恒等对，它只是一对恒等态射。简而言之，$\Cat$ 是一个完全的笛卡尔闭范畴，其中对于任意一对范畴都有一个指数对象 $\cat{D^C}$。通过“对象”在 $\Cat$ 中，我的意思是一个范畴，所以 $\cat{D^C}$ 是一个范畴，我们可以将其识别为 $\cat{C}$ 和 $\cat{D}$ 之间的函子范畴。

\section{2-范畴}

现在我们已经了解了 $\Cat$，让我们更详细地看看它。根据定义，$\Cat$ 中的任何同态集都是函子的集合。但是，正如我们所见，两个对象之间的函子具有比单纯的集合更丰富的结构。它们形成一个范畴，自然变换作为态射。由于函子在 $\Cat$ 中被认为是态射，自然变换就是态射之间的态射。

这种更丰富的结构是一个 $\cat{2}$-范畴的例子，它是范畴的推广，除了对象和态射（在此上下文中可能被称为 $1$-态射）之外，还有 $2$-态射，这是态射之间的态射。

在 $\Cat$ 作为一个 $\cat{2}$-范畴的情况下，我们有：

\begin{itemize}
  \tightlist
  \item
  对象：（小）范畴
  \item
  1-态射：范畴之间的函子
  \item
  2-态射：函子之间的自然变换。
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/8_cat-2-cat.jpg}
\end{figure}

\noindent
代替两个范畴 $\cat{C}$ 和 $\cat{D}$ 之间的同态集，我们有一个同态范畴——函子范畴 $\cat{D^C}$。我们有常规的函子复合：函子 $F$ 从 $\cat{D^C}$ 复合到一个函子 $G$ 从 $\cat{E^D}$ 给出 $G \circ F$ 从 $\cat{E^C}$。但我们也有每个同态范畴内部的复合——函子之间自然变换的纵向复合，或2-态射。

在一个 $\cat{2}$-范畴中有两种复合方式，问题是：它们如何相互作用？

让我们选择 $\Cat$ 中的两个函子，或 1-态射：
\begin{gather*}
  F \Colon \cat{C} \to \cat{D} \\
  G \Colon \cat{D} \to \cat{E}
\end{gather*}
及其复合：
\[G \circ F \Colon \cat{C} \to \cat{E}\]
假设我们有两个自然变换 $\alpha$ 和 $\beta$，它们分别作用于函子 $F$ 和 $G$：
\begin{gather*}
  \alpha \Colon F \to F' \\
  \beta \Colon G \to G'
\end{gather*}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/10_horizontal.jpg}
\end{figure}

\noindent
注意到我们不能将它们进行纵向复合，因为 $\alpha$ 的目标不同于 $\beta$ 的源。事实上，它们是两个不同函子范畴的成员：$\cat{D^C}$ 和 $\cat{E^D}$。然而，我们可以对函子 $F'$ 和 $G'$ 进行复合，因为 $F'$ 的目标是 $G'$ 的源——它是范畴 $\cat{D}$。$G' \circ F'$ 和 $G \circ F$ 之间有什么关系？

有了 $\alpha$ 和 $\beta$ 我们能定义一个从 $G \circ F$ 到 $G' \circ F'$ 的自然变换吗？让我简略描述一下构造。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/9_horizontal.jpg}
\end{figure}

\noindent
通常，我们从 $\cat{C}$ 中的一个对象 $a$ 开始。它的图像在 $\cat{D}$ 中分裂为两个对象：$F a$ 和 $F'a$。还有一个态射，自然变换 $\alpha$ 的分量，连接这两个对象：
\[\alpha_a \Colon F a \to F'a\]
当从 $\cat{D}$ 到 $\cat{E}$ 时，这两个对象进一步分裂为四个对象：$G (F a)$、$G'(F a)$、$G (F'a)$、$G'(F'a)$。我们还有四个态射构成一个方块。其中两个态射是自然变换 $\beta$ 的分量：
\begin{gather*}
  \beta_{F a} \Colon G (F a) \to G'(F a) \\
  \beta_{F'a} \Colon G (F'a) \to G'(F'a)
\end{gather*}
另外两个是两个函子的 $\alpha_a$ 的映像（函子映射态射）：
\begin{gather*}
  G \alpha_a \Colon G (F a) \to G (F'a) \\
  G'\alpha_a \Colon G'(F a) \to G'(F'a)
\end{gather*}
这些是很多态射。我们的目标是找到一个从 $G (F a)$ 到 $G'(F'a)$ 的态射，这可以作为连接两个函子 $G \circ F$ 和 $G' \circ F'$ 的自然变换的分量。事实上，这里有两条路径可以从 $G (F a)$ 到 $G'(F'a)$：
\begin{gather*}
  G'\alpha_a \circ \beta_{F a} \\
  \beta_{F'a} \circ G \alpha_a
\end{gather*}
幸运的是，它们是相等的，因为我们构造的方块是 $\beta$ 的自然性方块。

我们刚刚定义了一个从 $G \circ F$ 到 $G' \circ F'$ 的自然变换的分量。证明这个变换的自然性相当直接，只要你有足够的耐心。

我们称这个自然变换为 \newterm{横向复合} 的 $\alpha$ 和 $\beta$：
\[\beta \circ \alpha \Colon G \circ F \to G' \circ F'\]
同样，遵循 Mac Lane 的做法，我使用小圆圈表示横向复合，尽管你可能还会遇到用星号表示的。

这里有一个范畴论的经验法则：每当你有复合时，你应该寻找一个范畴。我们有自然变换的纵向复合，它是函子范畴的一部分。但横向复合呢？它属于哪个范畴？

解决这个问题的方法是横向看待 $\Cat$。不要将自然变换视为函子之间的箭头，而是作为范畴之间的箭头。自然变换位于两个范畴之间，它们由它所变换的函子连接。我们可以认为它连接了这两个范畴。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/sideways.jpg}
\end{figure}

\noindent
让我们关注 $\Cat$ 的两个对象——范畴 $\cat{C}$ 和 $\cat{D}$。存在一组自然变换，它们在连接 $\cat{C}$ 和 $\cat{D}$ 的函子之间。我们可以将这些自然变换视为从 $\cat{C}$ 到 $\cat{D}$ 的新箭头。同样地，也有自然变换连接从 $\cat{D}$ 到 $\cat{E}$ 的函子，我们可以将它们视为从 $\cat{D}$ 到 $\cat{E}$ 的新箭头。横向复合就是这些箭头的复合。

我们还可以有从 $\cat{C}$ 到 $\cat{C}$ 的恒等箭头。它是将 $\cat{C}$ 上的恒等函子映射到自身的恒等自然变换。注意到横向复合的恒等是纵向复合的恒等，但反之则不然。

最后，这两个复合满足交换律：
\[(\beta' \cdot \alpha') \circ (\beta \cdot \alpha) = (\beta' \circ \beta) \cdot (\alpha' \circ \alpha)\]
我会引用 Saunders Mac Lane 的话：读者可能会喜欢写出证明这个事实所需的明显图。

还有一个符号在将来可能会派上用场。在 $\Cat$ 的这个新横向解释中，有两种方式从对象到对象：使用函子或使用自然变换。然而，我们可以将函子箭头重新解释为一种特殊类型的自然变换：作用在这个函子上的恒等自然变换。因此，你经常会看到这种符号：
\[F \circ \alpha\]
其中 $F$ 是从 $\cat{D}$ 到 $\cat{E}$ 的函子，$\alpha$ 是从 $\cat{C}$ 到 $\cat{D}$ 的两个函子之间的自然变换。由于你不能将一个函子与自然变换复合，这被解释为在 $\alpha$ 后的恒等自然变换 $1_F$ 的横向复合。

类似地：
\[\alpha \circ F\]
是 $\alpha$ 后 $1_F$ 的横向复合。

\section{结论}

这就结束了本书的第一部分。我们学习了范畴论的基本词汇。你可以将对象和范畴视为名词；将态射、函子和自然变换视为动词。态射连接对象，函子连接范畴，自然变换连接函子。

但我们也看到了，表面上在一个抽象层次上的行为，在下一个层次上变成了对象。同态集变成了函数对象。作为一个对象，它可以是另一个态射的源或目标。这就是高阶函数背后的思想。

函子将对象映射到对象，因此我们可以将其用作类型构造器或参数化类型。函子还映射态射，因此它是一个高阶函数——\code{fmap}。有一些简单的函子，例如 \code{Const}、积和余积，它们可以用来生成各种代数数据类型。函数类型也是函子化的，既协变又逆变，可以用来扩展代数数据类型。

函子可以被视为函子范畴中的对象。作为这样的对象，它们成为态射的源和目标：自然变换。自然变换是一种特殊类型的多态函数。

\section{挑战}

\begin{enumerate}
  \tightlist
  \item
  定义一个从 \code{Maybe} 函子到列表函子的自然变换。证明其自然性条件。
  \item
  定义至少两个不同的自然变换在 \code{Reader ()} 和列表函子之间。有多少个不同的 \code{()} 列表？
  \item
  继续前面的练习，在 \code{Reader Bool} 和 \code{Maybe} 之间进行。
  \item
  证明自然变换的横向复合满足自然性条件（提示：使用分量）。这是一个很好的追图练习。
  \item
  写一篇关于你如何喜欢写出证明交换律所需的明显图的简短文章。
  \item
  为不同 \code{Op} 函子之间的变换创建一些测试用例，验证对立的自然性条件。这里有一个选择：

  \begin{snip}{haskell}
    op :: Op Bool Int
    op = Op (\x -> x > 0)
  \end{snip}
  和

  \begin{snip}{haskell}
    f :: String -> Int
    f x = read x
  \end{snip}
\end{enumerate}
