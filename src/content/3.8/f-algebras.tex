% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{我}{们已经看到了} monoid 的几种形式：作为一个集合，作为一个单对象范畴，作为 monoidal 范畴中的一个对象。我们还能从这个简单的概念中榨取出多少“果汁”呢？

让我们试试看。将 monoid 定义为一个集合 $m$ 以及一对函数：
\begin{align*}
  \mu  & \Colon m\times{}m \to m \\
  \eta & \Colon 1 \to m
\end{align*}
这里，1 是 $\Set$ 中的终对象——单元素集合。第一个函数定义了乘法（它接收一对元素并返回它们的乘积），第二个选择 $m$ 中的单位元。并不是所有具有这些签名的函数对都会产生一个 monoid。为此，我们需要施加附加条件：结合律和单位律。但让我们暂时忘记这些，只考虑“潜在的 monoid”。一对函数是两个函数集的笛卡尔积的元素。我们知道，这些集合可以表示为指数对象：
\begin{align*}
  \mu  & \in m^{m\times{}m} \\
  \eta & \in m^1
\end{align*}
这两个集合的笛卡尔积为：
\[m^{m\times{}m}\times{}m^1\]
利用一些高中代数（这在每个笛卡尔闭范畴中都适用），我们可以将其重写为：
\[m^{m\times{}m + 1}\]
加号表示 $\Set$ 中的余积。我们刚刚用一个函数代替了一对函数——即集合的一个元素：
\[m\times{}m + 1 \to m\]
这个函数集中的任何元素都是一个潜在的 monoid。

这种表述的美妙之处在于它引出了有趣的推广。例如，我们如何用这种语言描述群（group）呢？群是一个具有附加函数的 monoid，该函数为每个元素分配逆元。后者是类型 $m \to m$ 的函数。举个例子，整数构成了一个加法群，零是单位元，取反是逆元。为了定义一个群，我们将从一组三元函数开始：
\begin{align*}
  m\times{}m \to m \\
  m \to m          \\
  1 \to m
\end{align*}
和以前一样，我们可以将这些三元组合成一个函数集：
\[m\times{}m + m + 1 \to m\]
我们从一个二元运算符（加法）、一个一元运算符（取反）和一个零元运算符（单位元——这里是零）开始。我们将它们组合成一个函数。所有具有这个签名的函数都定义了潜在的群。

我们可以继续这样做。例如，要定义一个环（ring），我们可以添加另一个二元运算符和一个零元运算符，依此类推。每次我们都以一个函数类型结束，其左侧是幂的总和（可能包括零次幂——即终对象），而右侧是集合本身。

现在我们可以进行广泛的推广。首先，我们可以用对象替换集合，用态射替换函数。我们可以将 n 元运算符定义为从 n 元乘积出发的态射。这意味着我们需要一个支持有限积的范畴。对于零元运算符，我们要求终对象的存在。因此我们需要一个笛卡尔范畴。为了组合这些运算符，我们需要指数对象，所以这是一个笛卡尔闭范畴。最后，我们需要余积来完成我们的代数诡计。

或者，我们可以忘记我们推导公式的方式，专注于最终结果。态射左侧的乘积之和定义了一个端函子。如果我们选择一个任意的端函子 $F$，会发生什么呢？在这种情况下，我们不需要对我们的范畴施加任何约束。我们得到的就是所谓的 F-代数。

一个 F-代数是由一个端函子 $F$、一个对象 $a$ 以及一个态射组成的三元组
\[F a \to a\]
这个对象通常被称为载体（carrier）、基础对象或在编程上下文中称为载体类型。态射通常被称为求值函数或结构映射。可以将函子 $F$ 看作是形成表达式的结构，而态射则用于对它们求值。

以下是 Haskell 中对 F-代数的定义：

\src{snippet01}
它将代数与其求值函数等同。

在 monoid 示例中，所讨论的函子为：

\src{snippet02}
这在 Haskell 中表示 $1 + a\times{}a$（请记住 \hyperref[simple-algebraic-data-types]{代数数据结构}）。

一个环将使用以下函子定义：

\src{snippet03}
这在 Haskell 中表示 $1 + 1 + a\times{}a + a\times{}a + a$。

整数集是环的一个例子。我们可以选择 \code{Integer} 作为载体类型，并定义求值函数为：

\src{snippet04}
基于同一函子 \code{RingF}，还有更多的 F-代数。例如，多项式构成了一个环，方阵也是如此。

如你所见，函子的作用是生成可以使用代数求值器求值的表达式。到目前为止，我们只看到了非常简单的表达式。我们通常对可以使用递归定义的更复杂的表达式感兴趣。

\section{递归（Recursion）}

生成任意表达式树的一种方法是用递归替换函子定义中的变量 \code{a}。例如，一个环中的任意表达式由这个类树状的数据结构生成：

\src{snippet05}
我们可以将原始的环求值器替换为其递归版本：

\src{snippet06}
这仍然不太实用，因为我们被迫将所有整数表示为 1 的和，但在紧要关头可以使用。

但是，我们如何使用 F-代数的语言描述表达式树呢？我们必须以某种方式形式化替换我们的函子定义中自由类型变量的过程，递归地用替换结果填充这个类型变量。想象分步进行这个过程。首先，定义一个深度为 1 的树为：

\src{snippet07}
我们将 \code{RingF} 的定义中用 \code{RingF a} 生成的深度为 0 的树填入空缺中。类似地，深度为 2 的树也可以这样得到：

\src{snippet08}
我们还可以写成：

\src{snippet09}
继续这个过程，我们可以写出一个符号方程：

\begin{snipv}
  type RingF\textsubscript{n+1} a = RingF (RingF\textsubscript{n} a)
\end{snipv}
从概念上讲，在重复这个过程无穷次之后，我们最终得到 \code{Expr}。注意 \code{Expr} 不依赖于 \code{a}。我们旅程的起点无关紧要，最终总是到达同一个地方。这并不总是适用于任意范畴中的任意端函子，但在 $\Set$ 范畴中情况较好。

当然，这只是一个牵强的论点，我稍后会对其进行更严格的论证。

无限次地应用一个端函子生成一个不动点（fixed point），定义为：
\[\mathit{Fix}\ f = f\ (\mathit{Fix}\ f)\]
这个定义背后的直觉是，由于我们已经将 $f$ 应用无穷多次以得到 $\mathit{Fix}\ f$，再应用一次也不会改变任何东西。在 Haskell 中，不动点的定义为：

\src{snippet10}
可以说，如果构造器的名称与定义的类型不同，可能会更易读，如：

\src{snippet11}
但我会坚持使用公认的符号。构造器 \code{Fix}（或 \code{In}，如果你喜欢这样）可以看作是一个函数：

\src{snippet12}
还有一个函数可以剥去一个层次的函子应用：

\src{snippet13}
这两个函数是彼此的逆运算。我们稍后会用到这些函数。

\section{F-代数的范畴（Category of F-Algebras）}

这是书中最古老的技巧之一：每当你想出一种构建新对象的方法时，看看它们是否构成了一个范畴。不出所料，给定端函子 $F$ 的代数构成了一个范畴。该范畴中的对象是代数——由一个载体对象 $a$ 和一个态射 $F a \to a$ 组成的二元组，两者都来自原范畴 $\cat{C}$。

为了完成这个图景，我们必须定义 F-代数范畴中的态射。态射必须将一个代数 $(a, f)$ 映射到另一个代数 $(b, g)$。我们将其定义为一个态射 $m$，它映射载体——即从 $a$ 到 $b$ 在原范畴中的映射。并不是任何态射都可以做到：我们希望它与两个求值器兼容（我们称这种保持结构的态射为同态（homomorphism））。下面是 F-代数同态的定义。首先，注意我们可以将 $m$ 提升为映射：
\[F m \Colon F a \to F b\]
然后我们可以用 $g$ 来得到 $b$。或者，我们可以用 $f$ 从 $F a$ 到 $a$，然后跟随它使用 $m$。我们希望这两条路径相等：
\[g \circ F m = m \circ f\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/alg.png}
\end{figure}

\noindent
你很容易说服自己这确实是一个范畴（提示：$\cat{C}$ 中的恒等态射工作得很好，且同态的组合仍是同态）。

F-代数范畴中的初始对象（如果存在）称为初始代数（initial algebra）。我们称这个初始代数的载体为 $i$，其求值器为 $j \Colon F i \to i$。事实证明，初始代数的求值器 $j$ 是一个同构（isomorphism）。这一结果称为 Lambek 定理。证明依赖于初始对象的定义，它要求存在唯一的同态 $m$ 从它映射到任何其他 F-代数。因为 $m$ 是同态，下面的图必须交换：

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/alg2.png}
\end{figure}

\noindent
现在让我们构造一个载体为 $F i$ 的代数。此类代数的求值器必须是从 $F (F i)$ 到 $F i$ 的态射。我们可以通过提升 $j$ 来轻松构造这样的求值器：
\[F j \Colon F (F i) \to F i\]
由于 $(i, j)$ 是初始代数，必须存在一个唯一的同态 $m$ 从它映射到 $(F i, F j)$。以下图必须交换：

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/alg3a.png}
\end{figure}

\noindent
但我们还有这个可交换的图（两条路径是相同的！）：

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/alg3.png}
\end{figure}

\noindent
这可以解释为 $j$ 是一个将 $(F i, F j)$ 映射到 $(i, j)$ 的代数同态。我们可以将这两个图拼接在一起：

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{images/alg4.png}
\end{figure}

\noindent
这个图可以解释为 $j \circ m$ 是代数同态。在这种情况下，这两个代数是相同的。此外，因为 $(i, j)$ 是初始对象，只能存在一个从它映射到自身的同态，那就是恒等态射 $\id_i$——我们知道这是代数同态。因此 $j \circ m = \id_i$。利用这个事实和左侧图的可交换性质，我们可以证明 $m \circ j = \id_{Fi}$。这表明 $m$ 是 $j$ 的逆运算，因此 $j$ 是 $F i$ 和 $i$ 之间的同构：
\[F i \cong i\]
这仅仅表明 $i$ 是 $F$ 的一个不动点（fixed point）。这是对原先牵强论点的正式证明。

回到 Haskell：我们将 $i$ 识别为我们的 \code{Fix f}，将 $j$ 识别为我们的构造器 \code{Fix}，将其逆运算识别为 \code{unFix}。Lambek 定理中的同构告诉我们，为了得到初始代数，我们取函子 $f$ 并用 \code{Fix f} 替换其参数 $a$。我们还看到了为什么不动点不依赖于 $a$。

\section{自然数（Natural Numbers）}

自然数也可以定义为一个 F-代数。起点是两个态射的对：
\begin{align*}
  zero & \Colon 1 \to N \\
  succ & \Colon N \to N
\end{align*}
第一个选择零，第二个将所有数字映射到其后继数。和以前一样，我们可以将两者组合成一个：
\[1 + N \to N\]
左侧定义了一个函子，在 Haskell 中可以写成这样：

\src{snippet14}
这个函子的固定点（即它生成的初始代数）可以在 Haskell 中编码为：

\src{snippet15}
自然数要么是零，要么是另一个数字的后继数。这就是所谓的 Peano 表示法。

\section{Catamorphisms}

让我们使用 Haskell 符号重写初始性条件。我们将初始代数称为 \code{Fix f}。它的求值器是构造器 \code{Fix}。从初始代数到任何其他代数的唯一态射是 \code{m}。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/alg5.png}
\end{figure}

\noindent
顺便说一句，注意 \code{m} 是什么：它是整个递归表达式树的求值器。让我们找到一种实现它的通用方法。

Lambek 定理告诉我们，构造器 \code{Fix} 是同构。我们称其逆运算为 \code{unFix}。因此，我们可以翻转这个图中的一条箭头得到：

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/alg6.png}
\end{figure}

\noindent
让我们写下这个图的可交换性条件：

\begin{snip}{haskell}
  m = alg . fmap m . unFix
\end{snip}
我们可以将这个方程解释为 \code{m} 的递归定义。对于由函子 \code{f} 创建的任何有限树，这个递归必然会终止。我们可以通过注意到 \code{fmap m} 在函子 \code{f} 的顶层之下操作来看到这一点。换句话说，它作用于原始树的子节点。子节点总是比原始树浅一层。

当我们将 \code{m} 应用于用 \code{Fix\ f} 构造的树时会发生什么。操作 \code{unFix} 剥去了构造器，暴露了树的顶层。然后我们将 \code{m} 应用于顶节点的所有子节点。这会产生类型为 \code{a} 的结果。最后，我们通过应用非递归求值器 \code{alg} 来组合这些结果。关键点是我们的求值器 \code{alg} 是一个简单的非递归函数。

既然我们可以对任何代数 \code{alg} 执行此操作，那么定义一个高阶函数是有意义的，该函数以代数为参数并为我们提供我们称之为 \code{m} 的函数。这个高阶函数称为 catamorphism：

\src{snippet16}
让我们看看一个例子。采用定义自然数的函子：

\src{snippet17}
让我们选择 \code{(Int, Int)} 作为载体类型，并定义我们的代数为：

\src{snippet18}
你很容易说服自己，这个代数的 catamorphism，\code{cata fib}，计算斐波那契数。

一般来说，\code{NatF} 的代数定义了递推关系：当前元素的值以之前的元素为依据。然后，catamorphism 计算该序列的第 n 个元素。

\section{折叠（Folds）}

\code{e} 的列表是以下函子的初始代数：

\src{snippet19}
实际上，将变量 \code{a} 替换为递归的结果，我们称之为 \code{List e}，我们得到：

\src{snippet20}
列表函子的代数为一个特定的载体类型选择定义一个函数，该函数对两个构造器进行模式匹配。它对 \code{NilF} 的值告诉我们如何计算空列表，对 \code{ConsF} 的值告诉我们如何将当前元素与先前累积的值组合。

例如，下面是一个可以用于计算列表长度的代数（载体类型为 \code{Int}）：

\src{snippet21}
实际上，catamorphism \code{cata lenAlg} 计算列表的长度。请注意，求值器是（1）一个接受列表元素和累加器并返回新累加器的函数与（2）一个起始值，这里为零的组合。值的类型和累加器的类型由载体类型给出。

将其与传统的 Haskell 定义进行比较：

\src{snippet22}
\code{foldr} 的两个参数正好是代数的两个组成部分。

让我们尝试另一个例子：

\src{snippet23}
再次比较：

\src{snippet24}
正如你所见，\code{foldr} 只是一个对列表的 catamorphism 的便利特化。

\section{F-Coalgebras}

一如既往，我们有一个 F-余代数（F-coalgebra）的对偶构造，其中态射的方向是相反的：
\[a \to F a\]
给定函子的余代数也构成一个范畴，具有保持余代数结构的同态。该范畴中的终端对象 $(t, u)$ 称为终端余代数。对于每个其他代数 $(a, f)$，存在唯一的同态 $m$ 使以下图交换：

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/alg7.png}
\end{figure}

\noindent
终端余代数是函子的一个不动点，因为态射 $u \Colon t \to F t$ 是一个同构（Lambek 的余代数定理）：
\[F t \cong t\]
终端余代数通常在编程中解释为生成（可能是无限的）数据结构或转移系统的配方。

就像 catamorphism 可以用于求值初始代数一样，anamorphism 可以用于余求值终端余代数：

\src{snippet25}
余代数的一个典型例子基于一个固定点为元素类型 \code{e} 的无限流（stream）的函子。这个函子为：

\src{snippet26}
其固定点为：

\src{snippet27}
\code{StreamF e} 的余代数是一个函数，它接收类型为 \code{a} 的种子并生成一个对（\code{StreamF} 是对的别名），包括一个元素和下一个种子。

你可以轻松生成简单的余代数来产生无限序列，例如平方数列表或倒数。

一个更有趣的例子是一个余代数，它产生一个素数列表。技巧是使用无限列表作为载体。我们的起始种子将是列表 \code{{[}2..{]}}。下一个种子将是此列表的尾部，所有 2 的倍数都被移除。这是以 3 开始的奇数列表。在下一步中，我们将取此列表的尾部并移除所有 3 的倍数，依此类推。你可能认出这是埃拉托色尼筛法的雏形。这个余代数由以下函数实现：

\src{snippet28}
这个余代数的 anamorphism 生成素数列表：

\src{snippet29}
流是无限列表，因此应该可以将其转换为 Haskell 列表。为此，我们可以使用相同的函子 \code{StreamF} 形成一个代数，并可以在其上运行一个 catamorphism。例如，这是一个将流转换为列表的 catamorphism：

\src{snippet30}
在这里，同一个不动点同时是同一端函子的初始代数和终端余代数。在任意范畴中情况并非总是如此。通常，端函子可能有很多（或没有）不动点。初始代数是所谓的最小不动点，终端余代数是最大的固定点。然而，在 Haskell 中，两者由相同的公式定义，并且它们重合。

列表的 anamorphism 称为 unfold。为了创建有限列表，该函子被修改为生成一个 \code{Maybe} 对：

\src{snippet31}
\code{Nothing} 的值将终止列表的生成。

与镜头（lens）相关的余代数是一个有趣的例子。镜头可以表示为一个 getter 和 setter 的对：

\src{snippet32}
这里，\code{a} 通常是某种具有类型为 \code{s} 的字段的产品数据类型。getter 获取该字段的值，setter 用一个新值替换此字段。这两个函数可以组合成一个：

\src{snippet33}
我们可以进一步重写此函数为：

\src{snippet34}
其中我们定义了一个函子：

\src{snippet35}
请注意，这不是由乘积和余积构造的简单代数函子。它涉及一个指数 $a^s$。

镜头是这个函子的余代数，载体类型为 \code{a}。我们之前看到过 \code{Store s} 也是一个余单子（comonad）。事实证明，一个良好行为的镜头对应于一个与余单子结构兼容的余代数。在下一节中，我们将讨论这一点。

\section{挑战（Challenges）}

\begin{enumerate}
  \tightlist
  \item
  实现一个单变量多项式环的求值函数。你可以将多项式表示为一个系数列表，其前面是 $x$ 的幂。例如，$4x^2-1$ 可以表示为（从零次幂开始）\code{{[}-1, 0, 4{]}}。
  \item
  将前面的构造推广到多变量多项式，如 $x^2y-3y^3z$。
  \item
  实现 $2\times{}2$ 矩阵环的代数。
  \item
  定义一个余代数，其 anamorphism 生成自然数的平方列表。
  \item
  使用 \code{unfoldr} 生成前 $n$ 个素数的列表。
\end{enumerate}
