% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{你}{可以通过学习各种例子来真正理解范畴}。范畴有各种形状和大小，常常出现在意想不到的地方。我们将从一些非常简单的例子开始。

\section{没有对象 (No Objects)}

最简单的范畴是没有对象的范畴，因此也没有态射（morphisms）。它本身是一个非常无趣的范畴，但在其他范畴的上下文中可能很重要，例如，在所有范畴的范畴中（是的，确实有这样的一个范畴）。如果你认为空集有意义，那么为什么空范畴没有意义呢？

\section{简单图 (Simple Graphs)}

你可以通过用箭头连接对象来构建范畴。你可以想象从任何有向图开始，通过简单地添加更多箭头使其成为一个范畴。首先，在每个节点添加一个恒等箭头。然后，对于任何两个箭头，如果一个箭头的终点与另一个箭头的起点重合（换句话说，任何两个\newterm{可组合的}（composable）箭头），则添加一个新的箭头作为它们的组合。每次添加一个新箭头时，你还必须考虑它与任何其他箭头（除了恒等箭头）和它自身的组合。通常你最终会得到无穷多个箭头，但这没问题。

另一种看待这个过程的方法是，你正在创建一个范畴，它为图中的每个节点提供一个对象，并将所有可能的\newterm{链}（chains）——即可组合的图边——作为态射。（你甚至可以将恒等态射视为长度为零的特殊链。）

这样的范畴被称为由给定图生成的\newterm{自由范畴}（free category）。它是自由构造的一个例子，这一过程通过扩展最少数量的项来完成给定结构以满足其定律（在这里是范畴的定律）。我们将来会看到更多的例子。

\section{序 (Orders)}

现在来看一些完全不同的东西！在一个范畴中，态射是对象之间的一种关系：小于或等于的关系。让我们检查一下它是否确实是一个范畴。我们有恒等态射吗？每个对象都小于或等于自身：检查！我们有组合吗？如果 $a \leqslant b$ 且 $b \leqslant c$，那么 $a \leqslant c$：检查！组合是结合的吗？检查！具有这种关系的集合称为\newterm{预序}（preorder），所以预序确实是一个范畴。

你还可以有更强的关系，满足额外的条件，即如果 $a \leqslant b$ 且 $b \leqslant a$，那么 $a$ 必须与 $b$ 相同。这被称为\newterm{偏序}（partial order）。

最后，你可以施加一个条件，使得任何两个对象之间都存在某种关系，这就得到了\newterm{线性序}（linear order）或\newterm{全序}（total order）。

让我们将这些有序集描述为范畴。预序是一个范畴，其中从任意对象 $a$ 到任意对象 $b$ 的态射至多有一个。这种范畴的另一个名字是“薄”（thin）。预序是一个薄范畴。

范畴 $\cat{C}$ 中从对象 $a$ 到对象 $b$ 的态射集合被称为\newterm{态射集}（hom-set），记作 $\cat{C}(a, b)$（有时也写作 $\mathbf{Hom}_{\cat{C}}(a, b)$）。所以在预序中，所有的态射集要么为空，要么是单元素集。这包括预序中的态射集 $\cat{C}(a, a)$，即从 $a$ 到 $a$ 的态射集，它必须是单元素集，且仅包含恒等态射。然而，在预序中可能会有循环。在偏序中，循环是被禁止的。

能够识别预序、偏序和全序非常重要，因为排序算法，如快速排序（quicksort）、冒泡排序（bubble sort）、合并排序（merge sort）等，只有在全序上才能正确工作。偏序可以使用拓扑排序（topological sort）进行排序。

\section{作为集合的幺半群 (Monoid as Set)}

幺半群是一个令人难以置信的简单但惊人强大的概念。它是基本算术的背后概念：加法和乘法都形成幺半群。幺半群在编程中无处不在。它们以字符串、列表、可折叠的数据结构、并发编程中的期望值、函数响应式编程中的事件等形式出现。

传统上，幺半群被定义为一个带有二元运算的集合。这个运算所需的全部条件是它是结合的，并且存在一个特殊的元素在此运算下表现为单位元。

例如，带有零的自然数在加法下形成一个幺半群。结合性意味着：
\[(a + b) + c = a + (b + c)\]
（换句话说，我们可以在加法时忽略括号。）

中性元素是零，因为：
\[0 + a = a\]
并且
\[a + 0 = a\]
第二个方程式是多余的，因为加法是交换的 $(a + b = b + a)$，但交换性不是幺半群定义的一部分。例如，字符串连接不是交换的，但它仍然形成一个幺半群。顺便说一下，字符串连接的中性元素是空字符串，它可以附加在字符串的任一侧而不改变它。

在 Haskell 中，我们可以为幺半群定义一个类型类——一种有中性元素 \code{mempty} 和二元运算 \code{mappend} 的类型：

\src{snippet01}
这个二元函数的类型签名 \code{m -> m -> m} 乍一看可能有些奇怪，但在我们讨论柯里化（currying）之后，它将变得完全合理。你可以用两种基本方式解释带有多个箭头的类型签名：作为一个具有多个参数的函数，最右边的类型是返回类型；或者作为一个单参数函数（最左边的一个），返回一个函数。后者的解释可以通过添加括号来强调（虽然它们是多余的，因为箭头是右结合的），如：\code{m -> (m -> m)}。我们稍后会回到这种解释。

注意，在 Haskell 中，没有办法表达 \code{mempty} 和 \code{mappend} 的幺半群性质（即 \code{mempty} 是中性元素和 \code{mappend} 是结合的事实）。程序员有责任确保它们得到满足。

Haskell 类不像 C++ 类那么具侵入性。当你定义一个新类型时，你不必预先指定它的类。你可以自由地拖延，并在以后再声明给定类型是某个类的实例。例如，让我们通过提供 \code{mempty} 和 \code{mappend} 的实现来声明 \code{String} 是一个幺半群（实际上，这在标准 Prelude 中已经为你做了）：

\src{snippet02}
这里，我们重用了列表连接运算符 \code{(++)}，因为 \code{String} 只是一个字符列表。

关于 Haskell 语法的一点说明：任何中缀运算符都可以通过将其括在括号中变成一个二元函数。给定两个字符串，你可以通过在它们之间插入 \code{++} 来连接它们：

\begin{snip}{haskell}
  "Hello " ++ "world!"
\end{snip}
或通过将它们作为两个参数传递给括号中的 \code{(++)}：

\begin{snip}{haskell}
(++) "Hello " "world!"
\end{snip}
注意，函数的参数之间没有逗号，也没有被括号包围。（这可能是学习 Haskell 时最难适应的事情。）

值得强调的是，Haskell 允许你表达函数的相等性，如：

\begin{snip}{haskell}
  mappend = (++)
\end{snip}
从概念上讲，这与表达函数产生的值的相等性不同，如：

\begin{snip}{haskell}
  mappend s1 s2 = (++) s1 s2
\end{snip}
前者翻译成 $\Hask$（或忽略底的情况下的 $\Set$）范畴中的态射相等性。这种方程不仅更简洁，而且通常可以推广到其他范畴。后者称为\newterm{外延}（extensional）相等，表示对于任何两个输入字符串，\code{mappend} 和 \code{(++)} 的输出是相同的。由于参数的值有时被称为\newterm{点}（points）（如：$f$ 在点 $x$ 的值），这被称为逐点相等。未指定参数的函数相等被描述为\newterm{无点}（point-free）。（顺便提一下，无点方程通常涉及函数的组合，它用一个点符号表示，所以这对初学者来说可能有点混淆。）

在 C++ 中最接近声明一个幺半群的方法是使用 C++20 标准的 concept 特性。

\begin{snip}{cpp}
  template<class T>
  struct mempty;

  template<class T>
  T mappend(T, T) = delete;

  template<class M>
  concept Monoid = requires (M m) {
      { mempty<M>::value() } -> std::same_as<M>;
      { mappend(m, m) } -> std::same_as<M>;
  };
\end{snip}
第一个定义是一个结构，旨在为每个专门化类型保存中性元素。

关键字 \code{delete} 意味着没有定义默认值：它必须在具体情况下指定。同样，对于 \code{mappend} 也没有默认值。

concept \code{Monoid} 检查是否存在适当的 \code{mempty} 和 \code{mappend} 定义，用于给定的类型 \code{M}。

可以通过提供适当的专门化和重载来实例化 Monoid 概念：

\begin{snip}{cpp}
  template<>
  struct mempty<std::string> {
    static std::string value() { return ""; }
  };

  template<>
  std::string mappend(std::string s1, std::string s2) {
    return s1 + s2;
  }
\end{snip}

\section{作为范畴的幺半群 (Monoid as Category)}

那是关于幺半群的“熟悉”的定义，即集合的元素。但是，正如你所知，在范畴论中，我们试图摆脱集合及其元素，转而讨论对象和态射。所以让我们稍微改变一下视角，将二元运算的应用视为在集合中“移动”或“转移”事物。

例如，有一个将每个自然数加 5 的操作。它将 0 映射到 5，1 映射到 6，2 映射到 7，依此类推。这是一个定义在自然数集合上的函数。这很好：我们有一个函数和一个集合。一般来说，对于任意数 $n$，都有一个将 $n$ 加上的函数——$n$ 的“加法器”。

加法器如何组合？将加 5 的函数与加 7 的函数组合，结果是加 12 的函数。因此，加法器的组合可以与加法规则等同。这也很好：我们可以用函数组合替换加法。

但等等，还有更多：还有一个对应于中性元素的加法器，零。加零不会移动任何事物，所以它是自然数集合中的恒等函数。

我可以不告诉你传统的加法规则，而是给你加法器组合的规则，不会丢失任何信息。注意，加法器的组合是结合的，因为函数的组合是结合的；而且我们有零加法器对应于恒等函数。

一个聪明的读者可能已经注意到，从整数到加法器的映射源于 \code{mappend} 类型签名的第二种解释，即 \code{m -> (m -> m)}。它告诉我们 \code{mappend} 将一个幺半群集合的元素映射到作用于该集合的函数。

现在我希望你忘记你正在处理的是自然数集合，而只将其视为一个单一的对象，一个带有一堆态射的 blob——加法器。幺半群是一个单对象范畴。事实上，幺半群这个名字来源于希腊语 \emph{mono}，意思是单一的。每个幺半群都可以描述为一个单对象范畴，其中有一组符合组合规则的态射。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/monoid.jpg}
\end{figure}

\noindent
字符串连接是一个有趣的例子，因为我们可以选择定义右连接器和左连接器（或\emph{前置器}，如果你愿意的话）。两种模型的组合表是镜像反转的。你可以轻松地让自己相信在 “foo” 之后附加 “bar” 对应于在附加 “bar” 之后前置 “foo”。

你可能会问，是否每个范畴论上的幺半群——一个单对象范畴——都定义了一个唯一的带有二元运算符的集合幺半群。事实证明，我们总是可以从一个单对象范畴中提取一个集合。这个集合是态射的集合——在我们的例子中是加法器。换句话说，我们有单对象 $m$ 在范畴 $\cat{M}$ 中的态射集 $\cat{M}(m, m)$。我们可以很容易地在这个集合中定义一个二元运算符：两个集合元素的幺半群乘积是对应态射组合对应的元素。如果你给我两个对应于 $f$ 和 $g$ 的 $\cat{M}(m, m)$ 元素，它们的乘积将对应于组合 $f \circ g$。这个组合总是存在的，因为这些态射的源和目标是相同的对象。根据范畴的规则，它是结合的。恒等态射是这个乘积的中性元素。因此，我们总是可以从一个范畴幺半群中恢复一个集合幺半群。对于所有意图和目的来说，它们是相同的。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/monoidhomset.jpg}
  \caption{作为态射的幺半群态射集和作为集合中的点。}
\end{figure}

\noindent
数学家可以挑剔的唯一一点是：态射不一定要形成一个集合。在范畴世界中，有些东西比集合更大。在任意两个对象之间的态射形成集合的范畴称为局部小范畴（locally small）。正如承诺的那样，我将主要忽略这些细微差别，但我觉得我应该提到它们以备记录。

在范畴论中，许多有趣的现象都根源于这样的事实：态射集的元素既可以视为符合组合规则的态射，也可以视为集合中的点。在这里，$\cat{M}$ 中态射的组合转化为集合 $\cat{M}(m, m)$ 中的幺半群乘积。

\section{挑战 (Challenges)}

\begin{enumerate}
  \tightlist
  \item
  从以下内容生成一个自由范畴：

  \begin{enumerate}
    \tightlist
    \item
    一个只有一个节点且没有边的图
    \item
    一个有一个节点和一条（有向）边的图（提示：这条边可以与其自身组合）
    \item
    一个有两个节点和一个箭头的图
    \item
    一个有一个节点和 26 条以字母标记的箭头的图：a, b, c \ldots{} z.
  \end{enumerate}
  \item
  这种序是什么类型的？

  \begin{enumerate}
    \tightlist
    \item
    一个带有包含关系的集合的集合：如果 $A$ 的每个元素也是 $B$ 的元素，则 $A$ 包含于 $B$。
    \item
    C++ 类型及其以下子类型关系：如果可以将 \code{T1} 的指针传递给期望 \code{T2} 指针的函数而不触发编译错误，则 \code{T1} 是 \code{T2} 的子类型。
  \end{enumerate}
  \item
  考虑到 \code{Bool} 是一个包含 \code{True} 和 \code{False} 两个值的集合，证明它在运算符 \code{\&\&}（AND）和 \code{||}（OR）下分别形成了两个（集合论）幺半群。
  \item
  用 AND 运算符表示 \code{Bool} 幺半群作为一个范畴：列出态射及其组合规则。
  \item
  用一个幺半群范畴表示模 3 加法。
\end{enumerate}
