% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{我}{们已经看到了两种基本}的类型组合方式：乘积（product）和余积（coproduct）。事实证明，在日常编程中，很多数据结构可以仅通过这两种机制来构建。这一事实具有重要的实际意义。许多数据结构的属性是可组合的。例如，如果你知道如何比较基本类型的值是否相等，并且知道如何将这些比较推广到乘积类型和余积类型，你就可以自动推导复合类型的相等运算符。在 Haskell 中，你可以为大量的复合类型自动派生相等性、比较、字符串转换等操作。

让我们仔细看看编程中出现的乘积类型和和类型。

\section{乘积类型 (Product Types)}

在编程语言中，两个类型的乘积的典型实现是对（pair）。在 Haskell 中，对是一个原始类型构造器；在 C++ 中，它是一个相对复杂的标准库模板。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/pair.jpg}
\end{figure}

\noindent
对不完全是可交换的：\code{(Int, Bool)} 对不能替换为 \code{(Bool, Int)} 对，尽管它们携带相同的信息。然而，它们是同构（isomorphism）可交换的，所谓同构是指通过 \code{swap} 函数来实现的（该函数是其自身的逆）：

\src{snippet01}
你可以认为这两个对只是以不同的格式存储了相同的数据。这就像大端和小端之间的区别。

你可以通过在对中嵌套对来组合任意数量的类型，但有一个更简单的方法：嵌套的对等价于元组（tuples）。这是因为嵌套对的不同方式是同构的。如果你想按顺序组合三种类型 \code{a}、\code{b} 和 \code{c} 的乘积，你可以用两种方式来实现：

\src{snippet02}

或
\src{snippet03}
这些类型是不同的——你不能将一种类型传递给期望另一种类型的函数——但它们的元素是一一对应的。有一个函数可以将一种类型映射到另一种类型：

\src{snippet04}
这个函数是可逆的：

\src{snippet05}
所以它们是同构的。这些只是重新包装相同数据的不同方式。

你可以将创建乘积类型解释为类型上的二元运算。从这个角度来看，上述同构非常类似于我们在幺半群（monoid）中看到的结合律：
\[
  (a * b) * c = a * (b * c)
\]
不同的是，在幺半群的情况下，两个乘积的组合是相等的，而在这里它们只是“同构”的相等。

如果我们可以接受同构，而不坚持严格的相等，我们可以更进一步，证明单位类型 \code{()} 就像 1 是乘法的单位元一样，是乘积的单位元。实际上，将某个类型 \code{a} 的值与一个单位配对并不会增加任何信息。类型：

\src{snippet06}
是同构于 \code{a} 的。下面是这个同构：

\src{snippet07}

\src{snippet08}
这些观察可以形式化为：$\Set$（集合范畴）是一个\newterm{幺半群范畴}（monoidal category）。这是一种也是幺半群的范畴，意思是你可以对对象进行乘法（这里，取它们的笛卡尔积）。我将在未来详细讨论幺半群范畴，并给出完整的定义。

在 Haskell 中有一种更通用的方式来定义乘积类型，尤其是在它们与和类型结合使用时。它使用了带有多个参数的命名构造器。例如，一对可以定义为：

\src{snippet09}
在这里，\code{Pair a b} 是一个由两个其他类型 \code{a} 和 \code{b} 参数化的类型的名称；\code{P} 是数据构造器的名称。你可以通过向 \code{Pair} 类型构造器传递两个类型来定义一个对类型。你可以通过向构造器 \code{P} 传递两个适当类型的值来构造一个对值。例如，定义一个 \code{stmt} 值为 \code{String} 和 \code{Bool} 的对：

\src{snippet10}
第一行是类型声明。它使用类型构造器 \code{Pair}，其中 \code{String} 和 \code{Bool} 替代了 \code{a} 和泛型定义 \code{Pair} 中的 \code{b}。第二行通过将一个具体的字符串和一个具体的布尔值传递给数据构造器 \code{P} 来定义实际值。类型构造器用于构造类型；数据构造器用于构造值。

由于 Haskell 中类型构造器和数据构造器的命名空间是分开的，你会经常看到同样的名字用于这两个部分，如：

\src{snippet11}
如果你仔细观察，你甚至可以将内置的对类型视为这种声明的一种变体，其中 \code{Pair} 的名称被替换为二元运算符 \code{(,)}。实际上，你可以像其他命名构造器一样使用 \code{(,)} 并用前缀表示法创建对：

\src{snippet12}
类似地，你可以使用 \code{(,,)} 来创建三元组，等等。

除了使用泛型对或元组，你还可以定义特定的命名乘积类型，如：

\src{snippet13}
它只是 \code{String} 和 \code{Bool} 的乘积，但它被赋予了自己的名字和构造器。这种声明方式的优势在于，你可以定义许多具有相同内容但不同意义和功能的类型，并且它们不能相互替换。

用元组和多参数构造器进行编程可能会变得混乱且容易出错——你需要跟踪每个组件代表什么。通常，最好给组件命名。具有命名字段的乘积类型在 Haskell 中称为\newterm{记录}（record），在 C 中称为 \code{struct}。

\section{记录 (Records)}

让我们看看一个简单的例子。我们想通过组合两个字符串（名称和符号）和一个整数（原子序数）来描述化学元素。我们可以使用一个元组 \code{(String, String, Int)} 并记住每个组件代表什么。我们可以通过模式匹配来提取组件，例如这个检查元素符号是否是其名称前缀的函数（就像\textbf{氦}（He）是\textbf{氦气}（Helium）的前缀）：

\src{snippet14}
这段代码容易出错，难以阅读和维护。更好的方法是定义一个记录：

\src{snippet15}
这两种表示是同构的，这一点可以通过这两个相互逆转的转换函数来证明：

\src{snippet16}

\src{snippet17}
注意，记录字段的名称也充当了访问这些字段的函数。例如，\code{atomicNumber e} 从 \code{e} 中检索 \code{atomicNumber} 字段。我们将 \code{atomicNumber} 用作类型为：

\src{snippet18}
使用 \code{Element} 的记录语法后，我们的 \code{startsWithSymbol} 函数变得更加易读：

\src{snippet19}
我们甚至可以使用 Haskell 的技巧，通过将函数 \code{isPrefixOf} 用反引号包围将其转换为中缀运算符，并使其看起来几乎像一个句子：

\src{snippet20}
在这种情况下可以省略括号，因为中缀运算符的优先级低于函数调用。

\section{和类型 (Sum Types)}

正如集合范畴中的乘积产生了乘积类型，余积产生了和类型。Haskell 中和类型的典型实现是：

\src{snippet21}
像对一样，\code{Either} 是（同构的）可交换的，可以嵌套，并且嵌套顺序无关紧要（同构）。因此，我们可以定义一个三元和类型的等价物：

\src{snippet22}
等等。

事实证明，$\Set$ 也是一个关于余积的（对称的）幺半群范畴。二元运算的作用由不相交的和（disjoint sum）来扮演，单位元素的作用由初始对象来扮演。在类型方面，我们有 \code{Either} 作为幺半群运算符，\code{Void}，即无值类型，作为其中性元素。你可以将 \code{Either} 看作加法，将 \code{Void} 看作零。实际上，向和类型中添加 \code{Void} 并不会改变它的内容。例如：

\src{snippet23}
与 \code{a} 是同构的。这是因为没有办法构造此类型的 \code{Right} 版本——没有 \code{Void} 类型的值。\code{Either a Void} 的唯一元素是使用 \code{Left} 构造器构造的，它们只是封装了 \code{a} 类型的值。因此，象征性地，$a + 0 = a$。

和类型在 Haskell 中非常常见，但它们在 C++ 中的等价物，联合（union）或变体（variant），则要少得多。这有几个原因。

首先，最简单的和类型只是枚举，并且在 C++ 中使用 \code{enum} 实现。Haskell 和类型的等价物是：

\src{snippet24}
而 C++ 的实现是：

\begin{snip}{cpp}
  enum { Red, Green, Blue };
\end{snip}
一个更简单的和类型是：

\src{snippet25}
在 C++ 中的原始类型 \code{bool}。

编码值的存在或不存在的简单和类型通常在 C++ 中使用特殊技巧和“无效”值来实现，例如空字符串、负数、空指针等。这种可选性（optionality），如果是故意的，则在 Haskell 中使用 \code{Maybe} 类型表达：

\src{snippet26}
\code{Maybe} 类型是两个类型的和。你可以看到，如果将两个构造器分成单独的类型，第一个类型看起来像这样：

\src{snippet27}
它是一个只有一个值的枚举，称为 \code{Nothing}。换句话说，它是一个单例，与单位类型 \code{()} 等价。第二部分是：

\src{snippet28}
这只是 \code{a} 类型的封装。我们可以将 \code{Maybe} 编码为：

\src{snippet29}
在 C++ 中，复杂的和类型通常用指针伪装。指针可以是空的，或者指向特定类型的值。例如，一个 Haskell 列表类型，它可以定义为一个（递归的）和类型：

\src{snippet30}
可以翻译为 C++ 使用空指针技巧来实现空列表：

\begin{snip}{cpp}
  template<class A>
  class List {
    Node<A> * _head;
    public:
    List() : _head(nullptr) {} // Nil
    List(A a, List<A> l)       // Cons
    : _head(new Node<A>(a, l))
      {}
  };
\end{snip}
注意，两个 Haskell 构造器 \code{Nil} 和 \code{Cons} 被翻译为两个重载的 \code{List} 构造器，具有类似的参数（对于 \code{Nil}，没有；对于 \code{Cons}，是一个值和一个列表）。\code{List} 类不需要标签来区分和类型的两个组件。相反，它使用 \code{\_head} 的特殊值 \code{nullptr} 来编码 \code{Nil}。

然而，Haskell 和 C++ 类型之间的主要区别在于 Haskell 数据结构是不可变的。如果你使用一个特定的构造器创建了一个对象，该对象将永远记住使用了哪个构造器以及传递给它的参数。因此，创建为 \code{Just "energy"} 的 \code{Maybe} 对象永远不会变成 \code{Nothing}。同样，空列表将永远是空的，包含三个元素的列表将永远具有相同的三个元素。

正是这种不可变性使得构造可逆。给定一个对象，你可以始终将其分解为用于构造的部分。这种分解是通过模式匹配完成的，它重用了构造器作为模式。如果有的话，构造器参数会被变量（或其他模式）替换。

\code{List} 数据类型有两个构造器，因此对任意 \code{List} 的分解使用了两个对应于这些构造器的模式。例如，下面是一个关于 \code{List} 的简单函数的定义：

\src{snippet31}
\code{maybeTail} 的定义的第一部分使用 \code{Nil} 构造器作为模式并返回 \code{Nothing}。第二部分使用 \code{Cons} 构造器作为模式。它用通配符替换第一个构造器参数，因为我们对它不感兴趣。将 \code{Cons} 的第二个参数绑定到变量 \code{t}（尽管严格来说，变量永远不会变，因为一旦绑定到表达式，变量就永远不会改变，我还是会称这些东西为变量）。返回值是 \code{Just t}。现在，根据你的 \code{List} 是如何创建的，它将匹配其中一个子句。如果它是使用 \code{Cons} 创建的，那么传递给它的两个参数将被检索（第一个被丢弃）。

在 C++ 中，使用多态类层次结构实现的更复杂的和类型。一组具有共同祖先的类可以被理解为一个变体类型，其中 vtable 充当一个隐藏的标签。在 Haskell 中，通过对构造器进行模式匹配并调用专用代码来完成的事情，在 C++ 中通过基于 vtable 指针调用虚函数来实现。

你很少会看到 \code{union} 在 C++ 中作为和类型使用，因为对可以放入 union 中的内容有严格的限制。你甚至不能将 \code{std::string} 放入 union 中，因为它有一个复制构造函数。

\section{类型的代数 (Algebra of Types)}

分别来看，乘积和和类型可以用来定义各种有用的数据结构，但真正的力量来自于将两者结合使用。我们再次借助了组合的力量。

让我们总结一下到目前为止的发现。我们已经看到两个底层的可交换幺半群结构：我们有和类型，其中性元素为 \code{Void}；我们有乘积类型，其中性元素为单位类型 \code{()}。我们希望将它们类比为加法和乘法。在这个类比中，\code{Void} 对应于零，单位类型 \code{()} 对应于一。

让我们看看这个类比能延伸到多远。例如，乘以零是否等于零？换句话说，是否有一个组件为 \code{Void} 的乘积类型是同构于 \code{Void} 的？例如，是否有可能创建一个 \code{Int} 和 \code{Void} 的对？

要创建一个对，你需要两个值。尽管你可以轻松生成一个整数，但没有 \code{Void} 类型的值。因此，对于任何类型 \code{a}，类型 \code{(a, Void)} 是无效的——没有值——因此等价于 \code{Void}。换句话说，$a \times 0 = 0$。

另一个将加法和乘法联系在一起的东西是分配律：
\[a \times (b + c) = a \times b + a \times c\]
这个性质对于乘积类型和和类型是否成立？是的，它成立——和往常一样，最多是同构。左边对应的类型是：

\src{snippet32}
而右边对应的类型是：

\src{snippet33}
下面是将它们转换为一个方向的函数：

\src{snippet34}
而这是另一个方向的函数：

\src{snippet35}
\code{case of} 语句用于函数内部的模式匹配。每个模式后面跟随一个箭头和当模式匹配时要评估的表达式。例如，如果你用值调用 \code{prodToSum}：

\src{snippet36}
在 \code{case e of} 中的 \code{e} 将等于 \code{Left "Hi!"}。它将匹配模式 \code{Left y}，将 \code{"Hi!"} 替换为 \code{y}。由于 \code{x} 已经匹配到 \code{2}，因此 \code{case of} 子句的结果，以及整个函数的结果，将是 \code{Left (2, "Hi!")}, 如预期的那样。

我不打算证明这两个函数是彼此的逆，但如果你仔细考虑，它们必须是的！它们只是简单地重新打包了两个数据结构的内容。数据是相同的，只是格式不同。

数学家有一个术语来形容这样的交错幺半群：这叫做\newterm{半环}（semiring）。这不是一个完整的\newterm{环}（ring），因为我们不能定义类型的减法。这就是为什么半环有时被称为\newterm{rig}，这是一种双关语，表示“没有 \emph{n}（负数）的环”。但即使如此，我们仍然可以通过将关于自然数的陈述（它们形成一个 rig）转换为关于类型的陈述，来获得很多启示。以下是一些有趣条目的对照表：

\begin{longtable}[]{@{}ll@{}}
  \toprule
  数字      & 类型\tabularnewline
  \midrule
  \endhead
  $0$          & \code{Void}\tabularnewline
  $1$          & \code{()}\tabularnewline
  $a + b$      & \code{Either a b = Left a | Right b}\tabularnewline
  $a \times b$ & \code{(a, b)} or \code{Pair a b = Pair a b}\tabularnewline
  $2 = 1 + 1$  & \code{data Bool = True | False}\tabularnewline
  $1 + a$      & \code{data Maybe = Nothing | Just a}\tabularnewline
  \bottomrule
\end{longtable}

\noindent
列表类型非常有趣，因为它是方程的解。我们正在定义的类型出现在方程的两边：

\src{snippet37}
如果我们进行通常的替换，并且还用 \code{x} 替换 \code{List a}，我们会得到方程：

\begin{Verbatim}
  x = 1 + a * x
\end{Verbatim}
我们不能使用传统的代数方法来解决它，因为我们不能对类型进行减法或除法。但我们可以尝试一系列替换，不断用 \code{(1 + a*x)} 替换右边的 \code{x}，并使用分配律。这会导致以下系列：

\begin{Verbatim}
  x = 1 + a*x
  x = 1 + a*(1 + a*x) = 1 + a + a*a*x
  x = 1 + a + a*a*(1 + a*x) = 1 + a + a*a + a*a*a*x
  ...
  x = 1 + a + a*a + a*a*a + a*a*a*a...
\end{Verbatim}
我们最终得到一个无限的乘积和（元组），可以解释为：一个列表要么是空的，\code{1}；要么是单例，\code{a}；要么是一对，\code{a*a}；要么是三元组，\code{a*a*a}；等等……嗯，这正是列表的定义——一个由 \code{a} 组成的字符串！

关于列表还有更多的内容，我们将在学习函子（functors）和不动点（fixed points）之后回到列表和其他递归数据结构。

用符号变量求解方程——这就是代数！这就是给这些类型命名为代数数据类型的原因。

最后，我应该提到类型代数的一个非常重要的解释。注意，两个类型 \code{a} 和 \code{b} 的乘积必须同时包含 \code{a} 类型的值 \emph{和} \code{b} 类型的值，这意味着这两种类型都必须是可占有的（inhabited）。另一方面，两个类型的和包含了 \code{a} 类型的值 \emph{或} \code{b} 类型的值，所以只要其中一个是可占有的就足够了。逻辑的 \emph{and} 和 \emph{or} 也形成了一个半环，它也可以映射到类型理论中：

\begin{longtable}[]{@{}ll@{}}
  \toprule
  逻辑                & 类型\tabularnewline
  \midrule
  \endhead
  $\mathit{false}$     & \code{Void}\tabularnewline
  $\mathit{true}$      & \code{()}\tabularnewline
  $a \mathbin{||} b$   & \code{Either a b = Left a | Right b}\tabularnewline
  $a \mathbin{\&\&} b$ & \code{(a, b)}\tabularnewline
  \bottomrule
\end{longtable}

\noindent
这种类比更深入，是 Curry-Howard 同构（isomorphism）在逻辑与类型理论之间的基础。当我们讨论函数类型时，我们将再次讨论这个问题。

\section{挑战 (Challenges)}

\begin{enumerate}
  \tightlist
  \item
  展示 \code{Maybe a} 和 \code{Either () a} 之间的同构性。
  \item
  这里有一个在 Haskell 中定义的和类型：

  \begin{snip}{haskell}
    data Shape = Circle Float
    | Rect Float Float
  \end{snip}
  当我们想要定义一个作用于 \code{Shape} 的函数如 \code{area} 时，我们通过对这两个构造器进行模式匹配来完成：

  \begin{snip}{haskell}
    area :: Shape -> Float
    area (Circle r) = pi * r * r
    area (Rect d h) = d * h
  \end{snip}
  在 C++ 或 Java 中将 \code{Shape} 实现为一个接口，并创建两个类：\code{Circle} 和 \code{Rect}。将 \code{area} 实现为一个虚函数。
  \item
  继续前一个示例：我们可以轻松地添加一个新函数 \code{circ}，它计算 \code{Shape} 的周长。我们可以在不触及 \code{Shape} 定义的情况下完成：

  \begin{snip}{haskell}
    circ :: Shape -> Float
    circ (Circle r) = 2.0 * pi * r
    circ (Rect d h) = 2.0 * (d + h)
  \end{snip}
  将 \code{circ} 添加到你的 C++ 或 Java 实现中。你必须触及原始代码的哪些部分？
  \item
  继续进一步：向 \code{Shape} 添加一个新形状 \code{Square}，并进行所有必要的更新。在 Haskell 和 C++ 或 Java 中，你需要修改哪些代码？（即使你不是 Haskell 程序员，这些修改也应该相当明显。）
  \item
  证明 $a + a = 2 \times a$ 在类型上成立（最多同构）。记住 $2$ 对应于 \code{Bool}，根据我们的对照表。
\end{enumerate}
