% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{现}{在，你几乎不能}谈论函数式编程而不提到幺半群（monads）。但在另一个平行宇宙中，尤金尼奥·莫吉（Eugenio Moggi）可能关注了劳维尔理论（Lawvere theories）而不是幺半群。让我们探索一下那个宇宙。

\section{泛代数\\ \textmd{Universal Algebra}}

有很多方法可以在各种抽象层次上描述代数。我们尝试找到一种通用语言来描述诸如幺半群（monoids）、群（groups）或环（rings）之类的结构。在最简单的层次上，所有这些结构都定义了集合上元素的\emph{运算}，以及必须满足的\emph{定律}。例如，幺半群可以通过一个满足结合律的二元运算来定义。我们还需要一个单位元素和单位定律。但只要稍加想象，我们就可以将单位元素转变为一个零元运算——一个不需要任何参数并返回集合中特殊元素的运算。如果我们想讨论群，我们会添加一个一元运算符，该运算符接受一个元素并返回其逆元。还有相应的左逆定律和右逆定律。环定义了两个二元运算符以及更多的定律。等等。

大体来看，一个代数是通过对不同 $n$ 值的 $n$ 元运算以及一组方程等式来定义的。这些等式都是全称量化的。结合律等式必须对所有可能的三个元素组合成立，等等。

顺便提一下，这就排除了对域的考虑，原因很简单，零（加法的单位）对于乘法没有逆元。对于域的逆元定律不能全称量化。

如果我们将运算（函数）替换为态射，这种泛代数的定义可以扩展到 $\Set$ 以外的范畴。我们选择一个对象 $a$（称为泛对象）而不是集合。一个一元运算就是 $a$ 的一个自同态射（endomorphism）。但对于其他元数呢？（\newterm{元数}（arity）是给定运算的参数个数。）一个二元运算（元数为 2）可以定义为从积 $a\times{}a$ 到 $a$ 的态射。一般的 $n$ 元运算是从 $a$ 的 $n$ 次幂到 $a$ 的态射：
\[\alpha_n \Colon a^n \to a\]
一个零元运算是从终对象（$a$ 的零次幂）到 $a$ 的态射。因此，为了定义任何代数，我们只需要一个范畴，其对象是某个特殊对象 $a$ 的幂。特定的代数被编码在这个范畴的态射集中。这就是劳维尔理论的简要概述。

劳维尔理论的推导经过了许多步骤，以下是路线图：

\begin{enumerate}
  \tightlist
  \item
  有限集范畴 $\cat{FinSet}$。
  \item
  其骨架 $\cat{F}$。
  \item
  其对立范畴 $\Fop$。
  \item
  劳维尔理论 $\cat{L}$：在 $\cat{Law}$ 范畴中的一个对象。
  \item
  劳维尔范畴的模型 $M$：在范畴\\
  $\cat{Mod}(\cat{Law}, \Set)$ 中的一个对象。
\end{enumerate}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{images/lawvere1.png}
\end{figure}

\section{劳维尔理论\\ \textmd{Lawvere Theories}}

所有劳维尔理论共享一个共同的骨架。劳维尔理论中的所有对象都是通过对一个对象进行积运算（实际上是幂运算）生成的。但我们如何在一般范畴中定义这些积？事实证明，我们可以通过从一个更简单的范畴映射来定义积。实际上，这个简单的范畴可以定义余积而不是积，而我们会使用一个\emph{反变}函子将它们嵌入我们的目标范畴中。反变函子将余积转换为积，并将嵌入态射转换为投影态射。

劳维尔范畴骨架的自然选择是有限集范畴 $\cat{FinSet}$。它包含空集 $\varnothing$，一个单元素集合 $1$，一个双元素集合 $2$，等等。这个范畴中的所有对象都可以通过使用余积从单元素集合生成（将空集视为零元余积的特例）。例如，双元素集合是两个单元素集合的和，$2 = 1 + 1$，如下所示的 Haskell 表达式：

\src{snippet01}
然而，即使我们自然地认为只有一个空集，但可能有许多不同的单元素集合。特别是，集合 $1 + \varnothing$ 与集合 $\varnothing + 1$ 是不同的，也与 $1$ 不同——尽管它们都是同构的。集合范畴中的余积不是结合的。我们可以通过构建一个范畴来解决这种情况，该范畴识别所有同构的集合。这种范畴称为\newterm{骨架}（skeleton）。换句话说，任何劳维尔理论的骨架是 $\cat{FinSet}$ 的骨架 $\cat{F}$。这个范畴中的对象可以与自然数（包括零）相对应，这些自然数对应于 $\cat{FinSet}$ 中的元素数量。余积在此处扮演加法的角色。$\cat{F}$ 中的态射对应于有限集之间的函数。例如，从 $\varnothing$ 到 $n$ 存在唯一的态射（空集是初对象），从 $n$ 到 $\varnothing$ 没有态射（除了 $\varnothing \to \varnothing$），从 $1$ 到 $n$ 有 $n$ 个态射（即嵌入态射），从 $n$ 到 $1$ 有一个态射，等等。这里，$n$ 表示 $\cat{F}$ 中的一个对象，它对应于通过同构识别的 $\cat{FinSet}$ 中的所有 $n$ 元集合。

使用范畴 $\cat{F}$，我们可以正式定义\newterm{劳维尔理论}（Lawvere theory）为一个带有特殊函子的范畴 $\cat{L}$：
\[I_{\cat{L}} \Colon \Fop \to \cat{L}\]
这个函子必须在对象上是双射，并且必须保持有限积（$\Fop$ 中的积与 $\cat{F}$ 中的余积相同）：
\[I_{\cat{L}} (m\times{}n) = I_{\cat{L}} m\times{}I_{\cat{L}} n\]
你有时可能会看到这个函子被描述为对象上的恒等，这意味着 $\cat{F}$ 和 $\cat{L}$ 中的对象是相同的。因此，我们将使用相同的名称来表示它们——我们将它们用自然数表示。请记住，$\cat{F}$ 中的对象与集合不同（它们是同构集合的类）。

$\cat{L}$ 中的态射集通常比 $\Fop$ 中的更丰富。它们可能包含除那些对应于 $\cat{FinSet}$ 中函数的态射（后者有时称为\newterm{基本积运算}）以外的态射。劳维尔理论的等式定律编码在这些态射中。

关键的一点是，$\cat{F}$ 中的单元素集合 $1$ 被映射到 $\cat{L}$ 中的某个对象，我们也称其为 $1$，并且 $\cat{L}$ 中的所有其他对象都是这个对象的幂。例如，$\cat{F}$ 中的双元素集合 $2$ 是 $1 + 1$ 的余积，因此它必须映射到 $\cat{L}$ 中的积 $1 \times 1$（或 $1^2$）。从这个意义上说，范畴 $\cat{F}$ 的行为就像是 $\cat{L}$ 的对数。

在 $\cat{L}$ 中，我们有那些通过函子 $I_{\cat{L}}$ 从 $\cat{F}$ 转移来的态射。它们在 $\cat{L}$ 中起结构性作用。特别地，余积嵌入 $i_k$ 变成积投影 $p_k$。一个有用的直觉是将投影：
\[p_k \Colon 1^n \to 1\]
看作一个 $n$ 元函数的原型，它忽略了除第 $k$ 个变量之外的所有变量。相反，$\cat{F}$ 中的常值态射 $n \to 1$ 在 $\cat{L}$ 中变成对角态射 $1 \to 1^n$。它们对应于变量的重复。

$\cat{L}$ 中有趣的态射是定义非投影 $n$ 元运算的那些态射。正是这些态射区分了一个劳维尔理论与另一个。这些是乘法、加法、单位元素的选择等等，这些定义了代数。但是，为了使 $\cat{L}$ 成为一个完整的范畴，我们还需要复合运算 $n \to m$（或等价地 $1^n \to 1^m$）。由于范畴的简单结构，它们最终是 $n \to 1$ 类型的简单态射的积。这是前面我们已经见过的一个泛化，即返回积的函数是函数的积（或者我们已经看到过的同态函子是连续的）。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{images/lawvere1.png}
  \caption{劳维尔理论 $\cat{L}$ 基于 $\Fop$，它从中继承了定义积的“无趣”态射。它添加了描述 $n$ 元运算的“有趣”态射（虚线箭头）。}
\end{figure}

劳维尔理论形成一个范畴 $\cat{Law}$，其中的态射是保持有限积并与函子 $I$ 交换的函子。给定两个这样的理论，$(\cat{L}, I_{\cat{L}})$ 和 $(\cat{L'}, I'_{\cat{L'}})$ 之间的态射是一个函子 $F \Colon \cat{L} \to \cat{L'}$，使得：
\begin{gather*}
  F (m \times n) = F m \times F n \\
  F \circ I_{\cat{L}} = I'_{\cat{L'}}
\end{gather*}
劳维尔理论之间的态射封装了将一个理论解释为另一个理论的思想。例如，如果我们忽略逆元，群的乘法可以被解释为幺半群的乘法。

劳维尔范畴最简单的例子是 $\Fop$ 本身（对应于 $I_{\cat{L}}$ 的恒等函子的选择）。这个没有运算或定律的劳维尔理论恰好是 $\cat{Law}$ 中的初对象。

此时，如果我们没有先了解模型，提供一个非平凡的劳维尔理论例子会非常困难。

\section{劳维尔理论的模型\\ \textmd{Models of Lawvere Theories}}

理解劳维尔理论的关键是要意识到这样的理论概括了很多具有相同结构的个别代数。例如，幺半群的劳维尔理论描述了成为幺半群的本质。它必须对所有幺半群有效。特定的幺半群成为这种理论的模型。模型被定义为从劳维尔理论 $\cat{L}$ 到集合范畴 $\Set$ 的函子（有劳维尔理论的推广使用其他范畴作为模型，但在这里我只集中在 $\Set$ 上）。由于 $\cat{L}$ 的结构高度依赖于积，我们要求这样的函子保持有限积。$\cat{L}$ 的模型（也称为劳维尔理论 $\cat{L}$ 上的代数）因此由一个函子定义：
\begin{gather*}
  M \Colon \cat{L} \to \Set \\
  M (a \times b) \cong M a \times M b
\end{gather*}
注意，我们只要求积保持到同构。这一点非常重要，因为严格保持积会排除大多数有趣的理论。

模型保持积意味着 $M$ 在 $\Set$ 中的像是由集合 $M 1$（$\cat{L}$ 中 $1$ 的像）生成的一系列集合。我们称这个集合为 $a$。在特别的情况下，$\cat{L}$ 中的二元运算被映射到函数：
\[a \times a \to a\]
和任何函子一样，$\cat{L}$ 中的多个态射可能会折叠为 $\Set$ 中的同一个函数。

顺便提一下，由于所有定律都是全称量化的等式，这意味着每个劳维尔理论都有一个平凡模型：一个将所有对象映射到单元素集合的常值函子，并将所有态射映射为该集合上的恒等函数。

在 $\cat{L}$ 中，形式为 $m \to n$ 的一般态射被映射到一个函数：
\[a^m \to a^n\]
如果我们有两个不同的模型，$M$ 和 $N$，它们之间的自然变换是一个由 $n$ 索引的函数族：
\[\mu_n \Colon M n \to N n\]
或者等价地：
\[\mu_n \Colon a^n \to b^n\]
其中 $b = N 1$。

请注意，自然性条件保证了 $n$ 元运算的保持：
\[N f \circ \mu_n = \mu_1 \circ M f\]
其中 $f \Colon n \to 1$ 是 $\cat{L}$ 中的一个 $n$ 元运算。

定义模型的函子形成了模型的一个范畴，$\cat{Mod}(\cat{L}, \Set)$，其态射是自然变换。

考虑劳维尔范畴 $\Fop$ 的模型。这样的模型完全由其在 $1$ 处的值 $M 1$ 决定。因为 $M 1$ 可以是任意集合，所以有与 $\Set$ 中集合一样多的模型。此外，$\cat{Mod}(\Fop, \Set)$ 中的每个态射（即 $M$ 和 $N$ 之间的自然变换）都由其在 $M 1$ 的分量唯一确定。反过来，$M 1 \to N 1$ 的每个函数都会在两个模型 $M$ 和 $N$ 之间诱导一个自然变换。因此，$\cat{Mod}(\Fop, \Set)$ 与 $\Set$ 是等价的。

\section{幺半群理论\\ \textmd{The Theory of Monoids}}

最简单的非平凡劳维尔理论例子描述了幺半群的结构。它是一个单一理论，提炼了所有可能幺半群的结构，因为该理论的模型涵盖了整个 $\cat{Mon}$ 范畴的幺半群。我们已经看到一个\hyperref[free-monoids]{通用构造}，它表明每个幺半群都可以通过识别适当的自由幺半群的态射来获得。因此，一个自由幺半群已经概括了许多幺半群。然而，自由幺半群有无数个。幺半群的劳维尔理论 $\cat{L}_{\cat{Mon}}$ 将它们组合成一个优雅的构造。

每个幺半群必须有一个单位，所以我们必须在 $\cat{L}_{\cat{Mon}}$ 中有一个从 $0$ 到 $1$ 的特殊态射 $\eta$。注意，在 $\cat{F}$ 中没有相应的态射。这样的态射会朝相反的方向，从 $1$ 到 $0$，在 $\cat{FinSet}$ 中，这将是一个从单元素集合到空集的函数。不存在这样的函数。

接下来，考虑 $\cat{L}_{\cat{Mon}}(2, 1)$ 中的态射 $2 \to 1$，它们必须包含所有二元运算的原型。在 $\cat{Mod}(\cat{L}_{\cat{Mon}}, \Set)$ 中构建模型时，这些态射将被映射为从笛卡尔积 $M 1 \times M 1$ 到 $M 1$ 的函数。换句话说，二元函数。

问题是：仅使用幺半群运算符可以实现多少个二元函数。我们将两个参数称为 $a$ 和 $b$。有一个函数忽略这两个参数并返回幺半群的单位元素。然后有两个投影函数，分别返回 $a$ 和 $b$。然后是返回 $ab$、$ba$、$aa$、$bb$、$aab$ 等等的函数……事实上，存在与具有生成元 $a$ 和 $b$ 的自由幺半群的元素数量相同的二元函数。注意，$\cat{L}_{\cat{Mon}}(2, 1)$ 必须包含所有这些态射，因为自由幺半群是其中一个模型。在自由幺半群中，它们对应于不同的函数。其他模型可能会将 $\cat{L}_{\cat{Mon}}(2, 1)$ 中的多个态射折叠为一个函数，但不是自由幺半群。

如果我们用 $n$ 个生成元的自由幺半群表示为 $n^*$，我们可以将 $\cat{L}(2, 1)$ 的态射集识别为 $\cat{Mon}(1^*, 2^*)$ 在 $\cat{Mon}$ 范畴中的态射集。一般来说，我们选择 $\cat{L}_{\cat{Mon}}(m, n)$ 为 $\cat{Mon}(n^*, m^*)$。换句话说，$\cat{L}_{\cat{Mon}}$ 是自由幺半群范畴的对偶范畴。

幺半群劳维尔理论的\emph{模型}的范畴\\
$\cat{Mod}(\cat{L}_{\cat{Mon}}, \Set)$ 与所有幺半群的范畴 $\cat{Mon}$ 是等价的。

\section{劳维尔理论与幺半群\\ \textmd{Lawvere Theories and Monads}}

你可能记得，代数理论可以使用幺半群来描述——特别是\hyperref[algebras-for-monads]{幺半群的代数}。因此，不应感到惊讶，劳维尔理论与幺半群之间存在联系。

首先，让我们看看一个劳维尔理论如何诱导一个幺半群。它通过一个\hyperref[free-forgetful-adjunctions]{伴随}来实现，在遗忘函子和自由函子之间。遗忘函子 $U$ 将一个集合分配给每个模型。这个集合是通过在 $\cat{L}$ 中对对象 $1$ 求值的函子 $M$ 给出的。

另一种导出 $U$ 的方法是利用 $\Fop$ 是 $\cat{Law}$ 中的初对象这一事实。这意味着，对于任何劳维尔理论 $\cat{L}$，存在一个唯一的函子 $\Fop \to \cat{L}$。这个函子在模型上诱导了一个相反的函子（因为模型是从理论到集合的函子）：
\[\cat{Mod}(\cat{L}, \Set) \to \cat{Mod}(\Fop, \Set)\]
但是，正如我们讨论的，$\Fop$ 的模型范畴等价于 $\Set$，因此我们得到了遗忘函子：
\[U \Colon \cat{Mod}(\cat{L}, \Set) \to \Set\]
可以证明，如此定义的 $U$ 始终有一个左伴随，即自由函子 $F$。

对于有限集合，这很容易看出。自由函子 $F$ 产生自由代数。自由代数是从有限生成元集 $n$ 生成的 $\cat{Mod}(\cat{L}, \Set)$ 中的特定模型。我们可以将 $F$ 实现为可表函子：
\[\cat{L}(n, -) \Colon \cat{L} \to \Set\]
要证明它确实是自由的，我们需要做的只是证明它是遗忘函子的左伴随：
\[\cat{Mod}(\cat{L}(n, -), M) \cong \Set(n, U(M))\]
让我们简化右侧：
\[\Set(n, U(M)) \cong \Set(n, M 1) \cong (M 1)^n \cong M n\]
（我使用了这样一个事实，即态射集同构于指数集，在这种情况下，这只是迭代积。）伴随关系是 Yoneda 引理的结果：
\[[\cat{L}, \Set](\cat{L}(n, -), M) \cong M n\]
因此，遗忘函子和自由函子一起定义了 $\Set$ 上的\hyperref[monads-categorically]{幺半群} $T = U \circ F$。因此，每个劳维尔理论都生成一个幺半群。

事实证明，此幺半群的\hyperref[algebras-for-monads]{幺半群代数}范畴与模型的范畴是等价的。

你可能还记得，幺半群代数定义了使用幺半群形成的表达式的评估方法。劳维尔理论定义了可用于生成表达式的 $n$ 元运算。模型提供了评估这些表达式的方法。

劳维尔理论与幺半群之间的联系并不是双向的。只有有限的幺半群会导致劳维尔理论。有限幺半群基于有限函子。$\Set$ 上的有限函子完全由其在有限集上的作用决定。它在任意集合 $a$ 上的作用可以使用以下共端来求值：
\[F a = \int^n a^n \times (F n)\]
由于共端推广了余积或和，因此该公式是幂级数展开的推广。或者我们可以使用函子是广义容器的直觉。在这种情况下，$a$ 的有限容器可以描述为形状和内容的和。这里，$F n$ 是存储 $n$ 个元素的形状的集合，内容是 $n$ 元组的元素本身，是 $a^n$ 的一个元素。例如，列表（作为函子）是有限的，每个元数只有一个形状。树在每个元数上有更多的形状，等等。

首先，从劳维尔理论生成的所有幺半群都是有限的，它们可以表示为共端：
\[T_{\cat{L}} a = \int^n a^n \times \cat{L}(n, 1)\]
反过来，给定 $\Set$ 上的任意有限幺半群 $T$，我们可以构造一个劳维尔理论。我们首先构造一个 $T$ 的 Kleisli 范畴。正如你可能记得的，在 Kleisli 范畴中，从 $a$ 到 $b$ 的态射由基础范畴中的一个态射给出：
\[a \to T b\]
当限制为有限集时，这变为：
\[m \to T n\]
这个 Kleisli 范畴的对立范畴 $\cat{Kl}^\mathit{op}_{T}$ 限制为有限集就是所讨论的劳维尔理论。特别地，描述 $\cat{L}$ 中 $n$ 元运算的态射集 $\cat{L}(n, 1)$ 由 $\cat{Kl}_{T}(1, n)$ 中的态射集给出。

事实证明，我们在编程中遇到的大多数幺半群都是有限的，唯一的例外是延续幺半群。可以扩展劳维尔理论的概念以超越有限元运算。

\section{幺半群作为共端\\ \textmd{Monads as Coends}}

让我们更详细地探索共端公式。
\[T_{\cat{L}} a = \int^n a^n \times \cat{L}(n, 1)\]
首先，这个共端是在 $\cat{F}$ 中的一个伴随函子 $P$ 上取的，定义为：
\[P n m = a^n \times \cat{L}(m, 1)\]
这个伴随函子在第一个参数 $n$ 中是反变的。考虑它如何提升态射。$\cat{FinSet}$ 中的一个态射是一个有限集 $f \Colon m \to n$ 的映射。这样的映射描述了从一个 $n$ 元集合中选择 $m$ 个元素（允许重复）。它可以提升为 $a$ 幂的映射，注意方向：
\[a^n \to a^m\]
提升只是从 $n$ 元组 $(a_1, a_2, \ldots{}, a_n)$ 中选择 $m$ 个元素（可能有重复）。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/liftpower.png}
\end{figure}

例如，让我们取 $f_k \Colon 1 \to n$——从 $n$ 元集合中选择第 $k$ 个元素。它提升为一个函数，该函数接受 $n$ 元组的 $a$ 元素并返回第 $k$ 个元素。

或者让我们取 $f \Colon m \to 1$——将所有 $m$ 个元素映射为一个常值的函数。它的提升是一个函数，该函数接受 $a$ 的单个元素并将其复制 $m$ 次：
\[\lambda{}x \to (\underbrace{x, x, \ldots{}, x}_{m})\]
你可能注意到，立刻看出这个伴随函子在第二个参数中是协变的并不容易。同态函子 $\cat{L}(m, 1)$ 实际上在 $m$ 上是反变的。然而，我们并不是在 $\cat{L}$ 范畴中取共端，而是在 $\cat{F}$ 范畴中。共端变量 $n$ 遍历有限集（或其骨架）。$\cat{L}$ 包含 $\cat{F}$ 的对偶，所以在 $\cat{F}$ 中的态射 $m \to n$ 是 $\cat{L}$ 中的 $\cat{L}(n, m)$ 的成员（嵌入由函子 $I_{\cat{L}}$ 给出）。

让我们检查一下 $\cat{L}(m, 1)$ 作为从 $\cat{F}$ 到 $\Set$ 的函子的函子性。我们希望提升一个函数 $f \Colon m \to n$，因此我们的目标是从 $\cat{L}(m, 1)$ 到 $\cat{L}(n, 1)$ 实现一个函数。与函数 $f$ 对应的 $\cat{L}$ 中的态射是从 $n$ 到 $m$（注意方向）。与 $\cat{L}(m, 1)$ 组合这个态射给我们 $\cat{L}(n, 1)$ 的一个子集。

\begin{figure}[H]
  \centering
  \begin{tikzcd}[column sep=large]
    \cat{L}(m, 1) \arrow[r] & \cat{L}(n, 1)\\
    {}^m \bullet \arrow[r, "f"'] & \bullet^n
  \end{tikzcd}
\end{figure}

注意，通过提升函数 $1 \to n$ 我们可以从 $\cat{L}(1, 1)$ 到 $\cat{L}(n, 1)$。我们稍后会用到这个事实。

一个反变函子 $a^n$ 和一个协变函子 $\cat{L}(m, 1)$ 的乘积是一个伴随函子 $\Fop \times \cat{F} \to \Set$。记住，共端可以定义为伴随函子的所有对角成员的并集（不相交和），其中某些元素被识别。这些识别对应于共楔条件。

在这里，共端从对所有 $n$ 的集合 $a^n \times \cat{L}(n, 1)$ 的不相交和开始。这些识别可以通过表达\hyperref[ends-and-coends]{共端为共等化}来生成。我们从 $a^n \times \cat{L}(m, 1)$ 的对角项开始。要达到对角线，我们可以将一个态射 $f \Colon m \to n$ 应用于积的第一个或第二个分量。然后将两个结果识别出来。

\begin{figure}[H]
  \centering
  \begin{tikzcd}
    & a^n \times \cat{L}(m, 1)
    \arrow[dl, "\langle f {,} \id \rangle"']
    \arrow[dr, "\langle \id {,} f \rangle"]
    & \\
    a^m \times \cat{L}(m, 1)
    & \scalebox{2.5}[1]{\sim}
    & a^n \times \cat{L}(n, 1) \\
    & f \Colon m \to n &
  \end{tikzcd}
\end{figure}

正如我之前展示的，提升 $f \Colon 1 \to n$ 生成以下两种变换：
\[a^n \to a\]
和：
\[\cat{L}(1, 1) \to \cat{L}(n, 1)\]
因此，从 $a^n \times \cat{L}(1, 1)$ 开始，我们可以到达：
\[a \times \cat{L}(1, 1)\]
当我们提升 $\langle f, \id \rangle$ 时，以及：
\[a^n \times \cat{L}(n, 1)\]
当我们提升 $\langle \id, f \rangle$ 时。然而，这并不意味着 $a^n \times \cat{L}(n, 1)$ 的所有元素都可以与 $a \times \cat{L}(1, 1)$ 识别。这是因为 $\cat{L}(n, 1)$ 的所有元素都不能从 $\cat{L}(1, 1)$ 达到。请记住，我们只能提升来自 $\cat{F}$ 的态射。$\cat{L}$ 中的非平凡 $n$ 元运算不能通过提升 $f \Colon 1 \to n$ 构造出来。

换句话说，我们只能识别共端公式中的所有加法子集，其中 $\cat{L}(n, 1)$ 可以通过应用基本态射从 $\cat{L}(1, 1)$ 达到。它们都等价于 $a \times \cat{L}(1, 1)$。基本态射是 $\cat{F}$ 中态射的图像。

让我们看看这在最简单的劳维尔理论 $\Fop$ 中是如何工作的。在这样的理论中，每个 $\cat{L}(n, 1)$ 都可以从 $\cat{L}(1, 1)$ 达到。这是因为 $\cat{L}(1, 1)$ 是一个单元素集合，仅包含恒等态射，并且 $\cat{L}(n, 1)$ 仅包含对应于 $\cat{F}$ 中嵌入 $1 \to n$ 的态射，它们\emph{确实}是基本态射。因此，余积中的所有加法项都是等价的，我们得到：
\[T a = a \times \cat{L}(1, 1) = a\]
这是恒等幺半群。

\section{带有副作用的劳维尔理论\\ \textmd{Lawvere Theory of Side Effects}}

由于幺半群与劳维尔理论之间有如此紧密的联系，自然会问劳维尔理论是否可以作为编程中幺半群的替代方案。幺半群的主要问题在于它们不能很好地组合。没有通用的构建幺半群变换器的配方。劳维尔理论在这方面有优势：它们可以使用余积和张量积来组合。另一方面，只有有限的幺半群可以轻松转换为劳维尔理论。这里的例外是延续幺半群。这个领域的研究正在进行中（参见参考书目）。

为了让你了解劳维尔理论如何用于描述副作用，我将讨论一个使用 \code{Maybe} 幺半群传统实现的简单异常情况。

\code{Maybe} 幺半群由具有单个零元运算 $0 \to 1$ 的劳维尔理论生成。该理论的模型是一个函子，将 $1$ 映射到某个集合 $a$，并将零元运算映射为一个函数：

\src{snippet02}
我们可以使用共端公式恢复 \code{Maybe} 幺半群。让我们考虑零元运算的添加对态射集 $\cat{L}(n, 1)$ 的影响。除了创建一个新的 $\cat{L}(0, 1)$（在 $\Fop$ 中不存在），它还向 $\cat{L}(n, 1)$ 添加了新的态射。这些态射是由 $n \to 0$ 的态射与我们的 $0 \to 1$ 组合的结果。这些贡献在共端公式中与 $a^0 \times \cat{L}(0, 1)$ 相关，因为它们可以通过两种不同的方式从：
\[a^n \times \cat{L}(0, 1)\]
通过提升 $0 \to n$ 获得。

\begin{figure}[H]
  \centering
  \begin{tikzcd}
    & a^n \times \cat{L}(0, 1)
    \arrow[dl, "\langle f {,} \id \rangle"']
    \arrow[dr, "\langle \id {,} f \rangle"]
    & \\
    a^0 \times \cat{L}(0, 1)
    & \scalebox{2.5}[1]{\sim}
    & a^n \times \cat{L}(n, 1) \\
    & f \Colon 0 \to n &
  \end{tikzcd}
\end{figure}

共端简化为：
\[T_{\cat{L}} a = a^0 + a^1\]
或者，用 Haskell 表示：

\src{snippet03}
这相当于：

\src{snippet04}
请注意，此劳维尔理论仅支持引发异常，而不支持其处理。

\section{挑战\\ \textmd{Challenges}}

\begin{enumerate}
  \tightlist
  \item
  列举 $\cat{F}$（有限集范畴的骨架）中 $2$ 和 $3$ 之间的所有态射。
  \item
  证明幺半群劳维尔理论的模型范畴等价于列表幺半群的幺半群代数范畴。
  \item
  幺半群劳维尔理论生成了列表幺半群。证明其二元运算可以通过相应的 Kleisli 箭头生成。
  \item
  \textbf{FinSet} 是 $\Set$ 的一个子范畴，并且有一个函子将其嵌入 $\Set$。$\Set$ 上的任何函子都可以限制在 $\cat{FinSet}$ 上。证明一个有限函子是其自身限制的左 Kan 延拓。
\end{enumerate}

\section{进一步阅读\\ \textmd{Further Reading}}
\begin{enumerate}
  \tightlist
  \item
  \urlref{http://www.tac.mta.ca/tac/reprints/articles/5/tr5.pdf}{Functorial Semantics of Algebraic Theories}, F. William Lawvere
  \item
  \urlref{http://homepages.inf.ed.ac.uk/gdp/publications/Comp_Eff_Monads.pdf}{Notions of computation determine monads}, Gordon Plotkin and John Power
\end{enumerate}
