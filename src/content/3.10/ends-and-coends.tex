% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{有}{许多直觉} 可以应用于范畴中的态射，但我们都可以同意，如果对象 $a$ 和对象 $b$ 之间存在态射，那么这两个对象在某种程度上是“相关”的。态射在某种意义上是这种关系的证明。在任何偏序集范畴中，这一点都很明显，其中态射本身就是一种关系。一般来说，在两个对象之间可能有许多关于同一关系的“证明”。这些证明构成了我们称之为态射集（hom-set）的集合。当我们改变对象时，我们得到一个从对象对到“证明”集合的映射。这个映射是函子性的——在第一个参数中是反变的，在第二个参数中是协变的。我们可以将其视为在范畴中建立的一种全局关系。这种关系由态射函子（hom-functor）描述：
\[\cat{C}(-, =) \Colon \cat{C}^\mathit{op}\times{}\cat{C} \to \Set\]
通常，任何这样的函子都可以解释为在范畴中建立一种关系。这种关系还可以涉及两个不同的范畴 $\cat{C}$ 和 $\cat{D}$。描述这种关系的函子具有以下签名，并称为预函子（profunctor）：
\[p \Colon \cat{D}^\mathit{op}\times{}\cat{C} \to \Set\]
数学家们说它是从 $\cat{C}$ 到 $\cat{D}$ 的预函子（注意符号的倒置），并使用带斜线的箭头作为它的符号：
\[\cat{C} \nrightarrow \cat{D}\]
你可以将预函子视为 $\cat{C}$ 和 $\cat{D}$ 中对象之间的\newterm{证明相关关系}，其中集合的元素象征着这种关系的证明。每当 $p\ a\ b$ 为空时，$a$ 和 $b$ 之间就不存在关系。请记住，关系不必是对称的。

另一种有用的直觉是将 endofunctor 视为容器的想法进行推广。类型 $p\ a\ b$ 的预函子值可以被认为是 $b$ 的容器，其键由类型 $a$ 的元素表示。特别是，态射预函子的一个元素是从 $a$ 到 $b$ 的函数。

在 Haskell 中，预函子被定义为一个带有 \code{dimap} 方法的二参类型构造器 \code{p}，该方法提升了一对函数，第一个函数是以“错误”的方向作用的：

\src{snippet01}
预函子的函子性告诉我们，如果我们有证明 \code{a} 与 \code{b} 相关的证明，那么只要存在从 \code{c} 到 \code{a} 的态射和从 \code{b} 到 \code{d} 的另一个态射，我们就可以得到证明 \code{c} 与 \code{d} 相关的证明。或者，我们可以将第一个函数视为将新键转换为旧键，第二个函数则修改容器的内容。

对于在一个范畴内作用的预函子，我们可以从类型 $p\ a\ a$ 的对角元素中提取出大量信息。我们可以证明 $b$ 与 $c$ 相关，只要我们有一对态射 $b \to a$ 和 $a \to c$。更好的是，我们可以使用单个态射来到达非对角线值。例如，如果我们有一个态射 $f \Colon a \to b$，我们可以提升对 $\langle f, \idarrow[b] \rangle$ 从 $p\ b\ b$ 到 $p\ a\ b$：

\src{snippet02}
或者我们可以提升对 $\langle \idarrow[a], f \rangle$ 从 $p\ a\ a$ 到 $p\ a\ b$：

\src{snippet03}

\section{双自然变换（Dinatural Transformations）}

由于预函子是函子，我们可以按照标准方式定义它们之间的自然变换。然而，在许多情况下，仅定义两个预函子对角线元素之间的映射就足够了。这样的变换称为双自然变换，只要它满足反映我们可以将对角线元素连接到非对角线元素的两种方式的交换条件。两个预函子 $p$ 和 $q$ 之间的双自然变换，是函子范畴 ${[}\cat{C}^\mathit{op}\times{}\cat{C}, \Set{]}$ 中的态射族：
\[\alpha_a \Colon p\ a\ a \to q\ a\ a\]
对于任意 $f \Colon a \to b$，下面的图表是交换的：

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/end.jpg}
\end{figure}

\noindent
请注意，这比自然性条件要弱一些。如果 $\alpha$ 是 ${[}\cat{C}^\mathit{op}\times{}\cat{C}, \Set{]}$ 中的自然变换，那么上面的图表可以由两个自然性方块和一个函子性条件（预函子 $q$ 保持组合性）构成：

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/end-1.jpg}
\end{figure}

\noindent
请注意，自然变换 $\alpha$ 的分量在 ${[}\cat{C}^\mathit{op}\times{}\cat{C}, \Set{]}$ 中是由一对对象 $\alpha_{a b}$ 索引的。而双自然变换则只对一个对象索引，因为它只映射预函子的对角线元素。

\section{Ends}

我们现在准备从“代数”进阶到范畴论的“微积分”。端的微积分（ends 和 coends）借用了传统微积分中的一些思想，甚至包括一些符号。特别是，coend 可以理解为一个无穷和或积分，而 end 类似于无穷乘积。甚至还有一些类似于狄拉克δ函数的东西。

end 是极限的推广，函数子被预函子所取代。代替锥体，我们有了楔形。楔形的底部由预函子 $p$ 的对角线元素构成。楔形的顶点是一个对象（在这里，由于我们考虑的是 $\Set$ 值的预函子，所以是一个集合），而边是将顶点映射到基中的集合的函数族。你可以将这个族视为一个多态函数——一个在返回类型上多态的函数：
\[\alpha \Colon \forall a\ .\ \mathit{apex} \to p\ a\ a\]
与锥体不同，在楔形中我们没有连接基顶点的函数。然而，正如我们前面所看到的，给定范畴 $\cat{C}$ 中的任意态射 $f \Colon a \to b$，我们可以将 $p\ a\ a$ 和 $p\ b\ b$ 都连接到公共集合 $p\ a\ b$。因此，我们坚持要求以下图表交换：

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/end-2.jpg}
\end{figure}

\noindent
这被称为\newterm{楔形条件}。它可以写成：
\[p\ \idarrow[a]\ f \circ \alpha_a = p\ f\ \idarrow[b] \circ \alpha_b\]
或者，使用 Haskell 表示法：

\src{snippet04}
现在我们可以进行通用构造，并将 $p$ 的 end 定义为通用楔形——一个集合 $e$ 和一个函数族 $\pi$，使得对于任何顶点为 $a$ 的楔形和一个函数族 $\alpha$，都存在一个唯一的函数 $h \Colon a \to e$ 使得所有的三角形都交换：
\[\pi_a \circ h = \alpha_a\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/end-21.jpg}
\end{figure}

\noindent
end 的符号是积分符号，“积分变量”位于下标位置：
\[\int_c p\ c\ c\]
$\pi$ 的分量称为 end 的投影映射：
\[\pi_a \Colon \int_c p\ c\ c \to p\ a\ a\]
请注意，如果 $\cat{C}$ 是离散范畴（除了恒等态射外没有其他态射），那么 end 只是预函子 $p$ 在整个范畴 $\cat{C}$ 中所有对角线项的全局积。稍后我将向你展示，在更一般的情况下，end 与通过等化子（equalizer）获得的积之间的关系。

在 Haskell 中，end 公式直接翻译为通用量词：

\src{snippet05}
严格来说，这只是 $p$ 的所有对角线元素的乘积，但楔形条件由于\urlref{https://bartoszmilewski.com/2017/04/11/profunctor-parametricity/}{参数性}的原因自动满足。对于任何函数 $f \Colon a \to b$，楔形条件表示为：

\src{snippet06}
或者，带有类型注释：

\begin{snipv}
  dimap f id\textsubscript{b} . pi\textsubscript{b} = dimap id\textsubscript{a} f . pi\textsubscript{a}
\end{snipv}
这两个公式的类型都是：

\src{snippet07}
而 \code{pi} 是多态投影：

\src{snippet08}
在这里，类型推断自动选择 \code{e} 的正确分量。

正如我们能够将锥体的所有交换条件表达为一个自然变换一样，我们也可以将所有楔形条件组合成一个双自然变换。为此，我们需要将常量函子 $\Delta_c$ 推广为常量预函子，将所有对象对映射到一个单一对象 $c$，并将所有态射对映射到该对象的恒等态射。楔形是从该函子到预函子 $p$ 的双自然变换。实际上，当我们意识到 $\Delta_c$ 将所有态射提升为一个恒等函数时，双自然性六边形会缩小为楔形菱形。

end 也可以为其他目标范畴定义，但在这里我们只考虑 $\Set$ 值的预函子及其 end。

\section{Ends 作为等化子}

end 定义中的交换条件可以使用等化子来书写。首先，让我们定义两个函数（我使用 Haskell 表示法，因为数学符号在这种情况下似乎不太友好）。这些函数对应于楔形条件的两个汇聚分支：

\src{snippet09}[b]
两个函数都将预函子 \code{p} 的对角线元素映射到多态函数类型：

\src{snippet10}
这些函数具有不同的类型。然而，如果我们形成一个大乘积类型，将所有 \code{p} 的对角线元素聚集在一起，我们可以统一它们的类型：

\src{snippet11}
函数 \code{lambda} 和 \code{rho} 诱导了从这个乘积类型的两个映射：

\src{snippet12}
\code{p} 的 end 是这两个函数的等化子。请记住，等化子选择了两个函数相等的最大子集。在这种情况下，它选择了 \code{p} 的所有对角线元素的乘积，其中楔形图交换。

\section{自然变换作为 Ends}

end 最重要的一个例子是自然变换的集合。两个函子 $F$ 和 $G$ 之间的自然变换是从形如 $\cat{C}(F a, G a)$ 的态射集选择的态射族。如果没有自然性条件，自然变换的集合只是这些态射集的乘积。实际上，在 Haskell 中就是这样：

\src{snippet13}
之所以在 Haskell 中起作用，是因为自然性是从参数性推导出来的。然而，在 Haskell 之外，并不是所有跨越这些态射集的对角线部分都能生成自然变换。但请注意，映射：
\[\langle a, b \rangle \to \cat{C}(F a, G b)\]
是一个预函子，因此研究其 end 是有意义的。这是楔形条件：

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/end1.jpg}
\end{figure}

\noindent
让我们从集合 $\int_c \cat{C}(F c, G c)$ 中选择一个元素。这两个投影将此元素映射到一个特定变换的两个分量上，让我们称它们为：
\begin{align*}
  \tau_a & \Colon F a \to G a \\
  \tau_b & \Colon F b \to G b
\end{align*}
在左分支中，我们提升了一个态射对 $\langle \idarrow[a], G f \rangle$，使用态射函子。当作用于 $\tau_a$ 时，提升的对给我们：
\[G f \circ \tau_a \circ \idarrow[a]\]
图的另一个分支给我们：
\[\idarrow[b] \circ \tau_b \circ F f\]
它们的相等性由楔形条件要求，这正是 $\tau$ 的自然性条件。

\section{Coends}
如预期的那样，end 的对偶称为 coend。它是由楔形的对偶构建的，称为反楔形（cowedge，发音为 co-wedge，而不是 cow-edge）。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.25\textwidth]{images/end-31.jpg}
  \caption{“反楔形”}
\end{figure}

\noindent
coend 的符号是积分符号，“积分变量”位于上标位置：
\[\int^c p\ c\ c\]
就像 end 与乘积有关一样，coend 与并集或求和有关（在这方面，它类似于积分，它是和的极限）。与投影不同，coend 有从预函子的对角线元素到 coend 的注入。如果没有反楔形条件，我们可以说，预函子 $p$ 的 coend 可能是 $p\ a\ a$、$p\ b\ b$、$p\ c\ c$ 等等。或者我们可以说，存在这样的 $a$，使得 coend 只是集合 $p\ a\ a$。我们在 end 定义中使用的通用量词在 coend 中变为存在量词。

这就是为什么，在伪 Haskell 中，我们会将 coend 定义为：

\begin{snip}{text}
  exists a. p a a
\end{snip}
在 Haskell 中编码存在量词的标准方法是使用通用量词的数据构造器。因此我们可以定义：

\src{snippet14}
其逻辑是，应该可以使用 $p\ a\ a$ 家族中的任何类型的值来构造一个 coend，无论我们选择了哪个 $a$。

就像 end 可以用等化子来定义一样，coend 可以用\newterm{反等化子（coequalizer）}来描述。所有的反楔形条件可以通过取 $p\ a\ b$ 的一个巨大的并集，并为所有可能的 $b \to a$ 函数而满足。在 Haskell 中，可以表示为存在类型：

\src{snippet15}
有两种方法来计算这个和类型，即通过提升函数并应用于预函子 $p$：

\src{snippet16}
其中，\code{DiagSum} 是预函子 $p$ 的对角线元素的并集：

\src{snippet17}
coend 是这两个函数的反等化子。反等化子通过识别由同一参数应用 \code{lambda} 或 \code{rho} 获得的值，自动满足反楔形条件。这里，参数是一个包含函数 $b \to a$ 和 $p\ a\ b$ 元素的对。应用 \code{lambda} 和 \code{rho} 生成的可能不同的 \code{DiagSum p} 值。在 coend 中，这两个值被识别出来，使得反楔形条件自动满足。

在集合中识别相关元素的过程正式称为取商（taking a quotient）。要定义商，我们需要一个\newterm{等价关系} $\sim$，它是自反的、对称的和传递的关系：
\begin{align*}
  & a \sim a                                                         \\
  & \text{如果}\ a \sim b\ \text{则}\ b \sim a                       \\
  & \text{如果}\ a \sim b\ \text{且}\ b \sim c\ \text{则}\ a \sim c
\end{align*}
这种关系将集合分割成等价类。每个类由彼此相关的元素组成。通过从每个类中选择一个代表来形成商集。一个经典的例子是有理数的定义，它们是由整数对构成，并具有以下等价关系：
\[(a, b) \sim (c, d)\ \text{当且仅当}\ a * d = b * c\]
很容易验证这是一种等价关系。对 $(a, b)$ 被解释为分数 $\frac{a}{b}$，分子和分母具有公约数的分数被识别为相同的有理数。一个有理数是这样的分数的等价类。

你可能还记得我们早先讨论极限和余极限时，态射函子是连续的，也就是说，它保持极限。对偶地，反变态射函子将余极限转换为极限。这些属性可以推广到 ends 和 coends，它们分别是极限和余极限的推广。特别是，我们得到一个非常有用的恒等式，用于将 coends 转换为 ends：
\[\Set(\int^x p\ x\ x, c) \cong \int_x \Set(p\ x\ x, c)\]
让我们在伪 Haskell 中看看它：

\begin{snipv}
(exists x. p x x) -> c \ensuremath{\cong} forall x. p x x -> c
\end{snipv}
它告诉我们，接受存在类型的函数等价于一个多态函数。这非常有意义，因为这样的函数必须准备好处理可能编码在存在类型中的任何一种类型。与此相同的原理告诉我们，接受和类型的函数必须作为 case 语句实现，其中包含一个处理程序元组，每种类型都有一个处理程序。在这里，和类型被 coend 替代，而处理程序族则成为 end 或多态函数。

\section{忍者 Yoneda 引理}

在 Yoneda 引理中出现的自然变换集合可以使用 end 进行编码，得到以下公式：
\[\int_z \Set(\cat{C}(a, z), F z) \cong F a\]
还有一个对偶公式：
\[\int^z \cat{C}(z, a)\times{}F z \cong F a\]
这一定律与狄拉克δ函数的公式有着强烈的相似性（函数 $\delta(a - z)$，或更确切地说是一个分布，在 $a = z$ 时有一个无限的峰值）。在这里，态射函子起到了δ函数的作用。

这两个公式合在一起，有时被称为忍者 Yoneda 引理。

要证明第二个公式，我们将使用 Yoneda 镶嵌的结果，该结果指出，如果两个对象的态射函子同构，那么它们是同构的。换句话说，$a \cong b$ 如果且仅有且仅有一个类型为：
\[[\cat{C}, \Set](\cat{C}(a, -), \cat{C}(b, =))\]
的自然变换，并且这个自然变换是一个同构。

我们首先将我们想要证明的恒等式的左侧插入到一个态射函子中，该态射函子将映射到某个任意对象 $c$：
\[\Set(\int^z \cat{C}(z, a)\times{}F z, c)\]
使用连续性论证，我们可以将 coend 替换为 end：
\[\int_z \Set(\cat{C}(z, a)\times{}F z, c)\]
现在，我们可以利用乘积和指数之间的对合关系：
\[\int_z \Set(\cat{C}(z, a), c^{(F z)})\]
我们可以使用 Yoneda 引理进行“积分”以得到：
\[c^{(F a)}\]
（注意，我们使用了 Yoneda 引理的反变版本，因为函子 $c^{(F z)}$ 是 $z$ 的反变函子。）
该指数对象与态射集同构：
\[\Set(F a, c)\]
最后，我们利用 Yoneda 镶嵌得出同构：
\[\int^z \cat{C}(z, a)\times{}F z \cong F a\]

\section{预函子的组合}

让我们进一步探讨预函子描述关系的想法——更确切地说，证明相关关系，这意味着集合 $p\ a\ b$ 代表证明 $a$ 与 $b$ 相关的证明集。如果我们有两个关系 $p$ 和 $q$，我们可以尝试将它们组合起来。我们说，通过组合 $q$ 和 $p$，$a$ 与 $b$ 相关，如果存在一个中介对象 $c$ 使得 $q\ b\ c$ 和 $p\ c\ a$ 都不为空。这个新关系的证明是所有单个关系证明的对。因此，在理解存在量词对应于 coend 和两个集合的笛卡尔积对应于“证明对”的前提下，我们可以使用以下公式定义预函子的组合：
\[(q \circ p)\ a\ b = \int^c p\ c\ a\times{}q\ b\ c\]
以下是 \code{Data.Profunctor.Composition} 中的 Haskell 定义，经过一些重命名：

\src{snippet18}
这是使用广义代数数据类型（\acronym{GADT} 语法，其中一个自由类型变量（此处为 \code{c}）自动存在量化。数据构造器 \code{Procompose} 因此等价于：

\begin{snip}{text}
  exists c. (q a c, p c b)
\end{snip}
组合的单位是态射函子——这直接来自于忍者 Yoneda 引理。因此，有意义的是，问是否存在一个范畴，其中预函子作为态射。答案是肯定的，需要注意的是，预函子组合的结合律和单位律仅在自然同构的意义上成立。这样的范畴，法律在同构的基础上成立，被称为双范畴（bicategory），它比 $\cat{2}$-范畴更为普遍。因此我们有一个双范畴 $\cat{Prof}$，其中对象是范畴，态射是预函子，而态射之间的态射（即所谓的二胞元）是自然变换。事实上，我们甚至可以更进一步，因为除了预函子，我们还有常规函子作为范畴之间的态射。具有两种类型态射的范畴称为双范畴。

预函子在 Haskell 镜头库和箭头库中扮演着重要角色。
