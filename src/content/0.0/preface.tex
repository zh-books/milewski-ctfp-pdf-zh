\begin{quote}
  你好啊
  最近一段时间，我一直在酝酿写一本关于范畴论（Category Theory）的书，目标读者是程序员（programmers），注意，不是计算机科学家（computer scientists），而是程序员——工程师（engineers），而不是科学家（scientists）。我知道这听起来很疯狂，而且我也确实感到害怕。我不能否认科学与工程之间存在巨大的差距，因为我在这两方面都有工作经验。但我总是有一种强烈的冲动去解释事物。我对理查德·费曼（Richard Feynman）有着极大的敬佩，他是简明解释的大师。我知道我不是费曼，但我会尽力而为。我首先发布这篇序言，希望能激发读者学习范畴论的兴趣，并希望借此展开讨论并征求反馈意见。\footnote{
    你也可以观看我向现场观众讲授这部分内容的视频，网址为 \href{https://goo.gl/GT2UWU}{https://goo.gl/GT2UWU} （或在 YouTube 上搜索 “bartosz milewski category theory”）。}
\end{quote}

{Haskell 代码示例0000}
\begin{lstlisting}[language=Haskell]
f :: A -> B
toExp :: (a -> b) -> Exp a b
fromExp (Lan f (I x)) = \a -> f (a, x)
instance Functor (FreeF f) where
    fmap g (FMap h fi) = FMap (g . h) fi
\end{lstlisting}

{Haskell 代码示例11111}
\begin{lstlisting}[language=Haskell]
f :: A -> B

toExp :: (a -> b) -> Exp a b
toExp f = Lan (f . fst) (I ())

fromExp :: Exp a b -> (a -> b)
fromExp (Lan f (I x)) = \a -> f (a, x)

instance Functor (FreeF f) where
    fmap g (FMap h fi) = FMap (g . h) fi
\end{lstlisting}

{OCaml 代码示例11111}
\begin{lstlisting}[language=Caml]
module type Polymorphic_Function_F = sig
  type a
  type b

  val f : a -> b
end
module FreeFunctor (F : sig
  type 'a f
end) : Functor = struct
  module type F = FreeF with type 'a f = 'a F.f

  type 'a t = (module F with type a = 'a)

  let fmap
      (type a' b')
      (f : a' -> b')
      (module FF : F with type a = a')
    =
    (module struct
      type 'a f = 'a F.f
      type a = b'
      type i = FF.i

      let h i = f (FF.h i)
      let fi = FF.fi
    end : F
      with type a = b')
  ;;
end

\end{lstlisting}

\lettrine[lhang=0.17]{我}{将尝试}在几段文字中说服你，这本书是为你而写，无论你对在“充裕的业余时间”里学习最抽象的数学分支之一有何反对意见，这些反对意见都是毫无根据的。

我的乐观基于几个观察。首先，范畴论（Category Theory）是极为有用的编程思想的宝库。Haskell 程序员已经很长时间在利用这一资源，这些思想正在慢慢渗透到其他语言中，但这一过程太慢了。我们需要加快这个过程。

其次，不同类型的数学吸引着不同的受众。你可能对微积分或代数过敏，但这并不意味着你不会喜欢范畴论。我甚至要说，范畴论是特别适合程序员（programmers）思维的一类数学。这是因为范畴论并不处理特定事物，而是处理结构（structure）。它处理的是使程序可组合的那类结构。

组合（Composition）是范畴论的根本所在——它是范畴（category）本身定义的一部分。而且我会强烈主张，组合是编程的本质。我们一直在进行组合，早在某位伟大的工程师提出子程序的概念之前，我们就在组合事物。早些时候，结构化编程的原则（principles of structured programming）因为使代码块可组合而彻底改变了编程。然后面向对象编程（object oriented programming）出现了，面向对象编程的核心就是对象的组合。函数式编程（functional programming）不仅涉及函数和代数数据结构的组合，它还使并发（concurrency）可组合——这是在其他编程范式中几乎不可能做到的。

第三，我有一件秘密武器，一把屠刀，我将用它来屠宰数学，使之更易于被程序员接受。作为一名专业的数学家，你必须非常小心，确保所有假设都正确，恰当地限定每一个陈述，并严谨地构造所有证明。这使得数学论文和书籍对于外行人来说极难阅读。我是受过物理学训练的，在物理学中，我们通过非正式推理取得了惊人的进展。数学家曾嘲笑狄拉克δ函数（Dirac delta function），这是伟大的物理学家 P. A. M. Dirac 在现场编造出来的，用以解决一些微分方程。当数学家们发现一个全新的分支——称为分布理论（distribution theory）——并将狄拉克的洞见形式化时，他们才停止了嘲笑。

当然，使用这种挥手自如的论据时，你有可能说出明显错误的东西，因此我会尽量确保书中的非正式论据背后有扎实的数学理论支持。我床头放着一本已经用旧了的桑德斯·麦克莱恩（Saunders Mac Lane）所著的《工作数学家的范畴论》（Categories for the Working Mathematician）。

由于这是面向程序员的范畴论（Category Theory for Programmers），我将使用计算机代码来说明所有主要概念。你可能知道，函数式语言（functional languages）比更流行的命令式语言（imperative languages）更接近数学。它们也提供了更强的抽象能力。因此，一个自然的诱惑是：你必须学习 Haskell，才能享受到范畴论的好处。但这意味着范畴论在函数式编程之外没有应用，这是完全不真实的。因此，我会提供很多 C++ 示例。当然，你需要克服一些丑陋的语法，这些模式可能不会从冗长的背景中脱颖而出，并且你可能需要进行一些复制粘贴，以代替更高的抽象，但这就是 C++ 程序员的命运。

但在 Haskell 方面你并非完全摆脱了困扰。你不必成为 Haskell 程序员，但你需要将其作为一种草图语言，用来记录和实现 C++ 中的想法。这正是我开始学习 Haskell 的方式。我发现其简洁的语法和强大的类型系统对理解和实现 C++ 模板、数据结构和算法大有帮助。但由于我不能指望读者已经了解 Haskell，我会慢慢介绍，并逐步解释一切。

如果你是有经验的程序员，你可能会问自己：我编程这么久了，从未关心过范畴论或函数式方法，那又有什么改变呢？你肯定注意到，新的函数式特性（functional features）正在持续不断地入侵命令式语言。即使是面向对象编程的堡垒 Java 也引入了 lambda 表达式。C++ 最近一直在以狂热的速度发展——每隔几年就会有一个新标准——试图跟上变化的世界。所有这些活动都是为一种颠覆性的变化做准备，或者像我们物理学家所说的那样，是一种相变（phase transition）。如果你不断加热水，它最终会开始沸腾。我们现在就像一只青蛙，必须决定是继续在越来越热的水中游泳，还是开始寻找一些替代方案。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/img_1299.jpg}
\end{figure}

\noindent
推动这一重大变化的力量之一是多核革命（multicore revolution）。现行的编程范式——面向对象编程——在并发性和并行性方面毫无用处，反而鼓励危险且漏洞百出的设计。数据隐藏（data hiding），作为面向对象的基本前提，当与共享和变异相结合时，就成为数据竞争的配方。将一个互斥量（mutex）与它所保护的数据结合的想法很好，但不幸的是，锁（locks）不能组合，而锁的隐藏使得死锁（deadlocks）更有可能发生，也更难调试。

但即使在没有并发性的情况下，日益复杂的软件系统也在考验命令式编程范式的可扩展性。简单地说，副作用（side effects）正在失控。诚然，具有副作用的函数往往方便且易于编写。它们的效果原则上可以通过它们的名字和注释来编码。一个名为 SetPassword 或 WriteFile 的函数显然在改变某种状态并产生副作用，我们习惯于处理这种情况。只有当我们开始在具有副作用的函数之上组合另一个具有副作用的函数，如此反复，问题才会变得复杂起来。问题不在于副作用本身，而在于它们被隐藏，使得在更大规模上无法管理。副作用不具备可扩展性，而命令式编程完全依赖副作用。

硬件的变化和软件复杂性的增加迫使我们重新思考编程的基础。就像欧洲伟大哥特式教堂的建造者一样，我们已经将手艺磨练到了材料和结构的极限。在法国博韦（Beauvais），有一座未完工的哥特式大教堂，见证了这种深深的人类对抗限制的斗争。它本来打算打破所有之前的高度和轻盈记录，但经历了一系列坍塌。像铁杆和木质支撑这样的临时措施防止了它的解体，但显然很多事情出了问题。从现代的角度来看，许多哥特式结构在没有现代材料科学、计算机建模、有限元分析以及广义数学和物理学的帮助下顺利完成，是一个奇迹。我希望未来的几代人能够像钦佩哥特式建筑的建造者一样，钦佩我们在构建复杂操作系统、Web 服务器和互联网基础设施方面展示的编程技能。而且，坦率地说，他们应该钦佩，因为我们所有这些都是基于非常薄弱的理论基础。如果我们想要前进，就必须修复这些基础。

\begin{figure}
  \centering
  \includegraphics[totalheight=0.5\textheight]{images/beauvais_interior_supports.jpg}
  \caption{防止博韦大教堂坍塌的临时措施。}
\end{figure}
