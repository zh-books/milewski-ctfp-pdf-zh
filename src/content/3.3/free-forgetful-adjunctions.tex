% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{自}{由构造}是伴随子的一个强大应用。一个\newterm{自由函子}定义为\newterm{遗忘函子}的左伴随。遗忘函子通常是一个非常简单的函子，它遗忘了一些结构。例如，许多有趣的范畴都是基于集合构建的。但是，抽象这些集合的范畴对象没有内部结构——它们没有元素。然而，这些对象通常保留集合的记忆，即存在一个从给定范畴 $\cat{C}$ 到 $\Set$ 的映射——一个函子。对应于 $\cat{C}$ 中某个对象的集合称为它的\newterm{底层集合}。

幺半群（monoids）是这样的对象，它们有底层集合——元素的集合。存在一个从幺半群范畴 $\cat{Mon}$ 到集合范畴 $\Set$ 的遗忘函子 $U$，它将幺半群映射到它们的底层集合。它还将幺半群态射（同态映射）映射为集合之间的函数。

我喜欢把 $\cat{Mon}$ 看作有双重人格。一方面，它是一堆带有乘法和单位元素的集合。另一方面，它是一个范畴，具有无结构的对象，这些对象的唯一结构编码在它们之间的态射中。每一个保留乘法和单位的集合函数都会产生一个 $\cat{Mon}$ 中的态射。\\
\newline
需要记住的几点：

\begin{itemize}
  \tightlist
  \item
  可能有许多幺半群映射到同一个集合，并且
  \item
  幺半群态射的数量比它们底层集合之间的函数少（或至多相等）。
\end{itemize}

\noindent
作为遗忘函子 $U$ 的左伴随的函子 $F$ 是构建自由幺半群的自由函子。这个伴随关系来源于我们之前讨论过的自由幺半群的通用构造。\footnote{参见第 13 章 \hyperref[free-monoids]{自由幺半群}。}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{images/forgetful.jpg}
  \caption{幺半群 $m_1$ 和 $m_2$ 具有相同的底层集合。$m_2$ 和 $m_3$ 的底层集合之间的函数比它们之间的态射要多。}
\end{figure}

\noindent
在同态集的术语中，我们可以将这个伴随子写为：
\[\cat{Mon}(F x, m) \cong \Set(x, U m)\]
这个（在 $x$ 和 $m$ 上是自然的）同构告诉我们：

\begin{itemize}
  \tightlist
  \item
  对于自由幺半群 $F x$ 和任意幺半群 $m$ 之间的每一个幺半群同态映射，存在一个唯一的函数将生成元集合 $x$ 嵌入到 $m$ 的底层集合中。它是 $\Set(x, U m)$ 中的一个函数。
  \item
  对于将 $x$ 嵌入某个 $m$ 的底层集合中的每一个函数，存在一个唯一的幺半群态射在自由幺半群 $F x$ 和幺半群 $m$ 之间。（这是我们在通用构造中称为 $h$ 的那个态射。）
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{images/freemonadjunction.jpg}
\end{figure}

\noindent
直观上，$F x$ 是可以基于 $x$ 构建的“最大”幺半群。如果我们可以看到幺半群的内部，我们会发现任何属于 $\cat{Mon}(F x, m)$ 的态射都将这个自由幺半群嵌入到某个其他幺半群 $m$ 中。它可能通过标识一些元素来实现这一点。特别是，它将 $F x$ 的生成元（即 $x$ 的元素）嵌入 $m$ 中。这个伴随关系表明，右侧由 $\Set(x, U m)$ 中的函数给出的 $x$ 的嵌入唯一决定了左侧幺半群的嵌入，反之亦然。

在 Haskell 中，列表数据结构是一个自由幺半群（有一些警告：参见 \urlref{http://comonad.com/reader/2015/free-monoids-in-haskell/}{Dan Doel 的博客文章}）。列表类型 \code{{[}a{]}} 是一个自由幺半群，其中类型 \code{a} 代表生成元的集合。例如，类型 \code{{[}Char{]}} 包含单位元素——空列表 \code{{[}{]}}，以及单元素列表如 \code{{[}'a'{]}}, \code{{[}'b'{]}}——这些是自由幺半群的生成元。其余部分通过应用“乘积”生成。在这里，两个列表的乘积只是将一个附加到另一个。附加是结合律和单位律（即这里有一个中立元素——空列表）成立的。由 \code{Char} 生成的自由幺半群不过是所有字符列表的集合。在 Haskell 中，它被称为 \code{String}：

\src{snippet01}
（\code{type} 定义了一个类型同义词——一个现有类型的不同名称。）

另一个有趣的例子是从单一生成元构建的自由幺半群。它是由 \code{()} 组成的列表类型 \code{{[}(){]}}。它的元素是 \code{{[}{]}}, \code{{[}(){]}}, \code{{[}(), (){]}}，等等。每个这样的列表都可以由一个自然数描述——它的长度。列表中的单位并没有更多的信息。附加两个这样的列表会产生一个新列表，其长度是其组成部分的长度之和。很容易看出，类型 \code{{[}(){]}} 与自然数的加法幺半群（带零）同构。以下是两个互为逆函数，见证了这种同构：

\src{snippet02}
为简单起见，我使用了类型 \code{Int} 而不是 \code{Natural}，但原理是相同的。函数 \code{replicate} 创建一个长度为 \code{n} 的列表，预先填充了给定的值——在这里是单位值。

\section{一些直观的理解}

接下来的内容是一些随意的推理。这些推理远不严格，但有助于形成直观理解。

要获得对自由/遗忘伴随子的直观理解，帮助记住函子和函数的本质是有损失的。函子可能会合并多个对象和态射，函数可能会将集合中的多个元素捆绑在一起。此外，它们的像可能只覆盖其陪域的一部分。

在 $\Set$ 中的“平均”同态集将包含从最不损失的函数（例如，注入函数或可能的同构）到将整个定义域折叠为单一元素的常量函数（如果有的话）的整个谱系。

我倾向于将任意范畴中的态射也视为有损失的。这只是一种心理模型，但它是有用的，特别是在考虑伴随子时——尤其是其中一个范畴是 $\Set$ 的情况。

形式上，我们只能谈论可逆的（同构的）或不可逆的态射。后者的态射可以被认为是有损失的。还有一种单态（mono）和满态（epi）态射的概念，它们概括了注入（非合并）和满射（覆盖整个陪域）的函数的概念，但仍然可能有一个既是单态又是满态但仍然不可逆的态射。

在自由 ⊣ 遗忘伴随子中，我们在左侧有一个更受约束的范畴 $\cat{C}$，在右侧有一个不太受约束的范畴 $\cat{D}$。$\cat{C}$ 中的态射“更少”，因为它们必须保留一些额外的结构。而 $\cat{D}$ 中的态射不必保留那么多结构，因此它们“更多”。

当我们将遗忘函子 $U$ 应用于 $\cat{C}$ 中的一个对象 $c$ 时，我们认为它揭示了 $c$ 的“内部结构”。事实上，如果 $\cat{D}$ 是 $\Set$，我们认为 $U$ 是\emph{定义} $c$ 的内部结构——它的底层集合。（在任意范畴中，我们无法谈论对象的内部，除了通过它与其他对象的连接，但这里我们只是在随意推理。）

如果我们使用 $U$ 映射两个对象 $c'$ 和 $c$，我们通常期望同态集 $\cat{C}(c', c)$ 的映射只覆盖 $\cat{D}(U c', U c)$ 的一个子集。这是因为 $\cat{C}(c', c)$ 中的态射必须保留额外的结构，而 $\cat{D}(U c', U c)$ 中的态射则不必。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.45\textwidth]{images/forgettingmorphisms.jpg}
\end{figure}

\noindent
但是由于伴随子被定义为特定同态集的\newterm{同构}，我们必须非常仔细地选择 $c'$。在伴随子中，$c'$ 不是从 $\cat{C}$ 中的任意位置选取的，而是从自由函子 $F$ 的（可能较小的）像中选取的：
\[\cat{C}(F d, c) \cong \cat{D}(d, U c)\]
因此，$F$ 的像必须由有许多态射可以通向任意 $c$ 的对象组成。事实上，必须有尽可能多的结构保留态射从 $F d$ 到 $c$，因为有不保留结构的态射从 $d$ 到 $U c$。这意味着 $F$ 的像必须由本质上没有结构的对象组成（因此没有结构需要态射保留）。这样的“无结构”对象称为自由对象。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.45\textwidth]{images/freeimage.jpg}
\end{figure}

\noindent
在幺半群的例子中，自由幺半群除了由单位和结合律生成的结构外没有其他结构。除此之外，所有的乘法都会生成全新的元素。

在自由幺半群中，$2 * 3$ 不是 $6$——它是一个新元素 ${[}2, 3{]}$。由于没有 ${[}2, 3{]}$ 和 $6$ 的同一性，从这个自由幺半群到任何其他幺半群 $m$ 的态射被允许将它们单独映射。但是也可以将 ${[}2, 3{]}$ 和 $6$（它们的积）映射到 $m$ 的同一个元素中。或者在一个加法幺半群中，将 ${[}2, 3{]}$ 和 $5$（它们的和）标识为相同的元素，依此类推。不同的标识会给你不同的幺半群。

这引出了另一个有趣的直觉：自由幺半群不是执行幺半群操作，而是积累传递给它的参数。它不是将 $2$ 和 $3$ 相乘，而是记住 $2$ 和 $3$ 在一个列表中。这种方案的优点是我们不必指定我们将使用哪种幺半群操作。我们可以继续积累参数，只有在最后才对结果应用操作符。此时我们可以选择应用哪个操作符。我们可以加这些数字，或将它们相乘，或进行模 2 加法，等等。自由幺半群将表达式的创建与其求值分开。当我们讨论代数时，我们会再次看到这一想法。

这种直觉可以推广到其他更复杂的自由构造。例如，我们可以在求值之前积累整个表达式树。这样做的好处是我们可以转换这些树，使求值更快或更少消耗内存。例如，在实现矩阵计算时，这样做可以避免为存储中间结果而分配大量临时数组。

\section{挑战}

\begin{enumerate}
  \tightlist
  \item
  考虑一个从单一生成元构建的自由幺半群。证明从这个自由幺半群到任何幺半群 $m$ 的态射与从单一集合到 $m$ 的底层集合的函数之间存在一一对应关系。
\end{enumerate}
