% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{到}{目前为止}，我一直在略过函数类型的含义。函数类型与其他类型不同。

以 \code{Integer} 为例：它只是一个整数集合。\code{Bool} 是一个包含两个元素的集合。但函数类型 $a\to b$ 不止于此：它是对象 $a$ 和 $b$ 之间的态射集。任何范畴中两个对象之间的态射集被称为同态集（hom-set）。恰好在范畴 $\Set$ 中，每个同态集本身就是同一范畴中的对象——因为它毕竟是一个\emph{集合}。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/set-hom-set.jpg}
  \caption{在集合范畴（Set）中，同态集（hom-set）本质上只是一个集合}
\end{figure}

\noindent
对于其他范畴来说，情况则不同，它们的同态集是外部于范畴的。这些同态集甚至被称为\emph{外部同态集}。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/hom-set.jpg}
  \caption{在范畴 $\cat{C}$ 中，同态集是一个外部集合}
\end{figure}

\noindent
正是集合范畴 $\Set$ 的这种自我引用特性使得函数类型如此特别。但在某些范畴中，有一种方法可以构造表示同态集的对象。这种对象被称为\newterm{内部同态集}。

\section{泛在构造}

让我们暂时忘记函数类型是集合，尝试从头开始构造一个函数类型，或者更一般地，构造一个内部同态集。像往常一样，我们将从集合范畴 $\Set$ 中获得启发，但要小心避免使用任何集合的特性，这样该构造就能自动适用于其他范畴。

函数类型可以被认为是一种复合类型，因为它与参数类型和结果类型有关系。我们已经见过复合类型的构造——那些涉及对象之间关系的类型。我们使用泛在构造来定义\hyperref[products-and-coproducts]{乘积类型和余积类型}。我们可以使用同样的技巧来定义函数类型。我们需要一个涉及三个对象的模式：我们正在构造的函数类型、参数类型和结果类型。

连接这三种类型的显而易见的模式被称为\newterm{函数应用}或\newterm{求值}。给定一个函数类型的候选者，我们称之为 $z$（注意，如果我们不在集合范畴 $\Set$ 中，它只是一个普通的对象），以及参数类型 $a$（一个对象），求值将这一对映射到结果类型 $b$（一个对象）。我们有三个对象，其中两个是固定的（表示参数类型和结果类型的对象）。

我们还具有应用关系，这是一个映射。如何将此映射纳入我们的模式？如果我们被允许查看对象的内部，我们可以将一个函数 $f$（$z$ 的一个元素）与一个参数 $x$（$a$ 的一个元素）配对，并将其映射到 $f x$（$f$ 对 $x$ 的应用，其为 $b$ 的一个元素）。

\begin{figure}[H]
  \centering\includegraphics[width=0.35\textwidth]{images/functionset.jpg}
  \caption{在集合范畴中，我们可以从函数集合 $z$ 中选择一个函数 $f$，并从集合（类型）$a$ 中选择一个参数 $x$，得到集合（类型）$b$ 中的一个元素 $f x$。}
\end{figure}

\noindent
但是，与其处理单个对 $(f, x)$，我们不妨讨论函数类型 $z$ 和参数类型 $a$ 的整个\emph{乘积}。乘积 $z\times{}a$ 是一个对象，我们可以选择将其映射到 $b$ 的箭头 $g$ 作为应用态射。在集合范畴 $\Set$ 中，$g$ 是将每个对 $(f, x)$ 映射到 $f x$ 的函数。

所以这就是模式：两个对象 $z$ 和 $a$ 的乘积通过一个态射 $g$ 连接到另一个对象 $b$。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/functionpattern.jpg}
  \caption{对象和态射的模式，这是泛在构造的起点}
\end{figure}

\noindent
这个模式是否足够具体以通过泛在构造挑选出函数类型？并非在每个范畴中都是如此。但在我们感兴趣的范畴中确实如此。还有一个问题：是否有可能在没有首先定义乘积的情况下定义函数对象？有些范畴中没有乘积，或者某些对象对没有乘积。答案是否定的：如果没有乘积类型，就没有函数类型。稍后我们讨论指数时会回到这个问题。

让我们回顾一下泛在构造。我们从对象和态射的模式开始。这是我们不精确的查询，通常会产生大量的结果。特别是在集合范畴 $\Set$ 中，几乎所有东西都相互连接。我们可以取任何对象 $z$，将其与 $a$ 组成乘积，并且总会有一个从它到 $b$ 的函数（除非 $b$ 是一个空集）。

这时我们应用我们的秘密武器：排名。通常通过要求候选对象之间存在唯一的映射来完成排名——一个以某种方式对我们的构造进行因式分解的映射。在我们的例子中，如果 $z$ 与从 $z \times a$ 到 $b$ 的态射 $g$ 比某个其他对象 $z'$ 及其自己的应用 $g'$ 更\emph{好}，那么当且仅当存在一个从 $z'$ 到 $z$ 的唯一映射 $h$，使得 $g'$ 的应用通过 $g$ 的应用进行因式分解时，$z$ 被认为更好。（提示：在看图时阅读这句话。）

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/functionranking.jpg}
  \caption{在函数对象的候选者之间建立排名}
\end{figure}

\noindent
现在到了关键部分，也是我推迟讨论这个特定泛在构造的主要原因。给定从 $z'$ 到 $z$ 的态射 $h$，我们希望关闭图表，其中 $z'$ 和 $z$ 都与 $a$ 交叉。我们真正需要的是一个从 $z' \times a$ 到 $z \times a$ 的映射。现在，讨论了\hyperref[functoriality]{乘积的函子性}后，我们知道如何做到这一点。由于乘积本身是一个函子（更准确地说是一个自双函子），因此可以提升态射对。换句话说，我们不仅可以定义对象的乘积，还可以定义态射的乘积。

由于我们没有触及乘积 $z' \times a$ 的第二个分量，我们将提升态射对 $(h, \id)$，其中 $\id$ 是 $a$ 上的恒等态射。

因此，这就是我们如何将一个应用 $g$ 从另一个应用 $g'$ 中因式分解出来的：
\[g' = g \circ (h \times \id)\]
这里的关键是乘积对态射的作用。

泛在构造的第三部分是选择那个普遍最优的对象。我们将这个对象称为 $a \Rightarrow b$（将其视为一个符号名称，而不是 Haskell 类型类约束——稍后我会讨论不同的命名方法）。这个对象带有它自己的应用态射——从 $(a \Rightarrow b) \times a$ 到 $b$ 的一个态射——我们将其称为 $\mathit{eval}$。如果其他任何函数对象的候选者都可以唯一地映射到它，并且其应用态射 $g$ 可以通过 $\mathit{eval}$ 因式分解，则该对象是最佳的。这个对象比任何其他对象都好，根据我们的排名。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/universalfunctionobject.jpg}
  \caption{普遍函数对象的定义。这与上面的图是相同的，但现在对象 $a \Rightarrow b$ 是\emph{普遍的}。}
\end{figure}

\noindent
正式定义：

\begin{longtable}[]{@{}l@{}}
  \toprule
  \begin{minipage}[t]{0.97\columnwidth}\raggedright\strut
  从 $a$ 到 $b$ 的一个\emph{函数对象} 是一个对象 $a \Rightarrow b$ 以及态射
  \[\mathit{eval} \Colon ((a \Rightarrow b) \times a) \to b\]
  使得对于任何其他对象 $z$ 及其态射
  \[g \Colon z \times a \to b\]
  都存在唯一的态射
  \[h \Colon z \to (a \Rightarrow b)\]
  将 $g$ 因式分解通过 $\mathit{eval}$：
  \[g = \mathit{eval} \circ (h \times \id)\]
  \end{minipage}\tabularnewline
  \bottomrule
\end{longtable}

\noindent
当然，不能保证在给定的范畴中，任何一对对象 $a$ 和 $b$ 都存在这样的对象 $a \Rightarrow b$。但在集合范畴 $\Set$ 中总是存在。而且，在 $\Set$ 中，这个对象同构于同态集 $\Set(a, b)$。

这就是为什么在 Haskell 中，我们将函数类型 \code{a -> b} 解释为范畴的函数对象 $a \Rightarrow b$。

\section{柯里化}

让我们再看看所有函数对象的候选者。不过这次，让我们将态射 $g$ 视为一个有两个变量的函数，$z$ 和 $a$。
\[g \Colon z \times a \to b\]
作为一个来自乘积的态射，几乎等同于一个有两个变量的函数。特别地，在集合范畴 $\Set$ 中，$g$ 是一个从对（来自集合 $z$ 和集合 $a$ 的值组成的对）到集合 $b$ 的函数。

另一方面，普遍性质告诉我们，对于每个这样的 $g$，都存在唯一的态射 $h$ 将 $z$ 映射到一个函数对象 $a \Rightarrow b$。
\[h \Colon z \to (a \Rightarrow b)\]
在集合范畴 $\Set$ 中，这意味着 $h$ 是一个高阶函数，它接受一个类型为 $z$ 的变量，并返回一个从 $a$ 到 $b$ 的函数。因此，普遍构造建立了两个变量函数与返回函数的一个变量函数之间的一对一对应关系。这个对应关系称为\newterm{柯里化}，而 $h$ 被称为 $g$ 的柯里化版本。

这个对应关系是一对一的，因为对于任何给定的 $g$ 都存在唯一的 $h$，并且对于任何给定的 $h$，你都可以使用公式重新创建两个变量的函数 $g$：
\[g = \mathit{eval} \circ (h \times \id)\]
函数 $g$ 可以称为 $h$ 的\emph{反柯里化}版本。

柯里化本质上内嵌于 Haskell 的语法中。返回一个函数的函数：

\src{snippet01}
通常被认为是一个两个变量的函数。这就是我们阅读未加括号的签名的方式：

\src{snippet02}
这种解释在我们定义多参数函数的方式中显而易见。例如：

\src{snippet03}
同样的函数可以写成一个返回函数的单参数函数——一个 lambda 表达式：

\src{snippet04}
这两个定义是等价的，并且都可以部分应用于仅一个参数，生成一个单参数函数，如：

\src{snippet05}
严格来说，两个变量的函数是一个接受一个对（一个乘积类型）的函数：

\src{snippet06}
在这两种表示之间进行转换是微不足道的，并且执行这些转换的两个高阶函数被称为\code{curry} 和 \code{uncurry}：

\src{snippet07}
以及

\src{snippet08}
请注意，\code{curry} 是普遍构造的因式分解器。这一点在它以这种形式重写时尤其明显：

\src{snippet09}
（作为提醒：因式分解器从候选者中生成因式分解函数。）

在非函数式语言（如 C++）中，柯里化是可能的，但并不简单。你可以将 C++ 中的多参数函数视为对应于 Haskell 中接受元组的函数（尽管在 C++ 中你可以定义接受显式 \code{std::tuple} 的函数、可变参数函数以及接受初始化列表的函数，从而使情况变得更加混乱）。

你可以使用模板 \code{std::bind} 部分应用一个 C++ 函数。例如，给定一个有两个字符串参数的函数：

\begin{snip}{cpp}
  std::string catstr(std::string s1, std::string s2) {
    return s1 + s2;
  }
\end{snip}
你可以定义一个接受一个字符串参数的函数：

\begin{snip}{cpp}
  using namespace std::placeholders;

  auto greet = std::bind(catstr, "Hello ", _1);
  std::cout << greet("Haskell Curry");
\end{snip}
Scala 比 C++ 或 Java 更具函数性，处于中间位置。如果你预见到你定义的函数将被部分应用，你可以使用多个参数列表来定义它：

\begin{snip}{cpp}
  def catstr(s1: String)(s2: String) = s1 + s2
\end{snip}
当然，这需要库编写者具有一定的预见性或预知能力。

\section{指数对象}

在数学文献中，函数对象或两个对象 $a$ 和 $b$ 之间的内部同态对象通常被称为\newterm{指数对象}，表示为 $b^{a}$。注意参数类型在指数上。这个表示法乍一看可能有些奇怪，但如果你考虑到函数与乘积之间的关系，它就非常合乎逻辑。我们已经看到，在内部同态对象的泛在构造中我们必须使用乘积，但这种联系远不止于此。

这在考虑有限类型之间的函数时最为明显——有限类型是具有有限数量值的类型，如 \code{Bool}、\code{Char} 甚至 \code{Int} 或 \code{Double}。这样的函数，至少在原则上，可以完全备忘化或转换为可查阅的数据结构。这正是函数（态射）与函数类型（对象）之间等价性的本质。

例如，一个从 \code{Bool} 到 \code{Int} 的纯函数完全由一对值（分别对应于 \code{False} 和 \code{True}）指定。从 \code{Bool} 到 \code{Int} 的所有可能函数的集合等同于 \code{Int} 的所有对的集合。这与乘积 \code{Int} \times{} \code{Int} 是一样的，或者稍微创造性地使用符号表示为 \code{Int}\textsuperscript{2}。

再举一个例子，让我们看看 C++ 类型 \code{char}，它包含 256 个值（Haskell 的 \code{Char} 更大，因为 Haskell 使用 Unicode）。C++ 标准库的一些函数通常使用查找表实现，如 \code{isupper} 或 \code{isspace}，这些函数使用的表等价于 256 个布尔值的元组。一个元组是一个乘积类型，所以我们正在处理 256 个布尔值的乘积：\code{bool \times{} bool \times{} bool \times{} ... \times{} bool}。我们从算术中知道，迭代的乘积定义了幂。如果你将 \code{bool} 自乘 256（或 \code{char}）次，你就得到了 \code{bool} 的 \code{char} 次幂，或 \code{bool}\textsuperscript{\code{char}}。

在定义为 256 元组 \code{bool} 的类型中有多少值？恰好是 $2^{256}$。这也是从 \code{char} 到 \code{bool} 的不同函数的数量，每个函数对应于一个唯一的 256 元组。你可以类似地计算，从 \code{bool} 到 \code{char} 的函数的数量是 $256^{2}$，等等。在这些情况下，函数类型的指数表示法非常合理。

我们可能不希望完全备忘从 \code{int} 或 \code{double} 到其他类型的函数。但函数与数据类型之间的等价性，虽然不总是实用，但确实存在。还有无限类型，例如列表、字符串或树。急切地备忘从这些类型到其他类型的函数将需要无限存储。但 Haskell 是一门惰性语言，所以懒惰计算的（无限）数据结构与函数之间的边界是模糊的。这种函数与数据的二元性解释了 Haskell 的函数类型与范畴指数对象的识别——这更符合我们对\emph{数据}的概念。

\section{笛卡尔闭范畴}

虽然我将继续使用集合范畴作为类型和函数的模型，但值得一提的是，有一个更大的范畴家族可以用于该目的。这些范畴被称为\newterm{笛卡尔闭}，而 $\Set$ 只是其中的一个例子。

一个笛卡尔闭范畴必须包含：

\begin{enumerate}
  \tightlist
  \item
  终对象，
  \item
  任意一对对象的乘积，以及
  \item
  任意一对对象的指数对象。
\end{enumerate}
如果你将指数视为迭代乘积（可能是无限多次），那么你可以将笛卡尔闭范畴视为支持任意参数乘积的范畴。特别地，终对象可以视为零个对象的乘积——或对象的零次幂。

从计算机科学的角度来看，笛卡尔闭范畴的有趣之处在于它们为简单类型λ演算提供了模型，而简单类型λ演算是所有类型化编程语言的基础。

终对象和乘积有它们的对偶：初对象和余积。一个笛卡尔闭范畴如果也支持这两个，并且在其中乘积可以分布到余积上
\begin{gather*}
  a \times (b + c) = a \times b + a \times c \\
  (b + c) \times a = b \times a + c \times a
\end{gather*}
就被称为一个\newterm{双笛卡尔闭}范畴。我们将在下一节看到，双笛卡尔闭范畴（其中 $\Set$ 是一个主要例子）具有一些有趣的特性。

\section{指数对象与代数数据类型}

将函数类型解释为指数对象非常适合代数数据类型的方案。事实证明，所有高中代数中关于数字 0 和 1、和、乘积以及指数的基本恒等式在任何双笛卡尔闭范畴中，对于分别的初对象和终对象、余积、乘积和指数，几乎保持不变。我们还没有足够的工具来证明它们（如伴随函子或约内达引理），但我还是会在此列出它们，以作为宝贵的直觉来源。

\subsection{零次幂}

\[a^{0} = 1\]
在范畴解释中，我们将 0 替换为初对象，将 1 替换为终对象，将等号替换为同构。指数对象是内部同态对象。这个特定的指数对象表示从初对象到任意对象 $a$ 的态射集。根据初对象的定义，只有一个这样的态射，因此同态集 $\cat{C}(0, a)$ 是一个单元素集。在集合范畴 $\Set$ 中，一个单元素集就是终对象，因此这个恒等式在 $\Set$ 中是显然成立的。我们所说的是，它在任何双笛卡尔闭范畴中都成立。

在 Haskell 中，我们用 \code{Void} 替换 0，用单位类型 \code{()} 替换 1，并用函数类型替换指数对象。这个主张是，从 \code{Void} 到任意类型 \code{a} 的函数集等价于单位类型——这是一个单元素集。换句话说，只有一个函数 \code{Void -> a}。我们之前见过这个函数：它叫做 \code{absurd}。

这有点棘手，原因有两个。一个原因是在 Haskell 中，我们实际上没有未被占用的类型——每个类型都包含“永不终结的计算结果”或底层值。第二个原因是，所有 \code{absurd} 实现是等价的，因为无论它们做什么，都没有人可以执行它们。没有值可以传递给 \code{absurd}。（如果你设法传递给它一个永无止境的计算，它将永远不会返回！）

\subsection{一的幂}

\[1^{a} = 1\]
这个恒等式在集合范畴 $\Set$ 中重申了终对象的定义：从任何对象到终对象都有一个唯一的态射。一般来说，从 $a$ 到终对象的内部同态对象同构于终对象本身。

在 Haskell 中，从任何类型 \code{a} 到单位类型只有一个函数。我们之前见过这个函数——它叫做 \code{unit}。你也可以将其视为函数 \code{const} 部分应用于 \code{()}。

\subsection{一次幂}

\[a^{1} = a\]
这是对从终对象的态射可以用来选择对象 \code{a} 的“元素”的观察的重述。从终对象到 \code{a} 的态射集与对象本身同构。在集合范畴 $\Set$ 和 Haskell 中，这种同构关系存在于集合 \code{a} 的元素与选择这些元素的函数 \code{() -> a} 之间。

\subsection{和的指数}

\[a^{b+c} = a^{b} \times a^{c}\]
从范畴的角度来看，这意味着从两个对象的余积到另一个对象的指数同构于两个指数的乘积。在 Haskell 中，这个代数恒等式有一个非常实际的解释。它告诉我们，从两个类型的和到另一个类型的函数等价于从每个单独类型到该类型的两个函数。这正是我们在定义关于和的函数时使用的情况分析。我们通常将一个函数定义拆分为两个（或更多）函数，分别处理每个类型构造子，而不是编写一个带有 \code{case} 语句的函数定义。例如，从和类型 \code{(Either Int Double)} 到另一个类型的函数：

\src{snippet10}
它可以定义为一对从 \code{Int} 和 \code{Double} 到目标类型的函数：

\src{snippet11}
这里，\code{n} 是 \code{Int} 类型，\code{x} 是 \code{Double} 类型。

\subsection{指数的指数}

\[(a^{b})^{c} = a^{b \times c}\]
这是纯粹用指数对象表示柯里化的一种方式。一个返回函数的函数等价于一个从乘积（两个参数的函数）到目标类型的函数。

\subsection{乘积的指数}

\[(a \times b)^{c} = a^{c} \times b^{c}\]
在 Haskell 中：一个返回对的函数等价于一对函数，每个函数产生该对的一个元素。

令人惊讶的是，这些简单的高中代数恒等式可以提升到范畴理论，并在函数式编程中有实际应用。

\section{柯里-霍华德同构}

我已经提到过逻辑与代数数据类型之间的对应关系。类型 \code{Void} 和单位类型 \code{()} 分别对应于假和真。乘积类型和和类型分别对应于逻辑合取（$\wedge$）和析取（$\vee$）。在这个方案中，我们刚刚定义的函数类型对应于逻辑蕴涵（$\Rightarrow$）。换句话说，类型 \code{a -> b} 可以解读为“如果 a 则 b”。

根据柯里-霍华德同构，每个类型都可以被解释为一个命题——一个可能为真或假的陈述或判断。这样的命题被认为是成立的，如果该类型有元素占据；否则认为是不成立的。特别地，一个逻辑蕴涵是成立的，如果对应的函数类型有元素占据，这意味着存在这样的一个函数。因此，函数的实现是一个定理的证明。编写程序等价于证明定理。让我们看看几个例子。

让我们来看一下我们在定义函数对象时引入的函数 \code{eval}。它的签名是：

\src{snippet12}
它接受一个包含一个函数及其参数的对，并生成相应类型的结果。这是 Haskell 实现的态射：

\[\mathit{eval} \Colon (a \Rightarrow b) \times a \to b\]
该态射定义了函数类型 $a \Rightarrow b$（或指数对象 $b^{a}$）。让我们使用柯里-霍华德同构将该签名翻译为一个逻辑谓词：

\[((a \Rightarrow b) \wedge a) \Rightarrow b\]
你可以这样解读这个命题：如果 $b$ 由 $a$ 推出，并且 $a$ 是真的，那么 $b$ 必须是真的。这非常直观并且自古以来就为人所知，称为\newterm{演绎法则}（modus ponens）。我们可以通过实现函数来证明这一定理：

\src{snippet13}
如果你给我一个包含一个函数 \code{f}（它接受 \code{a} 并返回 \code{b}）和一个类型为 \code{a} 的具体值 \code{x} 的对，我可以通过简单地将函数 \code{f} 应用于 \code{x} 来生成一个类型为 \code{b} 的具体值。通过实现这个函数，我刚刚展示了类型 \code{((a -> b), a) -> b} 是被占据的。因此，在我们的逻辑中，\newterm{演绎法则} 是成立的。

那么，一个明显错误的命题呢？例如：如果 $a$ 或 $b$ 是真的，那么 $a$ 必须是真的。

\[a \vee b \Rightarrow a\]
这显然是错误的，因为你可以选择一个为假的 $a$ 和一个为真的 $b$，这就是一个反例。

使用柯里-霍华德同构将这个命题映射到一个函数签名中，我们得到：

\src{snippet14}
无论你怎么尝试，你都无法实现这个函数——如果你被传递了 \code{Right} 值，你就无法生成一个类型为 \code{a} 的值。（请记住，我们谈论的是\emph{纯}函数。）

最后，我们来看看 \code{absurd} 函数的含义：

\src{snippet15}
考虑到 \code{Void} 转换为假，我们得到：

\[\mathit{false} \Rightarrow a\]
任何东西都可以从谬误中推导出来（\emph{ex falso quodlibet}）。以下是这个命题（函数）在 Haskell 中的一个可能的证明（实现）：

\begin{snip}{haskell}
  absurd (Void a) = absurd a
\end{snip}
其中 \code{Void} 定义为：

\begin{snip}{haskell}
  newtype Void = Void Void
\end{snip}
如往常一样，\code{Void} 类型是棘手的。这个定义使得它无法构造出一个值，因为为了构造一个值，你需要先提供一个值。因此，函数 \code{absurd} 永远无法被调用。

这些都是有趣的例子，但柯里-霍华德同构在实际编程中是否有实用的一面？可能在日常编程中并不多见。但确实有一些编程语言如 Agda 或 Coq，利用柯里-霍华德同构来证明定理。

计算机不仅帮助数学家完成他们的工作——它们正在彻底改变数学的基础。该领域最新的热门研究主题称为同伦类型论，这是类型论的一个分支。它充满了布尔值、整数、乘积和余积、函数类型等等。而且，为了消除任何怀疑，该理论正在 Coq 和 Agda 中被公式化。计算机正在以多种方式改变世界。

\section{参考文献}

\begin{enumerate}
  \tightlist
  \item
  Ralph Hinze, Daniel W. H. James,
  \urlref{http://www.cs.ox.ac.uk/ralf.hinze/publications/WGP10.pdf}{Reason
  Isomorphically!}. 这篇论文包含了我在本章中提到的所有那些高中代数恒等式在范畴论中的证明。
\end{enumerate}
