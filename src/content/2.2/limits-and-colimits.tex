% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{看}{起来在范畴论中}，一切都与一切相关，所有事物都可以从多角度进行观察。以 \hyperref[products-and-coproducts]{积} 的普遍构造为例。现在我们对 \hyperref[functors]{函子} 和 \hyperref[natural-transformations]{自然变换} 有了更多了解，我们能简化并可能推广它吗？让我们试试看。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/productpattern.jpg}
\end{figure}

\noindent
积的构造从选择两个对象 $a$ 和 $b$ 开始，这两个对象是我们希望构造其积的对象。但是，\emph{选择对象} 意味着什么？我们能否用更范畴化的术语来重新表达这一操作？两个对象形成一个模式——一个非常简单的模式。我们可以将这个模式抽象为一个范畴——一个非常简单的范畴，但仍然是一个范畴。我们称之为 $\cat{2}$。它只包含两个对象，$1$ 和 $2$，没有其他态射，只有两个必需的恒等态射。现在，我们可以将选择 $\cat{C}$ 中的两个对象重新表述为从范畴 $\cat{2}$ 到 $\cat{C}$ 的函子 $D$ 的定义。一个函子将对象映射到对象，因此它的像只是两个对象（或者如果函子合并对象，这也是可以的）。它还映射态射——在这种情况下，它只是将恒等态射映射到恒等态射。

这种方法的伟大之处在于，它建立在范畴概念之上，避开了像“选择对象”这样从我们祖先的猎人-采集者词汇中直接借用的模糊描述。而且，顺便说一句，它也很容易推广，因为没有什么能阻止我们使用比 $\cat{2}$ 更复杂的范畴来定义我们的模式。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/two.jpg}
\end{figure}

\noindent
但让我们继续。积定义的下一步是选择候选对象 $c$。在这里，我们可以再次用单一对象范畴的函子来重新表述选择的操作。实际上，如果我们在使用 Kan 扩展，那将是正确的做法。但由于我们还没有准备好 Kan 扩展，我们可以使用另一种技巧：从相同的范畴 $\cat{2}$ 到 $\cat{C}$ 的常值函子 $\Delta$。在 $\cat{C}$ 中选择 $c$ 可以通过 $\Delta_c$ 来完成。记住，$\Delta_c$ 将所有对象映射到 $c$，并将所有态射映射到 $\idarrow[c]$。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/twodelta.jpg}
\end{figure}

\noindent
现在我们有了两个函子，$\Delta_c$ 和 $D$，它们都在 $\cat{2}$ 和 $\cat{C}$ 之间，所以自然要问它们之间是否存在自然变换。由于 $\cat{2}$ 中只有两个对象，自然变换将有两个分量。$\cat{2}$ 中的对象 $1$ 由 $\Delta_c$ 映射到 $c$，由 $D$ 映射到 $a$。因此，$\Delta_c$ 和 $D$ 之间的自然变换在 $1$ 处的分量是一个从 $c$ 到 $a$ 的态射。我们可以称之为 $p$。同样，第二个分量是从 $c$ 到 $b$ 的态射——即 $\cat{2}$ 中对象 $2$ 在 $D$ 下的像。但这些与我们在最初的积定义中使用的两个投影完全相同。所以与其谈论选择对象和投影，我们可以只谈论选择函子和自然变换。在这个简单的情况下，自然变换的自然性条件是平凡的，因为在 $\cat{2}$ 中没有态射（除恒等态射外）。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/productcone.jpg}
\end{figure}

\noindent
这种构造的一般化可以扩展到其他比 $\cat{2}$ 更复杂的范畴——例如，包含非平凡态射的范畴。这将对 $\Delta_c$ 和 $D$ 之间的变换施加自然性条件。我们称这种变换为 \emph{锥}，因为 $\Delta$ 的像是锥/金字塔的顶点，其侧面由自然变换的分量构成。$D$ 的像构成了锥的底部。

一般来说，构建一个锥，我们从一个定义模式的范畴 $\cat{I}$ 开始。它是一个小的，通常是有限的范畴。我们选择一个从 $\cat{I}$ 到 $\cat{C}$ 的函子 $D$，并称其为（或其像）一个 \emph{图}。我们在 $\cat{C}$ 中选择某个 $c$ 作为我们锥的顶点。我们用它来定义从 $\cat{I}$ 到 $\cat{C}$ 的常值函子 $\Delta_c$。从 $\Delta_c$ 到 $D$ 的自然变换就是我们的锥。对于有限的 $\cat{I}$，它只是连接 $c$ 和图（$\cat{I}$ 在 $D$ 下的像）的态射的集合。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/cone.jpg}
\end{figure}

\noindent
自然性要求该图中的所有三角形（即金字塔的墙面）都交换。确实，取 $\cat{I}$ 中的任意态射 $f$。函子 $D$ 将其映射到 $\cat{C}$ 中的态射 $D f$，这条态射构成了某个三角形的底边。常值函子 $\Delta_c$ 将 $f$ 映射到 $c$ 上的恒等态射。$\Delta$ 将态射的两个端点压缩成一个对象，自然性方块变成了一个交换三角形。该三角形的两个边是自然变换的分量。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/conenaturality.jpg}
\end{figure}

\noindent
所以这是一个锥。我们感兴趣的是 \newterm{普遍锥} ——就像我们在定义积时选择了一个普遍对象一样。

有很多方法可以实现它。例如，我们可以基于给定的函子 $D$ 定义一个 \emph{锥的范畴}。该范畴中的对象是锥。然而，并不是 $\cat{C}$ 中的每个对象 $c$ 都可以作为一个锥的顶点，因为可能不存在 $\Delta_c$ 和 $D$ 之间的自然变换。

要构成一个范畴，我们还必须定义锥之间的态射。这些将完全由它们的顶点之间的态射决定。但并不是任何态射都可以。记住，在我们构造积时，我们规定候选对象（顶点）之间的态射必须是投影的公因子。例如：

\src{snippet01}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/productranking.jpg}
\end{figure}

这一条件在一般情况下转化为这样的条件：三角形的一边是因式分解态射的因子，它们都交换。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/conecommutativity.jpg}
  \caption{连接两个锥的交换三角形，其中因式分解态射为 $h$（此处，下锥为普遍锥，顶点为 $\Lim[D]$）}
\end{figure}

\noindent
我们将这些因式分解态射作为锥范畴中的态射。很容易验证这些态射确实可以组合，并且恒等态射也是因式分解态射。因此锥形成了一个范畴。

现在我们可以将普遍锥定义为锥范畴中的 \emph{终对象}。终对象的定义表明，从任何其他对象到该对象都有一个唯一的态射。在我们的情况下，这意味着从任何其他锥的顶点到普遍锥的顶点都有一个唯一的因式分解态射。我们将此普遍锥称为图 $D$ 的 \emph{极限}，记为 $\Lim[D]$（在文献中，你会经常看到 $\Lim$ 符号下方指向 $I$ 的左箭头）。通常，作为简写，我们称该锥的顶点为极限（或极限对象）。

直觉上，极限在一个对象中体现了整个图的性质。例如，我们的两个对象图的极限就是两个对象的积。积（连同两个投影）包含了关于这两个对象的信息。作为普遍的对象，它没有多余的部分。

\section{作为自然同构的极限}

关于极限的这一定义，仍有一些不尽如人意的地方。我的意思是，它是可行的，但我们仍然有关于链接任何两个锥的三角形的交换性条件。如果我们能够用某种自然性条件来替换它，那将是多么优雅。但该怎么做呢？

我们不再仅仅处理一个锥，而是处理一个整合集合（实际上是一个范畴）的锥。如果极限存在（让我们明确一点，这没有任何保证），其中一个锥就是普遍锥。对于每一个其他锥，我们都有一个唯一的因式分解态射将其顶点（我们称之为 $c$）映射到普遍锥的顶点，我们称之为 $\Lim[D]$。（实际上，我可以省略“其他”这个词，因为恒等态射将普遍锥映射到自身，并且它可以通过自身平凡地因式分解。）让我重复一下重要部分：给定任何锥，都有一种特殊类型的唯一态射。我们有一个从锥到特殊态射的一对一映射。

这个特殊态射是 $\cat{C}(c, \Lim[D])$ 中的一个元素。这个同态集的其他元素不那么幸运，因为它们不能因式分解两个锥的映射。我们想要的是能够为每个 $c$ 从集合 $\cat{C}(c, \Lim[D])$ 中选择一个态射——满足特定交换性条件的态射。这听起来像是在定义自然变换吗？的确如此！

但是什么函子与此变换有关呢？

一个函子是将 $c$ 映射到集合 $\cat{C}(c, \Lim[D])$。这是一个从 $\cat{C}$ 到 $\Set$ 的函子——它将对象映射到集合。实际上，它是一个反变函子。以下是我们定义它对态射的作用的方法：假设我们有一个从 $c'$ 到 $c$ 的态射 $f$：
\[f \Colon c' \to c\]
我们的函子将 $c'$ 映射到集合 $\cat{C}(c', \Lim[D])$。为了定义该函子对 $f$ 的作用（换句话说，提升 $f$），我们必须定义 $\cat{C}(c, \Lim[D])$ 和 $\cat{C}(c', \Lim[D])$ 之间相应的映射。假设我们选择 $\cat{C}(c, \Lim[D])$ 的一个元素 $u$，看看我们是否可以将其映射到 $\cat{C}(c', \Lim[D])$ 的某个元素。一个同态集的元素是一个态射，因此我们有：
\[u \Colon c \to \Lim[D]\]
我们可以将 $u$ 和 $f$ 进行预组合得到：
\[u \circ f \Colon c' \to \Lim[D]\]
这就是 $\cat{C}(c', \Lim[D])$ 的一个元素——所以确实，我们找到了态射的一个映射：

\src{snippet02}
注意 $c$ 和 $c'$ 的顺序颠倒了，这正是 \emph{反变} 函子的特征。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/homsetmapping.jpg}
\end{figure}

\noindent
为了定义自然变换，我们需要另一个从 $\cat{C}$ 到 $\Set$ 的函子。但这次我们考虑的是一组锥。锥只是自然变换，因此我们关注的是自然变换集 $\mathit{Nat}(\Delta_c, D)$。将 $c$ 映射到这一特定自然变换集的映射是一个（反变）函子。我们如何证明这一点呢？再次，我们定义其对态射的作用：
\[f \Colon c' \to c\]
对 $f$ 的提升应该是一个自然变换之间的映射，这两个函子从 $\cat{I}$ 到 $\cat{C}$：
\[\mathit{Nat}(\Delta_c, D) \to \mathit{Nat}(\Delta_{c'}, D)\]
我们如何映射自然变换呢？每个自然变换都是态射的选择——它的分量，每个 $\cat{I}$ 的元素有一个态射。某个 $\alpha$（$\mathit{Nat}(\Delta_c, D)$ 的一个成员）在 $a$（$\cat{I}$ 中的一个对象）的分量是一个态射：
\[\alpha_a \Colon \Delta_c a \to D a\]
或者使用常值函子 $\Delta$ 的定义，
\[\alpha_a \Colon c \to D a\]
给定 $f$ 和 $\alpha$，我们必须构造一个 $\beta$，$\mathit{Nat}(\Delta_{c'}, D)$ 的成员。它在 $a$ 处的分量应该是一个态射：
\[\beta_a \Colon c' \to D a\]
我们可以通过与 $f$ 预组合来轻松地从前者（$\alpha_a$）得到后者（$\beta_a$）：
\[\beta_a = \alpha_a \circ f\]
很容易证明这些分量确实构成了一个自然变换。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/natmapping.jpg}
\end{figure}

\noindent
给定我们的态射 $f$，我们就这样逐个分量地构建了两个自然变换之间的映射。此映射定义了函子的 \code{contramap}：
\[c \to \mathit{Nat}(\Delta_c, D)\]
我刚才做的是向你展示我们有两个从 $\cat{C}$ 到 $\Set$ 的（反变）函子。我没有做任何假设——这些函子总是存在的。

顺便说一下，第一个函子在范畴论中起着重要作用，当我们谈到 Yoneda 引理时，我们会再次看到它。任何从范畴 $\cat{C}$ 到 $\Set$ 的反变函子都有一个名称：它们被称为“预层”。而这个被称为 \newterm{表示预层}。第二个函子也是一个预层。

现在我们有了两个函子，我们可以谈论它们之间的自然变换。所以不再赘述，结论如下：从 $\cat{I}$ 到 $\cat{C}$ 的函子 $D$ 只有在存在两个我刚刚定义的函子之间的自然同构时才有极限：
\[\cat{C}(c, \Lim[D]) \simeq \mathit{Nat}(\Delta_c, D)\]
让我提醒你什么是自然同构。它是一个自然变换，其每个分量都是一个同构态射，也就是说是一个可逆态射。

我不会详细讨论这一声明的证明过程。这个过程相当直接，但有点繁琐。当处理自然变换时，通常关注的是态射的分量。在这种情况下，由于两个函子的目标都是 $\Set$，自然同构的分量将是函数。这些是高阶函数，因为它们从同态集映射到自然变换集。同样，你可以通过考虑函数对其参数的操作来分析一个函数：在这里，参数将是一个态射——$\cat{C}(c, \Lim[D])$ 的成员——结果将是一个自然变换——$\mathit{Nat}(\Delta_c, D)$ 的成员，或我们称之为锥的东西。这个自然变换依次有其自己的分量，这些分量也是态射。因此，自始至终都是态射，如果你能跟踪它们，你就可以证明这一声明。

最重要的结果是，此同构的自然性条件恰好是锥映射的交换性条件。

作为即将到来的预告，让我提到，$\mathit{Nat}(\Delta_c, D)$ 集可以看作是函子范畴中的同态集；所以我们的自然同构关系着两个同态集，这指向了一个更普遍的关系，称为伴随。

\section{极限的示例}

我们已经看到，范畴积是由我们称为 $\cat{2}$ 的简单范畴生成的图的极限。

有一个更简单的极限示例：终对象。第一个冲动可能是认为单一对象范畴会导致终对象，但事实甚至比这更简洁：终对象是由空范畴生成的极限。从空范畴到某个范畴的函子不选择任何对象，因此锥缩小为仅顶点的情况。普遍锥是唯一具有从任何其他顶点到它的唯一态射的顶点。你会认出这是终对象的定义。

下一个有趣的极限称为 \emph{等化子}。它是由一个两元素范畴生成的极限，该范畴中有两个平行的态射在它们之间（以及总是存在的恒等态射）。这个范畴选择了 $\cat{C}$ 中由两个对象 $a$ 和 $b$ 以及两个态射组成的图：

\src{snippet03}

要在此图之上构建一个锥，我们必须添加顶点 $c$ 和两个投影：

\src{snippet04}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/equalizercone.jpg}
  \endfigure}

\noindent
我们有两个必须交换的三角形：

\src{snippet05}

这告诉我们，$q$ 由这些方程中的一个唯一决定，比如 \code{q = f . p}，我们可以省略它。因此我们只剩下一个条件：

\src{snippet06}

想法是，如果我们将注意力集中在 $\Set$ 上，函数 $p$ 的像选择了 $a$ 的一个子集。当限制在该子集上时，函数 $f$ 和 $g$ 是相等的。

例如，假设 $a$ 是由坐标 $x$ 和 $y$ 参数化的二维平面。$b$ 是实数线，并且：

\src{snippet07}

这两个函数的等化子是实数集（顶点 $c$）和函数：

\src{snippet08}

注意 $(p~t)$ 定义了二维平面中的一条直线。沿着这条直线，这两个函数是相等的。

当然，还有其他的集合 $c'$ 和函数 $p'$ 可能会导致相等：

\src{snippet09}

但它们都唯一地因式分解通过 $p$。例如，我们可以将单元素集 $\cat{()}$ 作为 $c'$，并选择函数：

\src{snippet10}

这是一个很好的锥，因为 $f (0, 0) = g (0, 0)$。但它不是普遍的，因为它通过 $h$ 唯一因式分解：

\src{snippet11}

其中

\src{snippet12}

\begin{figure}[H]
\centering
\includegraphics[width=0.35\textwidth]{images/equilizerlimit.jpg}
\endfigure}

\noindent
因此，等化子可用于解决 $f~x = g~x$ 类型的方程。但它更为一般，因为它是用对象和态射定义的，而不是代数地定义的。

解决方程的一个更一般的想法体现在另一种极限——拉回。这里，我们仍然有两个想要等式化的态射，但这次它们的定义域不同。我们从一个形状为 $1\rightarrow2\leftarrow3$ 的三对象范畴开始。此范畴对应的图由三个对象 $a$、$b$ 和 $c$ 以及两个态射组成：

\src{snippet13}

此图通常称为 \emph{余弦图}。

在此图之上构建的锥由顶点 $d$ 和三个态射组成：

\src{snippet14}

\begin{figure}[H]
\centering
\includegraphics[width=0.35\textwidth]{images/pullbackcone.jpg}
\endfigure}

\noindent
交换性条件告诉我们 $r$ 是完全由其他态射决定的，因此可以从图中省略。所以我们只剩下以下条件：

\src{snippet15}

拉回是这种形状的普遍锥。

\begin{figure}[H]
\centering
\includegraphics[width=0.35\textwidth]{images/pullbacklimit.jpg}
\endfigure}

\noindent
再次，如果你将焦点缩小到集合，可以认为对象 $d$ 由一对来自 $a$ 和 $c$ 的元素组成，其中第一个分量上的 $f$ 等于第二个分量上的 $g$。如果这仍然太过一般，考虑一个特殊情况，其中 $g$ 是常函数，比如 $g~\_ = 1.23$（假设 $b$ 是实数集）。那么你实际上是在解决方程：

\src{snippet16}

在这种情况下，$c$ 的选择无关紧要（只要它不是一个空集），所以我们可以将其视为一个单元素集。集合 $a$ 可以是三维向量的集合，$f$ 是向量的长度。然后拉回是对 $(v, ())$ 的集合，其中 $v$ 是长度为 1.23 的向量（$\sqrt{(x^{2}+y^{2}+z^{2})} = 1.23$ 的解），$()$ 是单元素集的虚拟元素。

但拉回在编程中有更广泛的应用。例如，将 C++ 类视为一个范畴，其中态射是将子类连接到超类的箭头。我们将继承视为一种传递性属性，所以如果 \code{C} 继承自 \code{B}，并且 \code{B} 继承自 \code{A}，那么我们会说 \code{C} 继承自 \code{A}（毕竟，你可以在需要指向 \code{A} 的地方传递指向 \code{C} 的指针）。此外，我们将假设 \code{C} 继承自 \code{C}，因此我们为每个类设置了恒等箭头。通过这种方式，子类化与子类型化对齐。C++ 还支持多重继承，因此你可以构建一个菱形继承图，其中两个类 \code{B} 和 \code{C} 继承自 \code{A}，第四个类 \code{D} 多重继承自 \code{B} 和 \code{C}。通常情况下，\code{D} 会有两个 \code{A} 的副本，这通常不是我们想要的；但你可以使用虚拟继承，在 \code{D} 中只有一个 \code{A} 的副本。

在这种图中，\code{D} 是一个拉回意味着什么？这意味着从 \code{B} 和 \code{C} 多重继承的任何类 \code{E} 也是 \code{D} 的子类。这在 C++ 中并不能直接表达，因为子类型化是名义上的（C++ 编译器不会推断这种类关系——它需要“鸭子类型”）。但我们可以超越子类型化关系，改为询问从 \code{E} 到 \code{D} 的转换是否安全。如果 \code{D} 是 \code{B} 和 \code{C} 的裸骨组合，没有额外的数据和方法重载，那么这个转换就是安全的。当然，如果 \code{B} 和 \code{C} 的某些方法存在名称冲突，那么就不会有拉回。

\begin{figure}[H]
\centering
\includegraphics[width=0.25\textwidth]{images/classes.jpg}
\endfigure}

\noindent
在类型推断中还有一个更高级的拉回用法。通常需要\emph{统一}两个表达式的类型。例如，假设编译器想要推断函数的类型：

\begin{snip}{haskell}
twice f x = f (f x)
\end{snip}
它会给所有变量和子表达式分配初步类型。特别是，它将分配：

\begin{snip}{haskell}
f       :: t0
x       :: t1
f x     :: t2
f (f x) :: t3
\end{snip}
由此推导出：

\begin{snip}{haskell}
twice :: t0 -> t1 -> t3
\end{snip}
它还会生成一组由函数应用规则产生的约束：

\begin{snip}{haskell}
t0 = t1 -> t2 -- 因为 f 应用于 x
t0 = t2 -> t3 -- 因为 f 应用于 (f x)
\end{snip}
这些约束必须通过找到一组类型（或类型变量）来统一，这些类型在代入两个表达式中的未知类型时会产生相同的类型。一个这样的代入是：

\begin{snip}{haskell}
t1 = t2 = t3 = Int
twice :: (Int -> Int) -> Int -> Int
\end{snip}
但显然，这不是最一般的。最一般的代入是通过拉回获得的。我不会详细讨论其细节，因为它们超出了本书的范围，但你可以相信，结果应该是：

\begin{snip}{haskell}
twice :: (t -> t) -> t -> t
\end{snip}
其中 \code{t} 是一个自由类型变量。

\section{余极限}

就像范畴论中的所有构造一样，极限在对偶范畴中有其对偶图像。当你反转锥中的所有箭头方向时，你得到一个余锥，而这些锥的普遍锥称为余极限。注意，反转也会影响因式分解态射，现在它从普遍余锥流向任何其他余锥。

\begin{figure}[H]
\centering
\includegraphics[width=0.35\textwidth]{images/colimit.jpg}
\caption{一个余锥及连接两个顶点的因式分解态射 $h$。}
\endfigure}

\noindent
余积对应于由 $\cat{2}$ 生成的图，是余极限的典型示例，这是我们在定义积时使用的范畴。

\begin{figure}[H]
\centering
\includegraphics[width=0.35\textwidth]{images/coproductranking.jpg}
\endfigure}

\noindent
积和余积都体现了一对对象的本质，但每种方式不同。

就像终对象是极限一样，初对象是基于空范畴的图的余极限。

拉回的对偶称为 \emph{推送}。它基于一个图，称为跨越图，由范畴 $1\leftarrow2\rightarrow3$ 生成。

\section{连续性}

我之前说过，函子非常接近连续映射范畴的思想，因为它们永远不会破坏现有的连接（态射）。实际上，从范畴 $\cat{C}$ 到 $\cat{C'}$ 的 \emph{连续函子} $F$ 的定义包括函子保留极限的要求。$\cat{C}$ 中的任意图 $D$ 可以通过简单地组合两个函子映射到 $\cat{C'}$ 中的图 $F \circ D$。$F$ 的连续性条件规定，如果图 $D$ 有一个极限 $\Lim[D]$，则图 $F \circ D$ 也有一个极限，并且它等于 $F (\Lim[D])$。

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{images/continuity.jpg}
\endfigure}

\noindent
注意，由于函子将态射映射到态射，并将组合映射到组合，因此锥的像始终是一个锥。交换三角形总是被映射为交换三角形（函子保留组合）。对于因式分解态射也是如此：因式分解态射的像也是因式分解态射。因此，每个函子都\emph{几乎}是连续的。可能出现的问题是唯一性条件。$\cat{C'}$ 中的因式分解态射可能不是唯一的。在 $\cat{C}$ 中可能没有其他“更好的锥”。

同态函子是连续函子的一个例子。回想一下，同态函子 $\cat{C}(a, b)$ 在第一个变量中是反变的，而在第二个变量中是协变的。换句话说，这是一个函子：
\[\cat{C}^\mathit{op} \times \cat{C} \to \Set\]
当其第二个参数固定时，同态集函子（它成为表示预层）将 $\cat{C}$ 中的余极限映射到 $\Set$ 中的极限；当其第一个参数固定时，它将极限映射到极限。

在 Haskell 中，同态函子是将任意两个类型映射到一个函数类型的映射，因此它只是一个参数化的函数类型。当我们将第二个参数固定时，例如固定为 \code{String}，我们得到反变函子：

\src{snippet17}
连续性意味着当 \code{ToString} 应用于余极限（例如一个余积 \code{Either b c}）时，它将生成一个极限；在本例中，是两个函数类型的积：

\src{snippet18}
确实，任何 \code{Either b c} 的函数都实现为一个 case 语句，该语句由一对函数服务两个情况。

同样，当我们固定同态集的第一个参数时，我们得到熟悉的 reader 函子。其连续性意味着例如任何返回积的函数都等价于函数的积；特别是：

\src{snippet19}
我知道你在想什么：你不需要范畴论就能弄清楚这些东西。你是对的！然而，我仍然感到惊讶的是，这样的结果可以从第一个原则推导出来，而无需借助比特与字节、处理器架构、编译器技术，甚至 lambda 演算。

如果你对“极限”和“连续性”这些名称的来源感到好奇，它们是从微积分中相应概念推广而来的。在微积分中，极限和连续性是用开邻域定义的。开集定义了拓扑，形成一个范畴（一个偏序集）。

\section{挑战}

\begin{enumerate}
\tightlist
\item
你如何在 C++ 类范畴中描述推送？
\item
证明恒等函子 $\mathbf{Id} \Colon \cat{C} \to \cat{C}$ 的极限是初对象。
\item
给定集合的子集形成一个范畴。在该范畴中，如果第一个子集是第二个子集的子集，则定义为一个箭头。这样的范畴中两个集合的拉回是什么？推送是什么？初对象和终对象是什么？
\item
你能猜到等化子的对偶是什么吗？
\item
证明在具有终对象的范畴中，指向终对象的拉回是积。
\item
同样地，证明来自初对象的推送（如果存在）是余积。
\end{enumerate}
