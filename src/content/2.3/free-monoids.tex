% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{单}{子是一个在范畴理论（category theory）和编程中都非常重要的概念}。范畴对应于强类型语言，而单子对应于无类型语言。这是因为在单子中你可以组合任意两个态射（arrow），就像在无类型语言中你可以组合任意两个函数一样（当然，当你执行程序时，可能会遇到运行时错误）。

我们已经看到，一个单子可以被描述为一个只有一个对象的范畴，其中所有逻辑都编码在态射组合的规则中。这种范畴模型与更传统的集合论单子定义完全等价，在集合论中我们“乘”两个元素得到第三个元素。这个“乘法”过程可以进一步拆分为首先形成一对元素，然后将这对元素与一个已有的元素——它们的“积”——相识别。

如果我们放弃乘法的第二部分——将对与现有元素相识别——会发生什么？例如，我们可以从一个任意的集合开始，形成所有可能的元素对，并称它们为新元素。然后我们将这些新元素与所有可能的元素配对，依此类推。这是一个链式反应——我们将永远添加新元素。结果，一个无限集合，将“几乎”是一个单子。但单子还需要一个单位元素和结合律。没问题，我们可以添加一个特殊的单位元素，并识别一些对——仅足以支持单位和结合律。

让我们看看在一个简单的例子中这是如何工作的。我们从一个由两个元素组成的集合 $\{a, b\}$ 开始。我们称它们为自由单子的生成元。首先，我们将添加一个特殊的元素 $e$ 作为单位。接下来我们将添加所有元素对，并称它们为“积”。$a$ 和 $b$ 的积将是对 $(a, b)$。$b$ 和 $a$ 的积将是对 $(b, a)$，$a$ 和 $a$ 的积将是对 $(a, a)$，$b$ 和 $b$ 的积将是对 $(b, b)$。我们还可以形成与 $e$ 的对，例如 $(a, e)$、$(e, b)$ 等，但我们将它们与 $a$、$b$ 等元素相识别。因此在这一轮中我们只会添加 $(a, a)$、$(a, b)$ 和 $(b, a)$ 以及 $(b, b)$，最终得到集合 $\{e, a, b, (a, a), (a, b), (b, a), (b, b)\}$。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{images/bunnies.jpg}
\end{figure}

\noindent
在下一轮中，我们将继续添加元素，如 $(a, (a, b))$、$((a, b), a)$ 等。这时我们必须确保结合律成立，因此我们将 $(a, (b, a))$ 与 $((a, b), a)$ 相识别。换句话说，我们不再需要内部的括号。

你可以猜到这个过程的最终结果：我们将创建所有可能的 $a$ 和 $b$ 列表。实际上，如果我们将 $e$ 表示为空列表，我们可以看到我们的“乘法”实际上就是列表连接。

这种构造方法，即你不断生成所有可能的元素组合，并进行最小量的识别——刚好足以维持定律——称为自由构造。我们刚才做的就是从生成元集合 $\{a, b\}$ 构造一个自由单子。

\section{Haskell 中的自由单子（Free Monoid in Haskell）}

Haskell 中的一个两元素集合等价于类型 \code{Bool}，由这个集合生成的自由单子等价于类型 \code{{[}Bool{]}}（\code{Bool} 的列表）。（我有意忽略了无限列表的问题。）

Haskell 中的单子通过类型类定义如下：

\src{snippet01}
这只是说每个 \code{Monoid} 都必须有一个中性元素，称为 \code{mempty}，以及一个二元函数（乘法）称为 \code{mappend}。单位和结合律不能在 Haskell 中表达，必须由程序员在每次实例化单子时验证。

列表的任意类型形成一个单子的事实通过以下实例定义描述：

\src{snippet02}
这表明空列表 \code{{[}{]}} 是单位元素，而列表连接 \code{(++)} 是二元操作。

正如我们所见，类型 \code{a} 的列表对应于一个以集合 \code{a} 作为生成元的自由单子。以乘法为运算的自然数集合并不是一个自由单子，因为我们识别了很多积。例如，比较：

\src{snippet03}
那很容易，但问题是，我们能否在范畴理论中进行这种自由构造，在那里我们不允许查看对象的内部？我们将使用我们的常用工具：泛范式（universal construction）。

第二个有趣的问题是，是否可以通过在某些自由单子中识别超过所需最小数量的元素，得到任何单子？我将向你展示这直接来自于泛范式。

\section{自由单子的泛范式（Free Monoid Universal Construction）}

如果你回想我们之前对泛范式的体验，你可能会注意到，这不只是关于构造某物，而是关于选择最适合给定模式的对象。因此，如果我们想使用泛范式“构造”一个自由单子，我们必须考虑一大堆单子以供选择。我们需要一个完整的单子范畴来选择。但单子能形成一个范畴吗？

首先让我们将单子看作由单位和乘法定义的集合。我们选择作为态射的那些保持单子结构的函数。这种保持结构的函数称为同态（homomorphism）。一个单子同态必须将两个元素的积映射为这两个元素映射的积：

\src{snippet04}
并且必须将单位映射为单位。

例如，考虑一个从整数列表到整数的同态。如果我们将 \code{{[}2{]}} 映射为 2，将 \code{{[}3{]}} 映射为 3，我们必须将 \code{{[}2, 3{]}} 映射为 6，因为连接

\src{snippet05}
变成了乘法

\src{snippet06}
现在让我们忘记单个单子的内部结构，只看它们作为对象以及相应的态射。你会得到一个单子范畴 $\cat{Mon}$。

好了，可能在我们忘记内部结构之前，让我们注意一个重要的属性。$\cat{Mon}$ 的每个对象都可以被平凡地映射到一个集合。它只是其元素的集合。这个集合称为基础集合（underlying set）。事实上，我们不仅可以将 $\cat{Mon}$ 的对象映射到集合，还可以将 $\cat{Mon}$ 的态射（同态）映射为函数。同样，这似乎是琐碎的，但它很快就会变得有用。这个从 $\cat{Mon}$ 到 $\Set$ 的对象和态射映射实际上是一个函子（functor）。由于这个函子“遗忘”了单子结构——一旦我们进入普通集合，我们就不再区分单位元素或关心乘法——它被称为遗忘函子（forgetful functor）。遗忘函子在范畴理论中经常出现。

我们现在对 $\cat{Mon}$ 有两种不同的看法。我们可以像对待任何其他范畴一样对待它，具有对象和态射。在这种观点中，我们看不到单子的内部结构。我们对 $\cat{Mon}$ 中的特定对象所能说的只是它通过态射连接到自己和其他对象。态射的“乘法”表——组合规则——来源于另一种视角：单子作为集合。通过进入范畴理论，我们并没有完全失去这种视角——我们仍然可以通过我们的遗忘函子访问它。

为了应用泛范式，我们需要定义一个特殊属性，以便我们可以在单子范畴中搜索并选择自由单子的最佳候选者。但自由单子是由其生成元定义的。不同的生成元选择会产生不同的自由单子（\code{Bool} 的列表与 \code{Int} 的列表不同）。我们的构造必须从一组生成元开始。所以我们又回到了集合！

这就是遗忘函子派上用场的地方。我们可以用它来对单子进行 X 光成像。我们可以在这些 blob 的 X 光图像中识别生成元。它是这样工作的：

我们从一组生成元 $x$ 开始。这是 $\Set$ 中的一个集合。

我们要匹配的模式由单子 $m$——$\cat{Mon}$ 的一个对象——和 $\Set$ 中的一个函数 $p$ 组成：

\src{snippet07}
其中 $U$ 是我们的从 $\cat{Mon}$ 到 $\Set$ 的遗忘函子。这是一个奇怪的异质模式——一半在 $\cat{Mon}$ 中，一半在 $\Set$ 中。

这个想法是函数 $p$ 将在 $m$ 的 X 光图像中识别生成元。函数可能在识别集合中的点时表现不佳（它们可能会坍缩它们）。这一切都将通过泛范式解决，泛范式将选择该模式的最佳代表。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/monoid-pattern.jpg}
\end{figure}

\noindent
我们还必须定义候选者之间的排序。假设我们有另一个候选者：单子 $n$ 及其 X 光图像中的生成元识别函数：

\src{snippet08}
我们将说 $m$ 比 $n$ 更好，如果存在一个单子态射（这是一个保持结构的同态）：

\src{snippet09}
它在 $U$ 下的像（记住，$U$ 是一个函子，所以它将态射映射为函数）通过 $p$ 因式分解：

\src{snippet10}
如果你将 $p$ 视为在 $m$ 中选择生成元，并将 $q$ 视为在 $n$ 中选择“相同”的生成元，那么你可以将 $h$ 视为在两个单子之间映射这些生成元。记住，$h$ 按定义保持单子结构。这意味着一个单子中两个生成元的积将被映射为第二个单子中相应两个生成元的积，依此类推。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/monoid-ranking.jpg}
\end{figure}

\noindent
这个排序可用于找到最佳候选者——自由单子。定义如下：

\begin{quote}
  我们将说 $m$（连同函数 $p$）是具有生成元 $x$ 的\textbf{自由单子}，当且仅当存在一个从 $m$ 到任何其他单子 $n$（连同函数 $q$）的\emph{唯一}态射 $h$ 满足上述因式分解属性。
\end{quote}
顺便说一下，这回答了我们第二个问题。函数 $U h$ 有能力将 $U m$ 的多个元素坍缩为 $U n$ 的单个元素。这种坍缩对应于识别自由单子中的某些元素。因此，任何具有生成元 $x$ 的单子都可以通过识别一些元素从基于 $x$ 的自由单子中获得。自由单子是一个只做了最小量识别的单子。

当我们讨论伴随（adjunction）时，我们将回到自由单子。

\section{挑战（Challenges）}

\begin{enumerate}
  \tightlist
  \item
  你可能会认为（正如我最初所想）保持单子同态的单位的要求是多余的。毕竟，我们知道对于所有 $a$ 都有

  \begin{snip}{text}
    h a * h e = h (a * e) = h a
  \end{snip}
  因此 $h e$ 作为右单位（同理作为左单位）起作用。问题是，所有 $a$ 的 $h a$ 可能只覆盖目标单子的一个子单子。可能存在一个“真正的”单位在 $h$ 的像之外。证明保持乘法的单子之间的同构必须自动保持单位。
  \item
  考虑一个从整数列表（连接）到整数（乘法）的单子同态。空列表 \code{{[}{]}} 的像是什么？假设所有单一列表都被映射为它们包含的整数，即 \code{{[}3{]}} 被映射为 3 等。 \code{{[}1, 2, 3, 4{]}} 的像是什么？有多少个不同的列表映射到整数 12？是否存在这两个单子之间的其他同态？
  \item
  由一个元素集生成的自由单子是什么？你能看到它同构于什么吗？
\end{enumerate}
